{"task_id": "rotate100", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'h1) begin\n        q <= {q[98:0], 1'b0};\n    end else if (ena == 2'h2) begin\n        q <= {1'b0, q[99:1]};\n    end\nend\nendmodule"]}
{"task_id": "dff8ar", "doubao_output": ["always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "lemmings1", "doubao_output": ["    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    // Combinational logic for next state\n    wire next_state;\n    assign next_state = (state == WL)? (bump_left? WR : WL) : (bump_right? WL : WR);\n\n    // State update on positive edge of clk or areset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output assignment based on current state\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            WL: next_state = bump_left ? WR : WL;\n            WR: next_state = bump_right ? WL : WR;\n            default: next_state = WL;\n        endcase\n    end\n\n    // State update on positive edge of clk or areset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign outputs based on current state\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            case (state)\n                WL: state <= bump_left? WR : WL;\n                WR: state <= bump_right? WL : WR;\n                default: state <= WL;\n            endcase\n        end\n    end\n\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            case (state)\n                WL: state <= bump_left ? WR : WL;\n                WR: state <= bump_right ? WL : WR;\n                default: state <= WL;\n            endcase\n        end\n    end\n\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            case (state)\n                WL: state <= bump_left ? WR : WL;\n                WR: state <= bump_right ? WL : WR;\n                default: state <= WL;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            case (state)\n                WL: state <= bump_left? WR : WL;\n                WR: state <= bump_right? WL : WR;\n                default: state <= WL;\n            endcase\n        end\n    end\n\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            case (state)\n                WL: state <= bump_left ? WR : WL;\n                WR: state <= bump_right ? WL : WR;\n                default: state <= WL;\n            endcase\n        end\n    end\n\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    // Combinational logic to determine next state\n    wire next_state;\n    assign next_state = (state == WL)? (bump_left? WR : WL) : (bump_right? WL : WR);\n\n    // State update on positive edge of clk or areset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign outputs based on current state\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            case (state)\n                WL: state <= bump_left ? WR : WL;\n                WR: state <= bump_right ? WL : WR;\n                default: state <= WL;\n            endcase\n        end\n    end\n\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule", "    parameter WL = 1'b0, WR = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            WL: next_state = bump_left ? WR : WL;\n            WR: next_state = bump_right ? WL : WR;\n            default: next_state = WL;\n        endcase\n    end\n\n    // State update on positive edge of clk or areset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output assignment based on current state\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n\nendmodule"]}
{"task_id": "2013_q2afsm", "doubao_output": ["    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: begin\n                if (r[1]) next = B;\n                else next = A;\n            end\n            C: begin\n                if (r[2]) next = C;\n                else next = A;\n            end\n            D: begin\n                if (r[3]) next = D;\n                else next = A;\n            end\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n            default: g = 3'b000;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: next = r[1] ? B : A;\n            C: next = r[2] ? C : A;\n            D: next = r[3] ? D : A;\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    assign g = (state == B) ? 3'b010 :\n               (state == C) ? 3'b100 :\n               (state == D) ? 3'b1000 : 3'b000;\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: begin\n                if (r[1]) next = B;\n                else next = A;\n            end\n            C: begin\n                if (r[2]) next = C;\n                else next = A;\n            end\n            D: begin\n                if (r[3]) next = D;\n                else next = A;\n            end\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: next = r[1]? B : A;\n            C: next = r[2]? C : A;\n            D: next = r[3]? D : A;\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: begin\n                if (r[1]) next = B;\n                else next = A;\n            end\n            C: begin\n                if (r[2]) next = C;\n                else next = A;\n            end\n            D: begin\n                if (r[3]) next = D;\n                else next = A;\n            end\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: begin\n                if (r[1]) next = B;\n                else next = A;\n            end\n            C: begin\n                if (r[2]) next = C;\n                else next = A;\n            end\n            D: begin\n                if (r[3]) next = D;\n                else next = A;\n            end\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: next = r[1]? B : A;\n            C: next = r[2]? C : A;\n            D: next = r[3]? D : A;\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: begin\n                if (r[1]) next = B;\n                else next = A;\n            end\n            C: begin\n                if (r[2]) next = C;\n                else next = A;\n            end\n            D: begin\n                if (r[3]) next = D;\n                else next = A;\n            end\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: begin\n                if (r[1]) next = B;\n                else next = A;\n            end\n            C: begin\n                if (r[2]) next = C;\n                else next = A;\n            end\n            D: begin\n                if (r[3]) next = D;\n                else next = A;\n            end\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next;\n\n    // State register update\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next = B;\n                else if (r[2]) next = C;\n                else if (r[3]) next = D;\n                else next = A;\n            end\n            B: begin\n                if (r[1]) next = B;\n                else next = A;\n            end\n            C: begin\n                if (r[2]) next = C;\n                else next = A;\n            end\n            D: begin\n                if (r[3]) next = D;\n                else next = A;\n            end\n            default: next = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case (state)\n            B: g[1] = 1'b1;\n            C: g[2] = 1'b1;\n            D: g[3] = 1'b1;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "review2015_count1k", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b0;\n    end else if (q == 10'd999) begin\n        q <= 10'b0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b0;\n    end else if (q == 10'd999) begin\n        q <= 10'b0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 1'b1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b0;\n    end else if (q == 10'd999) begin\n        q <= 10'b0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b0;\n    end else if (q == 10'd999) begin\n        q <= 10'b0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b0;\n    end else if (q == 10'd999) begin\n        q <= 10'b0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 1'b1;\n    end\nend\nendmodule"]}
{"task_id": "m2014_q4e", "doubao_output": ["assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule"]}
{"task_id": "vector4", "doubao_output": ["assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule", "assign out = { {24{in}}, in };\nendmodule"]}
{"task_id": "zero", "doubao_output": ["assign zero = 0;\nendmodule", "assign zero = 0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 0;\nendmodule", "assign zero = 0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 0;\nendmodule", "assign zero = 1'b0;\nendmodule"]}
{"task_id": "always_if2", "doubao_output": ["always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1'b1;\n    end else begin\n        shut_off_computer <= 1'b0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 1'b0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (cpu_overheated) begin\n        shut_off_computer <= 1;\n    end else begin\n        shut_off_computer <= 0;\n    end\nend\n\nalways @(posedge clk) begin\n    if (!arrived) begin\n        keep_driving <= ~gas_tank_empty;\n    end else begin\n        keep_driving <= 0;\n    end\nend\n\nendmodule"]}
{"task_id": "counter_2bc", "doubao_output": ["always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken && state < 2'b11) begin\n            state <= state + 1;\n        end else if (!train_taken && state > 2'b00) begin\n            state <= state - 1;\n        end\n    end\nend\nendmodule", "    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1;\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\n\nendmodule", "    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1;\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken && state < 2'b11) begin\n            state <= state + 1;\n        end else if (!train_taken && state > 2'b00) begin\n            state <= state - 1;\n        end\n    end\nend\n\nendmodule", "    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1;\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken && state < 2'b11) begin\n            state <= state + 1;\n        end else if (!train_taken && state > 2'b00) begin\n            state <= state - 1;\n        end\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken && state < 2'b11) begin\n            state <= state + 1;\n        end else if (!train_taken && state > 2'b00) begin\n            state <= state - 1;\n        end\n    end\nend\n\nendmodule", "    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1;\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken && state < 2'b11) begin\n            state <= state + 1;\n        end else if (!train_taken && state > 2'b00) begin\n            state <= state - 1;\n        end\n    end\nend\n\nendmodule", "    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1;\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nendmodule"]}
{"task_id": "circuit1", "doubao_output": ["assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule"]}
{"task_id": "andgate", "doubao_output": ["assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule"]}
{"task_id": "step_one", "doubao_output": ["assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule"]}
{"task_id": "count1to10", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else begin\n        if (q == 4'b1010) begin\n            q <= 4'b0001;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else begin\n        if (q == 4'b1010) begin\n            q <= 4'b0001;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else begin\n        if (q == 4'b1010) begin\n            q <= 4'b0001;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule"]}
{"task_id": "m2014_q4d", "doubao_output": ["always_ff @(posedge clk) begin\n    if ($time == 0) begin\n        out <= 0;\n    end else begin\n        out <= in ^ out;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "initial begin\n    out = 0;\nend\n\nalways_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "initial begin\n    out = 0;\nend\n\nalways_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "initial begin\n    out = 0;\nend\n\nalways_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule"]}
{"task_id": "fsm1", "doubao_output": ["    // Define state parameters\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    // Internal state variable\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_B;\n        end else begin\n            case (state)\n                STATE_A: state <= in ? STATE_A : STATE_B;\n                STATE_B: state <= in ? STATE_B : STATE_A;\n                default: state <= STATE_B;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define state parameters\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_B;\n        end else begin\n            case (state)\n                STATE_A: state <= in ? STATE_A : STATE_B;\n                STATE_B: state <= in ? STATE_B : STATE_A;\n                default: state <= STATE_B;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // Current state register\n    reg current_state;\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            STATE_B: begin\n                if (in) begin\n                    next_state = STATE_B;\n                end else begin\n                    next_state = STATE_A;\n                end\n            end\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    // State update on positive clock edge or asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_B;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // Internal state register\n    reg current_state;\n    reg next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    // State update on clock edge\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_B;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define state parameters\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define state parameters\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_B;\n        end else begin\n            case (state)\n                STATE_A: state <= in ? STATE_A : STATE_B;\n                STATE_B: state <= in ? STATE_B : STATE_A;\n                default: state <= STATE_B;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define state parameters\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    // Declare state registers\n    reg current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    // State update on clock edge\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_B;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define state parameters\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in? STATE_A : STATE_B;\n            STATE_B: next_state = in? STATE_B : STATE_A;\n            default: next_state = STATE_B;\n        endcase\n    end\n\n    // State update on positive clock edge or asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define state parameters\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n\n    // Internal state register\n    reg current_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_B;\n        end else begin\n            case (current_state)\n                STATE_A: current_state <= in ? STATE_A : STATE_B;\n                STATE_B: current_state <= in ? STATE_B : STATE_A;\n                default: current_state <= STATE_B;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // Internal state register\n    reg current_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_B;\n        end else begin\n            case (current_state)\n                STATE_A: begin\n                    if (in) begin\n                        current_state <= STATE_A;\n                    end else begin\n                        current_state <= STATE_B;\n                    end\n                end\n                STATE_B: begin\n                    if (in) begin\n                        current_state <= STATE_B;\n                    end else begin\n                        current_state <= STATE_A;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule"]}
{"task_id": "dff16e", "doubao_output": ["always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule"]}
{"task_id": "conditional", "doubao_output": ["always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always_comb begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule"]}
{"task_id": "gates4", "doubao_output": ["assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule"]}
{"task_id": "mux256to1v", "doubao_output": ["assign out = in[sel*4 +: 4];\nendmodule", "assign out = in[sel*4 +: 4];\nendmodule", "assign out = in[(sel * 4) +: 4];\nendmodule", "assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule", "assign out = in[sel*4 +: 4];\nendmodule", "assign out = in[sel*4 +: 4];\nendmodule", "assign out = in[(sel * 4) +: 4];\nendmodule", "assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule", "assign out = in[sel*4 +: 4];\nendmodule", "assign out = in[sel*4 +: 4];\nendmodule"]}
{"task_id": "hadd", "doubao_output": ["assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule"]}
{"task_id": "ece241_2013_q7", "doubao_output": ["always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule", "always @(posedge clk) begin\n    Q <= (j & ~Q) | (~k & Q);\nend\nendmodule"]}
{"task_id": "ringer", "doubao_output": ["assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\nendmodule"]}
{"task_id": "timer", "doubao_output": ["reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\nassign tc = (counter == 0);\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\nassign tc = (counter == 0);\nendmodule", "reg [9:0] counter;\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\nassign tc = (counter == 0);\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\nassign tc = (counter == 0);\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule"]}
{"task_id": "circuit7", "doubao_output": ["always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule", "always @(posedge clk) begin\n    q <= ~a;\nend\nendmodule"]}
{"task_id": "gatesv100", "doubao_output": ["assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule"]}
{"task_id": "vector100r", "doubao_output": ["always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule", "always_comb begin\n    for (int i = 0; i < $bits(out); i = i + 1) begin\n        out[i] = in[$bits(out) - 1 - i];\n    end\nend\nendmodule"]}
{"task_id": "countslow", "doubao_output": ["always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule"]}
{"task_id": "mt2015_eq2", "doubao_output": ["assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B);\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule"]}
{"task_id": "always_case", "doubao_output": ["always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule"]}
{"task_id": "circuit3", "doubao_output": ["wire or_ab;\nwire or_cd;\n\nassign or_ab = a | b;\nassign or_cd = c | d;\nassign q = or_ab & or_cd;\n\nendmodule", "wire or_ab;\nwire or_cd;\n\nassign or_ab = a | b;\nassign or_cd = c | d;\nassign q = or_ab & or_cd;\n\nendmodule", "wire or_ab;\nwire or_cd;\n\nassign or_ab = a | b;\nassign or_cd = c | d;\nassign q = or_ab & or_cd;\n\nendmodule", "wire or_ab;\nwire or_cd;\n\nassign or_ab = a | b;\nassign or_cd = c | d;\nassign q = or_ab & or_cd;\n\nendmodule", "wire ab_or;\nwire cd_or;\n\nassign ab_or = a | b;\nassign cd_or = c | d;\nassign q = ab_or & cd_or;\n\nendmodule", "wire or_ab;\nwire or_cd;\n\nassign or_ab = a | b;\nassign or_cd = c | d;\nassign q = or_ab & or_cd;\n\nendmodule", "wire ab_or;\nwire cd_or;\nassign ab_or = a | b;\nassign cd_or = c | d;\nassign q = ab_or & cd_or;\nendmodule", "wire or_ab;\nwire or_cd;\n\nassign or_ab = a | b;\nassign or_cd = c | d;\nassign q = or_ab & or_cd;\n\nendmodule", "wire or_ab;\nwire or_cd;\n\nassign or_ab = a | b;\nassign or_cd = c | d;\nassign q = or_ab & or_cd;\n\nendmodule", "wire ab_or;\nwire cd_or;\nassign ab_or = a | b;\nassign cd_or = c | d;\nassign q = ab_or & cd_or;\nendmodule"]}
{"task_id": "alwaysblock2", "doubao_output": ["assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = out_assign;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= out_assign;\nend\n\nendmodule"]}
{"task_id": "mt2015_muxdff", "doubao_output": ["initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule", "initial begin\n    Q = 0;\nend\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q = r_in;\n    end else begin\n        Q = q_in;\n    end\nend\n\nendmodule"]}
{"task_id": "m2014_q4j", "doubao_output": ["assign sum = x + y;\nendmodule", "assign sum = {1'b0, x} + {1'b0, y};\nendmodule", "assign sum = x + y;\nendmodule", "assign sum = x + y;\nendmodule", "assign sum = {1'b0, x} + {1'b0, y};\nendmodule", "assign sum = {1'b0, x} + {1'b0, y};\nendmodule", "assign sum = {1'b0, x} + {1'b0, y};\nendmodule", "assign sum = {1'b0, x} + {1'b0, y};\nendmodule", "assign sum = x + y;\nendmodule", "assign sum = {1'b0, x} + {1'b0, y};\nendmodule"]}
{"task_id": "norgate", "doubao_output": ["assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule"]}
{"task_id": "fsm3comb", "doubao_output": ["always_comb begin\n    case (state)\n        2'b00: begin // State A\n            if (in) next_state = 2'b01; // Go to state B\n            else next_state = 2'b00; // Stay in state A\n        end\n        2'b01: begin // State B\n            if (in) next_state = 2'b01; // Stay in state B\n            else next_state = 2'b10; // Go to state C\n        end\n        2'b10: begin // State C\n            if (in) next_state = 2'b11; // Go to state D\n            else next_state = 2'b00; // Go to state A\n        end\n        2'b11: begin // State D\n            if (in) next_state = 2'b01; // Go to state B\n            else next_state = 2'b10; // Go to state C\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11);\n\nendmodule", "always_comb begin\n    case (state)\n        2'b00: begin // State A\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin // State B\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin // State C\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin // State D\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11);\n\nendmodule", "always_comb begin\n    case (state)\n        2'b00: begin // State A\n            if (in) next_state = 2'b01; // Go to state B\n            else next_state = 2'b00; // Stay in state A\n        end\n        2'b01: begin // State B\n            if (in) next_state = 2'b01; // Stay in state B\n            else next_state = 2'b10; // Go to state C\n        end\n        2'b10: begin // State C\n            if (in) next_state = 2'b11; // Go to state D\n            else next_state = 2'b00; // Go to state A\n        end\n        2'b11: begin // State D\n            if (in) next_state = 2'b01; // Go to state B\n            else next_state = 2'b10; // Go to state C\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11);\n\nendmodule", "always_comb begin\n    case (state)\n        2'b00: next_state = in ? 2'b01 : 2'b00;\n        2'b01: next_state = in ? 2'b01 : 2'b10;\n        2'b10: next_state = in ? 2'b11 : 2'b00;\n        2'b11: next_state = in ? 2'b01 : 2'b10;\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11);\n\nendmodule", "always_comb begin\n    case (state)\n        2'b00: next_state = in ? 2'b01 : 2'b00;\n        2'b01: next_state = in ? 2'b01 : 2'b10;\n        2'b10: next_state = in ? 2'b11 : 2'b00;\n        2'b11: next_state = in ? 2'b01 : 2'b10;\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11);\n\nendmodule", "always_comb begin\n    case (state)\n        2'b00: begin // State A\n            if (in) next_state = 2'b01; // Go to B\n            else next_state = 2'b00; // Stay in A\n        end\n        2'b01: begin // State B\n            if (in) next_state = 2'b01; // Stay in B\n            else next_state = 2'b10; // Go to C\n        end\n        2'b10: begin // State C\n            if (in) next_state = 2'b11; // Go to D\n            else next_state = 2'b00; // Go to A\n        end\n        2'b11: begin // State D\n            if (in) next_state = 2'b01; // Go to B\n            else next_state = 2'b10; // Go to C\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11);\n\nendmodule", "    always_comb begin\n        case (state)\n            2'b00: begin // State A\n                if (in) next_state = 2'b01; // Go to B\n                else next_state = 2'b00; // Stay in A\n            end\n            2'b01: begin // State B\n                if (in) next_state = 2'b01; // Stay in B\n                else next_state = 2'b10; // Go to C\n            end\n            2'b10: begin // State C\n                if (in) next_state = 2'b11; // Go to D\n                else next_state = 2'b00; // Go to A\n            end\n            2'b11: begin // State D\n                if (in) next_state = 2'b01; // Go to B\n                else next_state = 2'b10; // Go to C\n            end\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "    always_comb begin\n        case (state)\n            2'b00: begin // State A\n                if (in) next_state = 2'b01; // Go to state B\n                else next_state = 2'b00; // Stay in state A\n            end\n            2'b01: begin // State B\n                if (in) next_state = 2'b01; // Stay in state B\n                else next_state = 2'b10; // Go to state C\n            end\n            2'b10: begin // State C\n                if (in) next_state = 2'b11; // Go to state D\n                else next_state = 2'b00; // Go to state A\n            end\n            2'b11: begin // State D\n                if (in) next_state = 2'b01; // Go to state B\n                else next_state = 2'b10; // Go to state C\n            end\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "    always_comb begin\n        case (state)\n            2'b00: begin // State A\n                if (in) next_state = 2'b01;\n                else next_state = 2'b00;\n            end\n            2'b01: begin // State B\n                if (in) next_state = 2'b01;\n                else next_state = 2'b10;\n            end\n            2'b10: begin // State C\n                if (in) next_state = 2'b11;\n                else next_state = 2'b00;\n            end\n            2'b11: begin // State D\n                if (in) next_state = 2'b01;\n                else next_state = 2'b10;\n            end\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule", "    always_comb begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00;\n            2'b01: next_state = in ? 2'b01 : 2'b10;\n            2'b10: next_state = in ? 2'b11 : 2'b00;\n            2'b11: next_state = in ? 2'b01 : 2'b10;\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    assign out = (state == 2'b11);\n\nendmodule"]}
{"task_id": "history_shift", "doubao_output": ["always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else begin\n        if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nend\n\nendmodule"]}
{"task_id": "bugs_addsubz", "doubao_output": ["always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n        default: out = 8'b0;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n        default: out = 8'b0;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n        default: out = 8'b0;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n        default: out = 8'b0;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule", "always @(*) begin\n    case (do_sub)\n        1'b0: out = a + b;\n        1'b1: out = a - b;\n        default: out = 8'b0;\n    endcase\n    result_is_zero = (out == 8'b0);\nend\nendmodule"]}
{"task_id": "truthtable1", "doubao_output": ["assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule", "assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule"]}
{"task_id": "circuit5", "doubao_output": ["always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'hf;\n        endcase\n    end\nendmodule", "always @(posedge clk) begin\n    case (c)\n        4'd0: q <= b;\n        4'd1: q <= e;\n        4'd2: q <= a;\n        4'd3: q <= d;\n        default: q <= 4'hf;\n    endcase\nend\nendmodule"]}
{"task_id": "m2014_q4f", "doubao_output": ["assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule"]}
{"task_id": "mt2015_q4a", "doubao_output": ["assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule", "assign z = x & (x ^ y);\nendmodule"]}
{"task_id": "dff8p", "doubao_output": ["always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "notgate", "doubao_output": ["assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule"]}
{"task_id": "wire4", "doubao_output": ["assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule"]}
{"task_id": "circuit6", "doubao_output": ["always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'd0: q = 16'd4658;\n        3'd1: q = 16'd44768;\n        3'd2: q = 16'd10196;\n        3'd3: q = 16'd23054;\n        3'd4: q = 16'd8294;\n        3'd5: q = 16'd25806;\n        3'd6: q = 16'd50470;\n        3'd7: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'd4658;\n        3'b001: q = 16'd44768;\n        3'b010: q = 16'd10196;\n        3'b011: q = 16'd23054;\n        3'b100: q = 16'd8294;\n        3'b101: q = 16'd25806;\n        3'b110: q = 16'd50470;\n        3'b111: q = 16'd12057;\n        default: q = 16'd0;\n    endcase\nend\nendmodule"]}
{"task_id": "always_casez", "doubao_output": ["always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule", "always @(*) begin\n    casez (in)\n        8'bzzzzzzz1: pos = 3'h0;\n        8'bzzzzzz1z: pos = 3'h1;\n        8'bzzzzz1zz: pos = 3'h2;\n        8'bzzzz1zzz: pos = 3'h3;\n        8'bzzz1zzzz: pos = 3'h4;\n        8'bzz1zzzzz: pos = 3'h5;\n        8'bz1zzzzzz: pos = 3'h6;\n        8'b1zzzzzzz: pos = 3'h7;\n        default: pos = 3'h0;\n    endcase\nend\nendmodule"]}
{"task_id": "alwaysblock1", "doubao_output": ["assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule"]}
{"task_id": "fsm2", "doubao_output": ["    // Define states\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg current_state, next_state;\n\n    // Combinational always block to determine next state\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Clocked always block to update the state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define states\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational always block to determine next state\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Clocked always block to update state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign out based on current state\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // Current state and next state variables\n    reg current_state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Sequential logic to update state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Parameter definition for states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // Combinational always block to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = j ? B : A;\n            B: next_state = k ? A : B;\n            default: next_state = A;\n        endcase\n    end\n\n    // Clocked always block to update state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // Current state and next state variables\n    reg current_state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Sequential logic to update current state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // Current state and next state variables\n    reg current_state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Sequential logic to update current state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // Current state and next state variables\n    reg current_state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Sequential logic to update current state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define states\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational always block to determine next state\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Clocked always block to update state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign out based on current state\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational always block to determine next state\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Clocked always block to update state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define states\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n    reg current_state, next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = j ? STATE_B : STATE_A;\n            STATE_B: next_state = k ? STATE_A : STATE_B;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Sequential logic to update state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule"]}
{"task_id": "m2014_q4g", "doubao_output": ["assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule", "assign out = ~(in1 ^ in2) ^ in3;\nendmodule"]}
{"task_id": "mt2015_q4b", "doubao_output": ["assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule", "assign z = ~(x ^ y);\nendmodule"]}
{"task_id": "kmap2", "doubao_output": ["assign out = (!c &&!b) || (!d &&!a) || (a && c && d) || (b && c && d);\nendmodule", "assign out = (!c &&!b) || (!d &&!a) || (a && c && d) || (b && c && d);\nendmodule", "assign out = (!c &&!b) || (!d &&!a) || (a && c && d) || (b && c && d);\nendmodule", "assign out = (!c &&!b) || (!d &&!a) || (a && c && d) || (b && c && d);\nendmodule", "assign out = ((~c & ~b) | (~d & ~a) | (a & c & d) | (b & c & d));\nendmodule", "assign out = ((~c & ~b) | (~d & ~a) | (a & c & d) | (b & c & d));\nendmodule", "assign out = ((~c & ~b) | (~d & ~a) | (a & c & d) | (b & c & d));\nendmodule", "assign out = (!c &&!b) || (!d &&!a) || (a && c && d) || (b && c && d);\nendmodule", "assign out = ((~c & ~b) | (~d & ~a) | (a & c & d) | (b & c & d));\nendmodule", "assign out = (!c &&!b) || (!d &&!a) || (a && c && d) || (b && c && d);\nendmodule"]}
{"task_id": "vector1", "doubao_output": ["assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule"]}
{"task_id": "vector0", "doubao_output": ["assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule"]}
{"task_id": "review2015_shiftcount", "doubao_output": ["always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule"]}
{"task_id": "dff8", "doubao_output": ["    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n    always @(posedge clk) begin\n        q = d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "    initial begin\n        q = 8'h0;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"]}
{"task_id": "xnorgate", "doubao_output": ["assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule"]}
{"task_id": "fsm3", "doubao_output": ["    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Parameterize the states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define the states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // Combinational logic to determine the next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state constants\n    localparam STATE_A = 2'b00;\n    localparam STATE_B = 2'b01;\n    localparam STATE_C = 2'b10;\n    localparam STATE_D = 2'b11;\n\n    // State register\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in ? STATE_B : STATE_A;\n            STATE_B: next_state = in ? STATE_B : STATE_C;\n            STATE_C: next_state = in ? STATE_D : STATE_A;\n            STATE_D: next_state = in ? STATE_B : STATE_C;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_D);\n\nendmodule", "    // Parameterize the states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state constants\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // State register\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define the states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define the states\n    localparam STATE_A = 2'b00;\n    localparam STATE_B = 2'b01;\n    localparam STATE_C = 2'b10;\n    localparam STATE_D = 2'b11;\n\n    // State register\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = in ? STATE_B : STATE_A;\n            STATE_B: next_state = in ? STATE_B : STATE_C;\n            STATE_C: next_state = in ? STATE_D : STATE_A;\n            STATE_D: next_state = in ? STATE_B : STATE_C;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_D);\n\nendmodule"]}
{"task_id": "mux2to1", "doubao_output": ["assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel? b : a;\nendmodule"]}
{"task_id": "dff", "doubao_output": ["initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule", "initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule", "initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule", "initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule", "initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule", "initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule", "    initial begin\n        q = 1'hx;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule", "    initial begin\n        q = 1'hx;\n    end\n\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule", "initial begin\n    q = 1'hx;\nend\n\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule"]}
{"task_id": "7420", "doubao_output": ["assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule"]}
{"task_id": "fsm2s", "doubao_output": ["    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= j ? B : A;\n                B: state <= k ? A : B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= j ? B : A;\n                B: state <= k ? A : B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define state parameters\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: begin\n                    if (j) begin\n                        state <= B;\n                    end else begin\n                        state <= A;\n                    end\n                end\n                B: begin\n                    if (k) begin\n                        state <= A;\n                    end else begin\n                        state <= B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= j ? B : A;\n                B: state <= k ? A : B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= STATE_A;\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (j) begin\n                        state <= STATE_B;\n                    end else begin\n                        state <= STATE_A;\n                    end\n                end\n                STATE_B: begin\n                    if (k) begin\n                        state <= STATE_A;\n                    end else begin\n                        state <= STATE_B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define the states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = j ? B : A;\n            B: next_state = k ? A : B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flop\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define the states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n    reg current_state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (j) begin\n                    next_state = STATE_B;\n                end else begin\n                    next_state = STATE_A;\n                end\n            end\n            STATE_B: begin\n                if (k) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= STATE_A;\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (j) begin\n                        state <= STATE_B;\n                    end else begin\n                        state <= STATE_A;\n                    end\n                end\n                STATE_B: begin\n                    if (k) begin\n                        state <= STATE_A;\n                    end else begin\n                        state <= STATE_B;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == STATE_B);\n\nendmodule", "    // Define the states\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    reg current_state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (j) begin\n                    next_state = STATE_B;\n                end else begin\n                    next_state = STATE_A;\n                end\n            end\n            STATE_B: begin\n                if (k) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B);\n\nendmodule", "    // Define the states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= j ? B : A;\n                B: state <= k ? A : B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule"]}
{"task_id": "m2014_q4b", "doubao_output": ["always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "fadd", "doubao_output": ["assign {cout, sum} = a + b + cin;\nendmodule", "assign {cout, sum} = a + b + cin;\n\nendmodule", "assign {cout, sum} = a + b + cin;\nendmodule", "assign {cout, sum} = a + b + cin;\nendmodule", "assign {cout, sum} = a + b + cin;\n\nendmodule", "assign {cout, sum} = a + b + cin;\n\nendmodule", "assign {cout, sum} = a + b + cin;\nendmodule", "assign {cout, sum} = a + b + cin;\nendmodule", "assign {cout, sum} = a + b + cin;\n\nendmodule", "assign {cout, sum} = a + b + cin;\n\nendmodule"]}
{"task_id": "m2014_q4k", "doubao_output": ["    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule", "    reg [3:0] sr;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            sr <= 4'b0000;\n        end else begin\n            sr <= {sr[2:0], in};\n        end\n    end\n\n    assign out = sr[3];\n\nendmodule"]}
{"task_id": "mux256to1", "doubao_output": ["assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule"]}
{"task_id": "vectorgates", "doubao_output": ["assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = a || b;\nassign out_not = {~b, ~a};\nendmodule"]}
{"task_id": "count10", "doubao_output": ["always @(posedge clk) begin\n    if (reset || q == 4'd9) begin\n        q <= 4'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset || q == 4'd9) begin\n        q <= 4'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "    always @(posedge clk) begin\n        if (reset || q == 4'd9) begin\n            q <= 4'd0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nendmodule", "always @(posedge clk) begin\n    if (reset || q == 4'd9) begin\n        q <= 4'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "    always @(posedge clk) begin\n        if (reset || q == 4'd9) begin\n            q <= 4'd0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nendmodule", "always @(posedge clk) begin\n    if (reset || q == 4'd9) begin\n        q <= 4'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset || q == 4'd9) begin\n        q <= 4'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset || q == 4'd9) begin\n        q <= 4'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset || q == 4'd9) begin\n        q <= 4'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "    always @(posedge clk) begin\n        if (reset || q == 4'd9) begin\n            q <= 4'd0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nendmodule"]}
{"task_id": "kmap4", "doubao_output": ["always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule", "always @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0;\n        4'b0001: out = 0;\n        4'b0010: out = 0;\n        4'b0011: out = 0;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 0;\n        4'b0111: out = 0;\n        4'b1000: out = 0;\n        4'b1001: out = 0;\n        4'b1010: out = 0;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 0;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\nendmodule"]}
{"task_id": "wire", "doubao_output": ["    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    parameter IDLE = 2'b00, WAIT = 2'b01, PROCESS = 2'b10, DONE = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'b0000;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'b0000;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == 4'b1111) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign out = data_out;\n    assign valid = valid_out;\n\nendmodule", "    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    parameter IDLE = 2'b00, WAIT = 2'b01, PROCESS = 2'b10, DONE = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'b0000;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'b0000;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == 4'd5) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign out = data_out;\n    assign valid = valid_out;\n\nendmodule", "    // Define states\n    localparam IDLE = 2'b00;\n    localparam WAIT = 2'b01;\n    localparam PROCESS = 2'b10;\n    localparam DONE = 2'b11;\n\n    // Internal signals\n    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    // Threshold for counter\n    localparam THRESHOLD = 4'd5;\n\n    // State machine logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'd0;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'd0;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == THRESHOLD) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    // Assign outputs\n    assign out = data_out;\n    assign valid = valid_out;\n\nendmodule", "    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    parameter IDLE = 2'b00, WAIT = 2'b01, PROCESS = 2'b10, DONE = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'b0000;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'b0000;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == 4'b1111) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign out = data_out;\n\nendmodule", "    // Define states\n    localparam IDLE = 2'b00;\n    localparam WAIT = 2'b01;\n    localparam PROCESS = 2'b10;\n    localparam DONE = 2'b11;\n\n    // Internal signals\n    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    // Threshold for counter\n    localparam THRESHOLD = 4'd5;\n\n    // State machine logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'd0;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'd0;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == THRESHOLD) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    // Assign outputs\n    assign out = data_out;\n    assign valid = valid_out;\n\nendmodule", "    // Internal signals\n    reg [1:0] state;\n    reg [3:0] counter;\n    wire [7:0] data;\n    wire valid;\n\n    // Parameter for counter threshold\n    parameter THRESHOLD = 4'd5;\n\n    // State definitions\n    localparam IDLE = 2'b00;\n    localparam WAIT = 2'b01;\n    localparam PROCESS = 2'b10;\n    localparam DONE = 2'b11;\n\n    // Stimulus generator instance\n    stimulus_gen stim_gen (\n      .clk(clk),\n      .reset(reset),\n      .data(data),\n      .valid(valid)\n    );\n\n    // State machine logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'd0;\n            out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'd0;\n                    out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    out <= 1'b0;\n                    if (counter == THRESHOLD) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    out <= data;\n                    state <= DONE;\n                end\n                DONE: begin\n                    out <= data;\n                    if (valid) begin\n                        state <= IDLE;\n                    end\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule", "    // Define states\n    localparam IDLE = 2'b00;\n    localparam WAIT = 2'b01;\n    localparam PROCESS = 2'b10;\n    localparam DONE = 2'b11;\n\n    // Internal signals\n    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    // Threshold for counter\n    localparam THRESHOLD = 4'd5;\n\n    // State transitions and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'd0;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'd0;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == THRESHOLD) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    // Assign outputs\n    assign out = data_out;\n    assign valid = valid_out;\n\nendmodule", "    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    parameter IDLE = 2'b00, WAIT = 2'b01, PROCESS = 2'b10, DONE = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'b0000;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'b0000;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == 4'b1111) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign out = data_out;\n\nendmodule", "    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    parameter IDLE = 2'b00, WAIT = 2'b01, PROCESS = 2'b10, DONE = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'b0000;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'b0000;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == 4'd5) begin // Threshold value of 5, can be adjusted\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\n    assign out = data_out;\n\nendmodule", "    reg [1:0] state;\n    reg [3:0] counter;\n    reg data_out;\n    reg valid_out;\n\n    parameter IDLE = 2'b00, WAIT = 2'b01, PROCESS = 2'b10, DONE = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counter <= 4'b0000;\n            data_out <= 1'b0;\n            valid_out <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= 4'b0000;\n                    data_out <= 1'b0;\n                    state <= WAIT;\n                end\n                WAIT: begin\n                    counter <= counter + 1;\n                    data_out <= 1'b0;\n                    if (counter == 4'b1111) begin\n                        state <= PROCESS;\n                    end\n                end\n                PROCESS: begin\n                    data_out <= in;\n                    state <= DONE;\n                end\n                DONE: begin\n                    valid_out <= 1'b1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    assign out = data_out;\n    assign valid = valid_out;\n\nendmodule"]}
{"task_id": "ece241_2014_q5b", "doubao_output": ["parameter A = 1'b0, B = 1'b1;\nreg state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= A;\n    end else begin\n        case (state)\n            A: state <= x ? B : A;\n            B: state <= B;\n        endcase\n    end\nend\n\nassign z = ((state == A) && x) || ((state == B) && !x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) && !x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) && !x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= (x)? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) &&!x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= (x) ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) && ~x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) &&!x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= (x)? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A && x) || (state == B &&!x));\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= (x)? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) &&!x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= (x) ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) && !x);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= (x) ? B : A;\n                B: state <= B;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = ((state == A) && x) || ((state == B) && !x);\n\nendmodule"]}
{"task_id": "gates100", "doubao_output": ["assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule"]}
{"task_id": "dualedge", "doubao_output": ["reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\n\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\n\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\n\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\n\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\n\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\n\nendmodule", "reg qp;\nreg qn;\n\nalways @(posedge clk) begin\n    qp <= d;\nend\n\nalways @(negedge clk) begin\n    qn <= d;\nend\n\nalways @(*) begin\n    if (clk) begin\n        q = qp;\n    end else begin\n        q = qn;\n    end\nend\nendmodule"]}
{"task_id": "mux2to1v", "doubao_output": ["assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule"]}
{"task_id": "edgedetect2", "doubao_output": ["reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\nend\n\nendmodule"]}
{"task_id": "ece241_2014_q3", "doubao_output": ["assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = ~d;\nassign mux_in[3] = c & d;\nendmodule"]}
{"task_id": "circuit10", "doubao_output": ["reg c;\n\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\n\nassign q = a ^ b ^ c;\nassign state = c;\n\nendmodule", "reg c;\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\nassign q = a ^ b ^ c;\nassign state = c;\nendmodule", "reg c;\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\nassign q = a ^ b ^ c;\nassign state = c;\nendmodule", "reg c;\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\nassign q = a ^ b ^ c;\nassign state = c;\nendmodule", "reg c;\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\nassign q = a ^ b ^ c;\nassign state = c;\nendmodule", "reg c;\n\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\n\nassign q = a ^ b ^ c;\nassign state = c;\n\nendmodule", "reg c;\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\nassign q = a ^ b ^ c;\nassign state = c;\nendmodule", "reg c;\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\nassign q = a ^ b ^ c;\nassign state = c;\nendmodule", "reg c;\n\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\n\nassign q = a ^ b ^ c;\nassign state = c;\n\nendmodule", "reg c;\n\nalways @(posedge clk) begin\n    c <= (a & b) | (a & c) | (b & c);\nend\n\nassign q = a ^ b ^ c;\nassign state = c;\n\nendmodule"]}
{"task_id": "fsm_ps2data", "doubao_output": ["    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[3] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'b0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'b0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_bytes = (state == DONE) ? shift_reg : 24'b0;\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'd0, BYTE2 = 2'd1, BYTE3 = 2'd2, DONE = 2'd3;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[3] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'd0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'd0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_bytes = (state == DONE) ? shift_reg : 24'd0;\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    localparam BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[3] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'b0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'b0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_bytes = (state == DONE) ? shift_reg : 24'b0;\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'd0, BYTE2 = 2'd1, BYTE3 = 2'd2, DONE = 2'd3;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[3] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'd0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'd0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_bytes = (state == DONE) ? shift_reg : 24'd0;\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'd0, BYTE2 = 2'd1, BYTE3 = 2'd2, DONE_STATE = 2'd3;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE_STATE;\n            DONE_STATE: next_state = in[3] ? BYTE1 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'd0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'd0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_bytes = (state == DONE_STATE) ? shift_reg : 24'd0;\n    assign done = (state == DONE_STATE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[3] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'b0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'b0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_bytes = (state == DONE) ? shift_reg : 24'b0;\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[3] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'b0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'b0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                default: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_bytes = (state == DONE) ? shift_reg : 24'b0;\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'd0, BYTE2 = 2'd1, BYTE3 = 2'd2, DONE = 2'd3;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            BYTE1: begin\n                if (in[3]) begin\n                    next_state = BYTE2;\n                end else begin\n                    next_state = BYTE1;\n                end\n            end\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: begin\n                if (in[3]) begin\n                    next_state = BYTE2;\n                end else begin\n                    next_state = BYTE1;\n                end\n            end\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // Output logic and shift register update\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'd0;\n        end else begin\n            shift_reg <= {shift_reg[15:0], in};\n        end\n    end\n\n    assign out_bytes = (state == DONE)? shift_reg : 24'd0;\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'd0, BYTE2 = 2'd1, BYTE3 = 2'd2, DONE = 2'd3;\n    \n    // State register\n    reg [1:0] state, next_state;\n    \n    // 24-bit register to hold the bytes\n    reg [23:0] byte_reg;\n    \n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[3] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[3] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n    \n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // Update the byte register\n    always @(posedge clk) begin\n        if (reset) begin\n            byte_reg <= 24'b0;\n        end else begin\n            case (state)\n                BYTE1: byte_reg[23:16] <= in;\n                BYTE2: byte_reg[15:8] <= in;\n                BYTE3: byte_reg[7:0] <= in;\n                default: byte_reg <= byte_reg;\n            endcase\n        end\n    end\n    \n    // Set the done signal\n    assign done = (state == DONE);\n    \n    // Set the out_bytes output\n    assign out_bytes = done ? byte_reg : 24'b0;\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            BYTE1: begin\n                if (in[3]) begin\n                    next_state = BYTE2;\n                end else begin\n                    next_state = BYTE1;\n                end\n            end\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: begin\n                if (in[3]) begin\n                    next_state = BYTE2;\n                end else begin\n                    next_state = BYTE1;\n                end\n            end\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // Output logic and shift register update\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'b0;\n        end else begin\n            case (state)\n                BYTE1: shift_reg <= {16'b0, in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[7:0], in};\n                DONE: shift_reg <= shift_reg;\n            endcase\n        end\n    end\n\n    assign out_bytes = (state == DONE)? shift_reg : 24'b0;\n    assign done = (state == DONE);\n\nendmodule"]}
{"task_id": "edgedetect", "doubao_output": ["reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule", "reg [7:0] d_last;\n\nalways @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\nend\n\nendmodule"]}
{"task_id": "circuit4", "doubao_output": ["assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule", "assign q = b | c;\nendmodule"]}
{"task_id": "fsm_ps2", "doubao_output": ["    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    parameter BYTE1 = 2'd0, BYTE2 = 2'd1, BYTE3 = 2'd2, DONE = 2'd3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: begin\n                if (in[2] == 1'b0) begin\n                    next_state = BYTE1;\n                end else begin\n                    next_state = BYTE2;\n                end\n            end\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: begin\n                if (in[2] == 1'b0) begin\n                    next_state = BYTE1;\n                end else begin\n                    next_state = BYTE2;\n                end\n            end\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule", "    // Define states\n    parameter BYTE1 = 2'b00, BYTE2 = 2'b01, BYTE3 = 2'b10, DONE = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            BYTE1: next_state = in[2] ? BYTE2 : BYTE1;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = DONE;\n            DONE: next_state = in[2] ? BYTE2 : BYTE1;\n            default: next_state = BYTE1;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= BYTE1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == DONE);\n\nendmodule"]}
{"task_id": "count15", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule"]}
{"task_id": "m2014_q4a", "doubao_output": ["always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always_comb begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule"]}
{"task_id": "m2014_q4h", "doubao_output": ["assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule"]}
{"task_id": "popcount3", "doubao_output": ["assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule"]}
{"task_id": "dff8r", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "ece241_2014_q1c", "doubao_output": ["wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\n\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\n\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\n\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\n\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\n\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\n\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[8] != a[7]));\n\nendmodule", "wire [8:0] sum;\nassign sum = a + b;\nassign s = sum[7:0];\nassign overflow = ((a[7] == b[7]) && (sum[7] != a[7]));\nendmodule"]}
{"task_id": "ece241_2013_q2", "doubao_output": ["// Calculate SOP\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Calculate POS\nwire pos0;\nwire pos1;\nassign pos0 = c & (~b | d) & (~a | b);\nassign pos1 = c & (~b | d) & (~a | d);\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "// Calculate SOP\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Calculate POS\nwire pos0;\nwire pos1;\nassign pos0 = c & (~b | d) & (~a | b);\nassign pos1 = c & (~b | d) & (~a | d);\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "// Calculate SOP\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Calculate POS\nwire pos0;\nwire pos1;\nassign pos0 = c & (~b | d) & (~a | b);\nassign pos1 = c & (~b | d) & (~a | d);\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "    // Calculate SOP\n    assign out_sop = (c & d) | (~a & ~b & c);\n\n    // Calculate POS\n    wire pos0;\n    wire pos1;\n    assign pos0 = c & (~b | d) & (~a | b);\n    assign pos1 = c & (~b | d) & (~a | d);\n    assign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "// SOP expression\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Intermediate wires for POS\nwire pos0;\nwire pos1;\n\n// Calculate pos0\nassign pos0 = c & (~b | d) & (~a | b);\n\n// Calculate pos1\nassign pos1 = c & (~b | d) & (~a | d);\n\n// Final POS output\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "// SOP expression\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Intermediate wires for POS\nwire pos0;\nwire pos1;\n\n// Calculate pos0\nassign pos0 = c & (~b | d) & (~a | b);\n\n// Calculate pos1\nassign pos1 = c & (~b | d) & (~a | d);\n\n// Assign out_pos based on the ternary condition\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "// SOP expression\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Intermediate wires for POS\nwire pos0;\nwire pos1;\n\n// Calculate pos0\nassign pos0 = c & (~b | d) & (~a | b);\n\n// Calculate pos1\nassign pos1 = c & (~b | d) & (~a | d);\n\n// Final POS output\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "// Calculate SOP\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Calculate POS\nwire pos0;\nwire pos1;\nassign pos0 = c & (~b | d) & (~a | b);\nassign pos1 = c & (~b | d) & (~a | d);\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "// SOP expression\nassign out_sop = (c & d) | (~a & ~b & c);\n\n// Intermediate wires for POS\nwire pos0;\nwire pos1;\n\n// Calculate pos0\nassign pos0 = c & (~b | d) & (~a | b);\n// Calculate pos1\nassign pos1 = c & (~b | d) & (~a | d);\n\n// Final POS output\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule", "wire sop_term1, sop_term2;\nassign sop_term1 = c & d;\nassign sop_term2 = ~a & ~b & c;\nassign out_sop = sop_term1 | sop_term2;\n\nwire pos0, pos1;\nassign pos0 = c & (~b | d) & (~a | b);\nassign pos1 = c & (~b | d) & (~a | d);\nassign out_pos = (pos0 == pos1)? pos0 : 1'bx;\n\nendmodule"]}
{"task_id": "m2014_q6c", "doubao_output": ["assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = y[2] & y[3] & y[5] & y[6] & w;\nendmodule"]}
{"task_id": "reduction", "doubao_output": ["assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule"]}
{"task_id": "gates", "doubao_output": ["assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule"]}
{"task_id": "wire_decl", "doubao_output": ["wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule", "wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule", "wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule", "wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule", "wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule", "wire w1;\nwire w2;\n\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\n\nendmodule", "wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule", "wire w1;\nwire w2;\n\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\n\nendmodule", "wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule", "wire w1, w2;\nassign w1 = a & b;\nassign w2 = c & d;\nassign out = w1 | w2;\nassign out_n = ~out;\nendmodule"]}
{"task_id": "7458", "doubao_output": ["assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule", "assign p1y = (p1a & p1b & p1c) & (p1d | p1e | p1f);\nassign p2y = (p2a & p2b) & (p2c | p2d);\nendmodule"]}
{"task_id": "2012_q2fsm", "doubao_output": ["    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w? B : A;\n            B: next_state = w? C : D;\n            C: next_state = w? E : D;\n            D: next_state = w? F : A;\n            E: next_state = w? E : D;\n            F: next_state = w? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w? B : A;\n            B: next_state = w? C : D;\n            C: next_state = w? E : D;\n            D: next_state = w? F : A;\n            E: next_state = w? E : D;\n            F: next_state = w? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = w? B : A;\n            B: next_state = w? C : D;\n            C: next_state = w? E : D;\n            D: next_state = w? F : A;\n            E: next_state = w? E : D;\n            F: next_state = w? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = w? B : A;\n            B: next_state = w? C : D;\n            C: next_state = w? E : D;\n            D: next_state = w? F : A;\n            E: next_state = w? E : D;\n            F: next_state = w? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = w? B : A;\n            B: next_state = w? C : D;\n            C: next_state = w? E : D;\n            D: next_state = w? F : A;\n            E: next_state = w? E : D;\n            F: next_state = w? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule"]}
{"task_id": "2014_q4a", "doubao_output": ["always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (E) begin\n        if (L) begin\n            Q <= R;\n        end else begin\n            Q <= w;\n        end\n    end\nend\nendmodule"]}
{"task_id": "ece241_2014_q5a", "doubao_output": ["parameter A = 2'b00, B = 2'b01, C = 2'b10;\nreg [1:0] state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= A;\n    end else begin\n        case (state)\n            A: state <= x ? C : A;\n            B: state <= x ? B : C;\n            C: state <= x ? B : C;\n            default: state <= A;\n        endcase\n    end\nend\n\nassign z = (state == C);\n\nendmodule", "    parameter A = 2'b00, B = 2'b01, C = 2'b10;\n    reg [1:0] state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x ? C : A;\n                B: state <= x ? B : C;\n                C: state <= x ? B : C;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = (state == C);\n\nendmodule", "    parameter A = 2'b00, B = 2'b01, C = 2'b10;\n    reg [1:0] state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x ? C : A;\n                B: state <= x ? B : C;\n                C: state <= x ? B : C;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = (state == C);\n\nendmodule", "    parameter A = 2'b00, B = 2'b01, C = 2'b10;\n    reg [1:0] state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x ? C : A;\n                B: state <= x ? B : C;\n                C: state <= x ? B : C;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = (state == C);\n\nendmodule", "parameter A = 2'b00, B = 2'b01, C = 2'b10;\nreg [1:0] state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= A;\n    end else begin\n        case (state)\n            A: state <= x ? C : A;\n            B: state <= x ? B : C;\n            C: state <= x ? B : C;\n            default: state <= A;\n        endcase\n    end\nend\n\nassign z = (state == C);\n\nendmodule", "    parameter A = 2'b00, B = 2'b01, C = 2'b10;\n    reg [1:0] state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x? C : A;\n                B: state <= x? B : C;\n                C: state <= x? B : C;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = (state == C);\n\nendmodule", "parameter A = 2'b00, B = 2'b01, C = 2'b10;\nreg [1:0] state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= A;\n    end else begin\n        case (state)\n            A: state <= x? C : A;\n            B: state <= x? B : C;\n            C: state <= x? B : C;\n            default: state <= A;\n        endcase\n    end\nend\n\nassign z = (state == C);\n\nendmodule", "    parameter A = 2'b00, B = 2'b01, C = 2'b10;\n    reg [1:0] state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            case (state)\n                A: state <= x ? C : A;\n                B: state <= x ? B : C;\n                C: state <= x ? B : C;\n                default: state <= A;\n            endcase\n        end\n    end\n\n    assign z = (state == C);\n\nendmodule", "parameter A = 2'b00, B = 2'b01, C = 2'b10;\nreg [1:0] state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= A;\n    end else begin\n        case (state)\n            A: state <= x ? C : A;\n            B: state <= x ? B : C;\n            C: state <= x ? B : C;\n            default: state <= A;\n        endcase\n    end\nend\n\nassign z = (state == C);\n\nendmodule", "parameter A = 2'b00, B = 2'b01, C = 2'b10;\nreg [1:0] state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= A;\n    end else begin\n        case (state)\n            A: state <= x? C : A;\n            B: state <= x? B : C;\n            C: state <= x? B : C;\n            default: state <= A;\n        endcase\n    end\nend\n\nassign z = (state == C);\n\nendmodule"]}
{"task_id": "vector2", "doubao_output": ["assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule", "assign out = {in[31:24], in[23:16], in[15:8], in[7:0]};\nendmodule"]}
{"task_id": "kmap1", "doubao_output": ["assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule", "assign out = a | b | c;\nendmodule"]}
{"task_id": "circuit2", "doubao_output": ["assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule", "assign q = ~(a ^ b ^ c ^ d);\nendmodule"]}
{"task_id": "always_if", "doubao_output": ["assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\n\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\n\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule", "assign out_assign = (sel_b1 & sel_b2)? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule"]}
{"task_id": "ece241_2013_q12", "doubao_output": ["reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule", "reg [7:0] q;\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule"]}
{"task_id": "shift4", "doubao_output": ["always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {q[2:0], 1'b0};\n    end\nend\nendmodule"]}
{"task_id": "m2014_q4c", "doubao_output": ["always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "fsm1s", "doubao_output": ["    // Parameter definition for states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // Sequential logic to update state\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output assignment\n    assign out = (state == B);\n\nendmodule", "    // Parameterize the states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // Sequential logic to update state\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign output based on state\n    assign out = (state == B);\n\nendmodule", "    parameter A = 0, B = 1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State update on positive edge of clk\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output assignment\n    assign out = (state == B);\n\nendmodule", "    parameter A = 0, B = 1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // Sequential logic to update state\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output assignment\n    assign out = (state == B);\n\nendmodule", "    // Parameterize the states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // Sequential logic to update state\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign output based on state\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State update on positive edge of clk\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign output based on state\n    assign out = (state == B);\n\nendmodule", "    parameter A = 0, B = 1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // Update state on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign output based on state\n    assign out = (state == B);\n\nendmodule", "    // Parameterize the states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State update on positive edge of clk\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Assign output based on state\n    assign out = (state == B);\n\nendmodule", "    parameter A = 0, B = 1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State update on positive edge of clk\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output assignment\n    assign out = (state == B);\n\nendmodule", "    parameter A = 0, B = 1;\n    reg state;\n    reg next_state;\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            A: next_state = in? A : B;\n            B: next_state = in? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output assignment\n    assign out = (state == B);\n\nendmodule"]}
{"task_id": "m2014_q4i", "doubao_output": ["assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule"]}
{"task_id": "popcount255", "doubao_output": ["always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule", "always_comb begin\n    out = 8'b0;\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule"]}
{"task_id": "thermostat", "doubao_output": ["assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\n\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\n\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\n\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\n\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\nendmodule", "assign fan = too_cold || too_hot || fan_on;\nassign heater = mode && too_cold;\nassign aircon =!mode && too_hot;\nendmodule"]}
{"task_id": "2012_q2b", "doubao_output": ["assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\nendmodule"]}
{"task_id": "kmap3", "doubao_output": ["always @(posedge clk) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0011: out = 1'b1;\n        4'b0010: out = 1'b1;\n        4'b0100: out = 1'bx;\n        4'b0101: out = 1'b0;\n        4'b0111: out = 1'b0;\n        4'b0110: out = 1'b0;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'bx;\n        4'b1111: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'bx;\n        4'b1011: out = 1'b1;\n        4'b1010: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a,b,c,d})\n        4'b0000: out <= 1'b0;\n        4'b0001: out <= 1'b0;\n        4'b0010: out <= 1'b1;\n        4'b0011: out <= 1'b1;\n        4'b0100: out <= 1'bx;\n        4'b0101: out <= 1'b0;\n        4'b0110: out <= 1'b0;\n        4'b0111: out <= 1'b0;\n        4'b1000: out <= 1'b1;\n        4'b1001: out <= 1'bx;\n        4'b1010: out <= 1'b1;\n        4'b1011: out <= 1'b1;\n        4'b1100: out <= 1'b1;\n        4'b1101: out <= 1'bx;\n        4'b1110: out <= 1'b1;\n        4'b1111: out <= 1'b1;\n        default: out <= 1'bx;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0011: out = 1'b1;\n        4'b0010: out = 1'b1;\n        4'b0100: out = 1'bx;\n        4'b0101: out = 1'b0;\n        4'b0111: out = 1'b0;\n        4'b0110: out = 1'b0;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'bx;\n        4'b1111: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'bx;\n        4'b1011: out = 1'b1;\n        4'b1010: out = 1'b1;\n        default: out = 1'bx;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a,b,c,d})\n        4'b0000: out <= 1'b0;\n        4'b0001: out <= 1'b0;\n        4'b0010: out <= 1'b1;\n        4'b0011: out <= 1'b1;\n        4'b0100: out <= 1'bx;\n        4'b0101: out <= 1'b0;\n        4'b0110: out <= 1'b0;\n        4'b0111: out <= 1'b0;\n        4'b1000: out <= 1'b1;\n        4'b1001: out <= 1'bx;\n        4'b1010: out <= 1'b1;\n        4'b1011: out <= 1'b1;\n        4'b1100: out <= 1'b1;\n        4'b1101: out <= 1'bx;\n        4'b1110: out <= 1'b1;\n        4'b1111: out <= 1'b1;\n        default: out <= 1'bx;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a,b,c,d})\n        4'b0000: out <= 1'b0;\n        4'b0001: out <= 1'b0;\n        4'b0011: out <= 1'b1;\n        4'b0010: out <= 1'b1;\n        4'b0100: out <= 1'bx;\n        4'b0101: out <= 1'b0;\n        4'b0111: out <= 1'b0;\n        4'b0110: out <= 1'b0;\n        4'b1100: out <= 1'b1;\n        4'b1101: out <= 1'bx;\n        4'b1111: out <= 1'b1;\n        4'b1110: out <= 1'b1;\n        4'b1000: out <= 1'b1;\n        4'b1001: out <= 1'bx;\n        4'b1011: out <= 1'b1;\n        4'b1010: out <= 1'b1;\n        default: out <= 1'b0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0011: out = 1'b1;\n        4'b0010: out = 1'b1;\n        4'b0100: out = 1'bx;\n        4'b0101: out = 1'b0;\n        4'b0111: out = 1'b0;\n        4'b0110: out = 1'b0;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'bx;\n        4'b1111: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'bx;\n        4'b1011: out = 1'b1;\n        4'b1010: out = 1'b1;\n        default: out = 1'bx;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a,b,c,d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0011: out = 1'b1;\n        4'b0010: out = 1'b1;\n        4'b0100: out = 1'bx;\n        4'b0101: out = 1'b0;\n        4'b0111: out = 1'b0;\n        4'b0110: out = 1'b0;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'bx;\n        4'b1111: out = 1'b1;\n        4'b1110: out = 1'b1;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'bx;\n        4'b1011: out = 1'b1;\n        4'b1010: out = 1'b1;\n        default: out = 1'b0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a,b,c,d})\n        4'b0000: out <= 1'b0;\n        4'b0001: out <= 1'b0;\n        4'b0011: out <= 1'b1;\n        4'b0010: out <= 1'b1;\n        4'b0100: out <= 1'bx;\n        4'b0101: out <= 1'b0;\n        4'b0111: out <= 1'b0;\n        4'b0110: out <= 1'b0;\n        4'b1100: out <= 1'b1;\n        4'b1101: out <= 1'bx;\n        4'b1111: out <= 1'b1;\n        4'b1110: out <= 1'b1;\n        4'b1000: out <= 1'b1;\n        4'b1001: out <= 1'bx;\n        4'b1011: out <= 1'b1;\n        4'b1010: out <= 1'b1;\n        default: out <= 1'bx;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({a,b,c,d})\n        4'b0000: out <= 1'b0;\n        4'b0001: out <= 1'b0;\n        4'b0011: out <= 1'b1;\n        4'b0010: out <= 1'b1;\n        4'b0100: out <= 1'bx;\n        4'b0101: out <= 1'b0;\n        4'b0111: out <= 1'b0;\n        4'b0110: out <= 1'b0;\n        4'b1100: out <= 1'b1;\n        4'b1101: out <= 1'bx;\n        4'b1111: out <= 1'b1;\n        4'b1110: out <= 1'b1;\n        4'b1000: out <= 1'b1;\n        4'b1001: out <= 1'bx;\n        4'b1011: out <= 1'b1;\n        4'b1010: out <= 1'b1;\n        default: out <= 1'b0;\n    endcase\nend\n\nendmodule", "always @(posedge clk) begin\n    case ({a,b,c,d})\n        4'b0000: out = 1'b0;\n        4'b0001: out = 1'b0;\n        4'b0010: out = 1'b1;\n        4'b0011: out = 1'b1;\n        4'b0100: out = 1'bx;\n        4'b0101: out = 1'b0;\n        4'b0110: out = 1'b0;\n        4'b0111: out = 1'b0;\n        4'b1000: out = 1'b1;\n        4'b1001: out = 1'bx;\n        4'b1010: out = 1'b1;\n        4'b1011: out = 1'b1;\n        4'b1100: out = 1'b1;\n        4'b1101: out = 1'bx;\n        4'b1110: out = 1'b1;\n        4'b1111: out = 1'b1;\n        default: out = 1'bx;\n    endcase\nend\nendmodule"]}
{"task_id": "bugs_mux2", "doubao_output": ["always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel) begin\n        out = a;\n    end else begin\n        out = b;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule", "always @(*) begin\n    if (sel == 1'b0) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\nendmodule"]}
{"task_id": "2014_q3fsm", "doubao_output": ["    // Define states\n    parameter A = 2'd0, B = 2'd1, C = 2'd2, S10 = 2'd3, S11 = 3'd4, S20 = 3'd5, S21 = 3'd6, S22 = 3'd7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            // You can define the output logic for z here based on requirements\n            // For example, let's assume z is 1 when in state B\n            B: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'd0, B = 2'd1, C = 2'd2, S10 = 2'd3, S11 = 3'd4, S20 = 3'd5, S21 = 3'd6, S22 = 3'd7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // Here you can define the output z based on the state\n        // For simplicity, let's assume z is high when in state B\n        z = (state == B);\n    end\n\nendmodule", "    // Define states\n    parameter A = 0, B = 1, C = 2, S10 = 3, S11 = 4, S20 = 5, S21 = 6, S22 = 7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // Here you need to define the output logic for z.\n        // Since it's not specified in the description, let's assume z is 1 when in state B\n        z = (state == B);\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'd0, B = 2'd1, C = 2'd2, S10 = 2'd3, S11 = 3'd4, S20 = 3'd5, S21 = 3'd6, S22 = 3'd7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // You can define the output logic for z here based on your requirements.\n        // For now, let's assume z is high when in state B\n        z = (state == B);\n    end\n\nendmodule", "    // Define states\n    localparam A = 2'd0, B = 2'd1, C = 2'd2, S10 = 2'd3, S11 = 3'd4, S20 = 3'd5, S21 = 3'd6, S22 = 3'd7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // Here we can define the output logic for z based on requirements.\n        // For simplicity, let's assume z is high when in state B\n        z = (state == B);\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'd0, B = 2'd1, C = 2'd2, S10 = 2'd3, S11 = 3'd4, S20 = 3'd5, S21 = 3'd6, S22 = 3'd7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // Here we need to define the output logic for z. Since it's not specified in the description,\n        // we can set it to a default value. Let's assume z is 1 when in state A and 0 otherwise.\n        z = (state == A) ? 1'b1 : 1'b0;\n    end\n\nendmodule", "    // Define states\n    parameter A = 0, B = 1, C = 2, S10 = 3, S11 = 4, S20 = 5, S21 = 6, S22 = 7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // Here you can define the output z based on the state\n        // For simplicity, let's assume z is high when in state B\n        z = (state == B);\n    end\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, S10 = 2'b11, S11 = 3'b000, S20 = 3'b001, S21 = 3'b010, S22 = 3'b011;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // Here we can define the output logic for z based on the state\n        // For simplicity, let's assume z is high when in state B\n        z = (state == B);\n    end\n\nendmodule", "    // Define states\n    parameter A = 0, B = 1, C = 2, S10 = 3, S11 = 4, S20 = 5, S21 = 6, S22 = 7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: z = 1'b0;\n            B: z = 1'b0;\n            C: z = 1'b0;\n            S10: z = 1'b0;\n            S11: z = 1'b0;\n            S20: z = 1'b0;\n            S21: z = 1'b0;\n            S22: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter A = 0, B = 1, C = 2, S10 = 3, S11 = 4, S20 = 5, S21 = 6, S22 = 7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = w ? S11 : S10;\n            C: next_state = w ? S11 : S10;\n            S10: next_state = w ? S21 : S20;\n            S11: next_state = w ? S22 : S21;\n            S20: next_state = B;\n            S21: next_state = w ? C : B;\n            S22: next_state = w ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        // Here you need to define the output logic for z based on requirements.\n        // For now, let's assume z is high when in state B\n        z = (state == B);\n    end\n\nendmodule"]}
{"task_id": "fsm_onehot", "doubao_output": ["assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule", "assign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\nassign next_state[0] = ~in & (|state[4:0] | state[7] | state[8] | state[9]);\nassign next_state[1] = in & (state[0] | state[8] | state[9]);\nassign next_state[2] = in & state[1];\nassign next_state[3] = in & state[2];\nassign next_state[4] = in & state[3];\nassign next_state[5] = in & state[4];\nassign next_state[6] = in & state[5];\nassign next_state[7] = in & (state[6] | state[7]);\nassign next_state[8] = ~in & state[5];\nassign next_state[9] = ~in & state[6];\n\nendmodule"]}
{"task_id": "circuit9", "doubao_output": ["always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else if (q == 3'd6) begin\n        q <= 3'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule"]}
{"task_id": "mt2015_q4", "doubao_output": ["wire out1, out2;\nand g1(out1, x, y);\nand g2(out2, y, x);\nand g3(z, out1, out2);\nendmodule", "wire out1, out2;\nand g1(out1, x, y);\nand g2(out2, y, x);\nand g3(z, out1, out2);\nendmodule", "wire out1, out2;\nand (out1, x, y);\nor (out2, y, x);\nxor (z, out1, out2);\nendmodule", "wire first_gate_out;\nwire second_gate_out;\n\n// First gate: AND gate\nassign first_gate_out = x & y;\n\n// Second gate: OR gate\nassign second_gate_out = y | x;\n\n// Third gate: XOR gate\nassign z = first_gate_out ^ second_gate_out;\n\nendmodule", "wire out1, out2;\nand g1(out1, x, y);\nand g2(out2, y, x);\nand g3(z, out1, out2);\nendmodule", "wire out1, out2;\nand (out1, x, y);\nor (out2, y, x);\nxor (z, out1, out2);\nendmodule", "wire out1, out2;\nand gate1(out1, x, y);\nand gate2(out2, y, x);\nand gate3(z, out1, out2);\nendmodule", "wire out1, out2;\nand g1(out1, x, y);\nor g2(out2, y, x);\nxor g3(z, out1, out2);\nendmodule", "wire out1, out2;\nand g1(out1, x, y);\nor g2(out2, y, x);\nnand g3(z, out1, out2);\nendmodule", "wire first_gate_out;\nwire second_gate_out;\n\n// First gate: AND gate\nassign first_gate_out = x & y;\n\n// Second gate: OR gate\nassign second_gate_out = y | x;\n\n// Third gate: XOR gate\nassign z = first_gate_out ^ second_gate_out;\n\nendmodule"]}
{"task_id": "vector3", "doubao_output": ["assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\nendmodule", "assign w = {a, 2'b11};\nassign x = {b, 2'b11};\nassign y = {c, 2'b11};\nassign z = {d, 2'b11};\n\nendmodule"]}
{"task_id": "m2014_q3", "doubao_output": ["always_comb begin\n    case(x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case(x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case(x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case(x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1'bx;\n        4'h1: f = 1'bx;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'bx;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'bx;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'bx;\n        4'hb: f = 1'b1;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'bx;\n        4'he: f = 1'b1;\n        4'hf: f = 1'bx;\n        default: f = 1'bx;\n    endcase\nend\nendmodule"]}
{"task_id": "vector5", "doubao_output": ["assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule", "assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\nendmodule"]}
{"task_id": "always_case2", "doubao_output": ["always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (in)\n        4'd0: pos <= 2'd0;\n        4'd1: pos <= 2'd0;\n        4'd2: pos <= 2'd1;\n        4'd3: pos <= 2'd0;\n        4'd4: pos <= 2'd2;\n        4'd5: pos <= 2'd0;\n        4'd6: pos <= 2'd1;\n        4'd7: pos <= 2'd0;\n        4'd8: pos <= 2'd3;\n        4'd9: pos <= 2'd0;\n        4'd10: pos <= 2'd1;\n        4'd11: pos <= 2'd0;\n        4'd12: pos <= 2'd2;\n        4'd13: pos <= 2'd0;\n        4'd14: pos <= 2'd1;\n        4'd15: pos <= 2'd0;\n        default: pos <= 2'd0;\n    endcase\nend\nendmodule"]}
{"task_id": "ece241_2014_q4", "doubao_output": ["reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule", "reg [2:0] s = 3'b0;\n\nalways @(posedge clk) begin\n    {s[2], s[1], s[0]} = {x ^ s[2], x & ~s[1], x | ~s[0]};\nend\n\nassign z = ~(|s);\n\nendmodule"]}
{"task_id": "lfsr5", "doubao_output": ["    reg [4:0] q_next;\n\n    always @(q) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(*) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [4:0] q_next;\n\n    always @(q) begin\n        q_next = {q[4:1]};\n        q_next[4] = q[0];\n        q_next[2] = q_next[2] ^ q[0];\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule"]}
{"task_id": "2014_q3bfsm", "doubao_output": ["    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = x ? E : B;\n            C: next_state = x ? B : C;\n            D: next_state = x ? C : B;\n            E: next_state = x ? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x? B : A;\n            B: next_state = x? E : B;\n            C: next_state = x? B : C;\n            D: next_state = x? C : B;\n            E: next_state = x? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = x ? E : B;\n            C: next_state = x ? B : C;\n            D: next_state = x ? C : B;\n            E: next_state = x ? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = x ? E : B;\n            C: next_state = x ? B : C;\n            D: next_state = x ? C : B;\n            E: next_state = x ? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x? B : A;\n            B: next_state = x? E : B;\n            C: next_state = x? B : C;\n            D: next_state = x? C : B;\n            E: next_state = x? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x? B : A;\n            B: next_state = x? E : B;\n            C: next_state = x? B : C;\n            D: next_state = x? C : B;\n            E: next_state = x? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = x ? E : B;\n            C: next_state = x ? B : C;\n            D: next_state = x ? C : B;\n            E: next_state = x ? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x ? B : A;\n            B: next_state = x ? E : B;\n            C: next_state = x ? B : C;\n            D: next_state = x ? C : B;\n            E: next_state = x ? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x? B : A;\n            B: next_state = x? E : B;\n            C: next_state = x? B : C;\n            D: next_state = x? C : B;\n            E: next_state = x? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = x? B : A;\n            B: next_state = x? E : B;\n            C: next_state = x? B : C;\n            D: next_state = x? C : B;\n            E: next_state = x? E : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == D) || (state == E);\n    end\n\nendmodule"]}
{"task_id": "review2015_fsmshift", "doubao_output": ["    // Define states\n    localparam B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, DONE = 3'b100;\n\n    // State register\n    reg [2:0] state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end else begin\n            case (state)\n                B0: state <= B1;\n                B1: state <= B2;\n                B2: state <= B3;\n                B3: state <= DONE;\n                default: state <= DONE;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\nendmodule", "// Define states\nlocalparam B0 = 3'b000;\nlocalparam B1 = 3'b001;\nlocalparam B2 = 3'b010;\nlocalparam B3 = 3'b011;\nlocalparam Done = 3'b100;\n\n// State register\nreg [2:0] state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= B0;\n    end else begin\n        case (state)\n            B0: state <= B1;\n            B1: state <= B2;\n            B2: state <= B3;\n            B3: state <= Done;\n            default: state <= Done;\n        endcase\n    end\nend\n\n// Output logic\nassign shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n\nendmodule", "    // Define states\n    parameter B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B0: next_state = B1;\n            B1: next_state = B2;\n            B2: next_state = B3;\n            B3: next_state = Done;\n            default: next_state = Done;\n        endcase\n    end\n\n    // Output logic\n    assign shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n\nendmodule", "    // Define states\n    parameter B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B0: next_state = B1;\n            B1: next_state = B2;\n            B2: next_state = B3;\n            B3: next_state = Done;\n            default: next_state = Done;\n        endcase\n    end\n\n    // Output logic\n    assign shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n\nendmodule", "    // Define states\n    localparam B0 = 3'b000;\n    localparam B1 = 3'b001;\n    localparam B2 = 3'b010;\n    localparam B3 = 3'b011;\n    localparam Done = 3'b100;\n\n    // State register\n    reg [2:0] state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end else begin\n            case (state)\n                B0: state <= B1;\n                B1: state <= B2;\n                B2: state <= B3;\n                B3: state <= Done;\n                default: state <= Done;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n\nendmodule", "    // Define states\n    parameter B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B0: next_state = B1;\n            B1: next_state = B2;\n            B2: next_state = B3;\n            B3: next_state = Done;\n            default: next_state = Done;\n        endcase\n    end\n\n    // Output logic\n    assign shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n\nendmodule", "// Define local parameters for states\nlocalparam B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, DONE = 3'b100;\n\n// Declare state register\nreg [2:0] state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= B0;\n    end else begin\n        case (state)\n            B0: state <= B1;\n            B1: state <= B2;\n            B2: state <= B3;\n            B3: state <= DONE;\n            default: state <= DONE;\n        endcase\n    end\nend\n\n// Output logic\nassign shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n\nendmodule", "    // Define states\n    parameter B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, DONE = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B0: next_state = B1;\n            B1: next_state = B2;\n            B2: next_state = B3;\n            B3: next_state = DONE;\n            default: next_state = DONE;\n        endcase\n    end\n\n    // Output logic\n    assign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\nendmodule", "    // Define states\n    parameter B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, DONE = 3'b100;\n    \n    // State register\n    reg [2:0] state;\n    \n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end else begin\n            case (state)\n                B0: state <= B1;\n                B1: state <= B2;\n                B2: state <= B3;\n                B3: state <= DONE;\n                default: state <= DONE;\n            endcase\n        end\n    end\n    \n    // Output logic\n    assign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\nendmodule", "    // Define states\n    parameter B0 = 3'b000, B1 = 3'b001, B2 = 3'b010, B3 = 3'b011, Done = 3'b100;\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B0: next_state = B1;\n            B1: next_state = B2;\n            B2: next_state = B3;\n            B3: next_state = Done;\n            default: next_state = Done;\n        endcase\n    end\n\n    // Output logic\n    assign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\nendmodule"]}
{"task_id": "fsm3s", "doubao_output": ["    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n        if (reset) begin\n            next_state = A;\n        end\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        state <= next_state;\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule"]}
{"task_id": "fsm3onehot", "doubao_output": ["assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\n\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\n\nendmodule", "assign next_state[0] = (in == 1'b0)? (state[0] | state[2]) : 1'b0;\nassign next_state[1] = (in == 1'b0)? 1'b0 : (state[0] | state[1] | state[3]);\nassign next_state[2] = (in == 1'b0)? (state[1] | state[3]) : 1'b0;\nassign next_state[3] = (in == 1'b0)? 1'b0 : state[2];\nassign out = state[3];\n\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\nendmodule", "assign next_state[0] = in ? 1'b0 : (state[0] | state[2]);\nassign next_state[1] = in ? (state[0] | state[1] | state[3]) : 1'b0;\nassign next_state[2] = in ? 1'b0 : (state[1] | state[3]);\nassign next_state[3] = in ? state[2] : 1'b0;\nassign out = state[3];\nendmodule"]}
{"task_id": "edgecapture", "doubao_output": ["reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule", "reg [31:0] d_last;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        d_last <= 32'b0;\n    end else begin\n        d_last <= in;\n        out <= out | (~in & d_last);\n    end\nend\n\nendmodule"]}
{"task_id": "always_nolatches", "doubao_output": ["always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule", "always @(*) begin\n    left = (scancode == 16'he06b) ? 1'b1 : 1'b0;\n    down = (scancode == 16'he072) ? 1'b1 : 1'b0;\n    right = (scancode == 16'he074) ? 1'b1 : 1'b0;\n    up = (scancode == 16'he075) ? 1'b1 : 1'b0;\nend\nendmodule"]}
{"task_id": "2013_q2bfsm", "doubao_output": ["    // Define states\n    parameter A = 0, B = 1, S0 = 2, S1 = 3, S10 = 4, G1 = 5, G2 = 6, P0 = 7, P1 = 8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    parameter A = 0, B = 1, S0 = 2, S1 = 3, S10 = 4, G1 = 5, G2 = 6, P0 = 7, P1 = 8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    localparam A = 0, B = 1, S0 = 2, S1 = 3, S10 = 4, G1 = 5, G2 = 6, P0 = 7, P1 = 8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    parameter A = 0, B = 1, S0 = 2, S1 = 3, S10 = 4, G1 = 5, G2 = 6, P0 = 7, P1 = 8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    localparam A = 0, B = 1, S0 = 2, S1 = 3, S10 = 4, G1 = 5, G2 = 6, P0 = 7, P1 = 8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    parameter A = 3'd0, B = 3'd1, S0 = 3'd2, S1 = 3'd3, S10 = 3'd4, G1 = 3'd5, G2 = 3'd6, P0 = 3'd7, P1 = 3'd8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    localparam A = 0, B = 1, S0 = 2, S1 = 3, S10 = 4, G1 = 5, G2 = 6, P0 = 7, P1 = 8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, S0 = 2'b10, S1 = 2'b11, S10 = 3'b100, G1 = 3'b101, G2 = 3'b110, P0 = 3'b111, P1 = 4'b1000;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, S0 = 2'b10, S1 = 2'b11, S10 = 3'b000, G1 = 3'b001, G2 = 3'b010, P0 = 3'b011, P1 = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule", "    // Define states\n    parameter A = 0, B = 1, S0 = 2, S1 = 3, S10 = 4, G1 = 5, G2 = 6, P0 = 7, P1 = 8;\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = B;\n            B: next_state = S0;\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S10;\n            S10: next_state = x ? G1 : S0;\n            G1: next_state = y ? P1 : G2;\n            G2: next_state = y ? P1 : P0;\n            P0: next_state = P0;\n            P1: next_state = P1;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == B);\n    assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule"]}
{"task_id": "rule90", "doubao_output": ["always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {q[$bits(q)-2:0], 1'b0} ^ {1'b0, q[$bits(q)-1:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {1'b0, q[$bits(q)-1:1] ^ q[$bits(q)-2:0]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {q[$bits(q)-2:0], 1'b0} ^ {1'b0, q[$bits(q)-1:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {q[$bits(q)-2:0], 1'b0} ^ {1'b0, q[$bits(q)-1:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {1'b0, q[$bits(q)-1:1] ^ q[$bits(q)-2:0]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {1'b0, q[$bits(q)-1:1] ^ q[$bits(q)-2:0]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {q[$bits(q)-2:0], 1'b0} ^ {1'b0, q[$bits(q)-1:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {q[$bits(q)-2:0], 1'b0} ^ {1'b0, q[$bits(q)-1:1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {1'b0, q[$bits(q)-1:1] ^ q[$bits(q)-2:0]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load)\n        q <= data;\n    else begin\n        q <= {1'b0, q[$bits(q)-1:1] ^ q[$bits(q)-2:0]};\n    end\nend\nendmodule"]}
{"task_id": "m2014_q6b", "doubao_output": ["always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case ({y, w})\n        4'h0: Y2 = 0;\n        4'h1: Y2 = 0;\n        4'h2: Y2 = 1;\n        4'h3: Y2 = 1;\n        4'h4: Y2 = 0;\n        4'h5: Y2 = 1;\n        4'h6: Y2 = 0;\n        4'h7: Y2 = 0;\n        4'h8: Y2 = 0;\n        4'h9: Y2 = 1;\n        4'ha: Y2 = 1;\n        4'hb: Y2 = 1;\n        default: Y2 = 0;\n    endcase\nend\nendmodule"]}
{"task_id": "shift18", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q = data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q = {q[62:0], 1'b0};\n            2'b01: q = {q[55:0], 8'b0};\n            2'b10: q = {q[63], q[63:1]};\n            2'b11: q = {{8{q[63]}}, q[63:8]};\n            default: q = 64'hx;\n        endcase\n    end\nend\nendmodule", "    always @(posedge clk) begin\n        if (load) begin\n            q = data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q = {q[62:0], 1'b0};\n                2'b01: q = {q[55:0], 8'b0};\n                2'b10: q = {q[63], q[63:1]};\n                2'b11: q = {{8{q[63]}}, q[63:8]};\n                default: q = 64'hx;\n            endcase\n        end\n    end\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q = data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q = {q[62:0], 1'b0};\n            2'b01: q = {q[55:0], 8'b0};\n            2'b10: q = {q[63], q[63:1]};\n            2'b11: q = {{8{q[63]}}, q[63:8]};\n            default: q = 64'hx;\n        endcase\n    end\nend\nendmodule", "    always @(posedge clk) begin\n        if (load) begin\n            q = data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q = {q[62:0], 1'b0};\n                2'b01: q = {q[55:0], 8'b0};\n                2'b10: q = {q[63], q[63:1]};\n                2'b11: q = {{8{q[63]}}, q[63:8]};\n                default: q = 64'hx;\n            endcase\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (load) begin\n            q = data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q = {q[62:0], 1'b0};\n                2'b01: q = {q[55:0], 8'b0};\n                2'b10: q = {q[63], q[63:1]};\n                2'b11: q = {{8{q[63]}}, q[63:8]};\n                default: q = 64'hx;\n            endcase\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (load) begin\n            q = data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: q = {q[62:0], 1'b0};\n                2'b01: q = {q[55:0], 8'b0};\n                2'b10: q = {q[63], q[63:1]};\n                2'b11: q = {{8{q[63]}}, q[63:8]};\n                default: q = 64'hx;\n            endcase\n        end\n    end\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q = data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q = {q[62:0], 1'b0};\n            2'b01: q = {q[55:0], 8'b0};\n            2'b10: q = {q[63], q[63:1]};\n            2'b11: q = {{8{q[63]}}, q[63:8]};\n            default: q = 64'hx;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q = data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q = {q[62:0], 1'b0};\n            2'b01: q = {q[55:0], 8'b0};\n            2'b10: q = {q[63], q[63:1]};\n            2'b11: q = {{8{q[63]}}, q[63:8]};\n            default: q = 64'hx;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q = data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q = {q[62:0], 1'b0};\n            2'b01: q = {q[55:0], 8'b0};\n            2'b10: q = {q[63], q[63:1]};\n            2'b11: q = {{8{q[63]}}, q[63:8]};\n            default: q = 64'hx;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q = data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q = {q[62:0], 1'b0};\n            2'b01: q = {q[55:0], 8'b0};\n            2'b10: q = {q[63], q[63:1]};\n            2'b11: q = {{8{q[63]}}, q[63:8]};\n            default: q = 64'hx;\n        endcase\n    end\nend\nendmodule"]}
{"task_id": "ece241_2013_q8", "doubao_output": ["parameter S = 2'b00, S1 = 2'b01, S10 = 2'b10;\nreg [1:0] state, next_state;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        S: begin\n            if (x == 0) next_state = S;\n            else next_state = S1;\n        end\n        S1: begin\n            if (x == 0) next_state = S10;\n            else next_state = S1;\n        end\n        S10: begin\n            if (x == 0) next_state = S;\n            else next_state = S1;\n        end\n        default: next_state = S;\n    endcase\nend\n\n// State flip-flops\nalways @(posedge clk or negedge aresetn) begin\n    if (!aresetn) state <= S;\n    else state <= next_state;\nend\n\n// Output logic\nalways @(*) begin\n    case (state)\n        S: z = 0;\n        S1: z = 0;\n        S10: z = x;\n        default: z = 0;\n    endcase\nend\n\nendmodule", "    // Define states\n    parameter S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 1'b0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 1'b0;\n            S1: z = 1'b0;\n            S10: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 0;\n            S1: z = 0;\n            S10: z = x;\n            default: z = 0;\n        endcase\n    end\n\nendmodule", "parameter S = 2'b00, S1 = 2'b01, S10 = 2'b10;\nreg [1:0] state, next_state;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        S: begin\n            if (x == 0) next_state = S;\n            else next_state = S1;\n        end\n        S1: begin\n            if (x == 0) next_state = S10;\n            else next_state = S1;\n        end\n        S10: begin\n            if (x == 0) next_state = S;\n            else next_state = S1;\n        end\n        default: next_state = S;\n    endcase\nend\n\n// State flip-flops\nalways @(posedge clk or negedge aresetn) begin\n    if (!aresetn) state <= S;\n    else state <= next_state;\nend\n\n// Output logic\nalways @(*) begin\n    case (state)\n        S: z = 0;\n        S1: z = 0;\n        S10: z = x;\n        default: z = 0;\n    endcase\nend\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 1'b0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 1'b0;\n            S1: z = 1'b0;\n            S10: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 1'b0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 1'b0;\n            S1: z = 1'b0;\n            S10: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 1'b0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 1'b0;\n            S1: z = 1'b0;\n            S10: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 1'b0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 1'b0;\n            S1: z = 1'b0;\n            S10: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 1'b0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 1'b0;\n            S1: z = 1'b0;\n            S10: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S10 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            S1: begin\n                if (x == 1'b0) next_state = S10;\n                else next_state = S1;\n            end\n            S10: begin\n                if (x == 1'b0) next_state = S;\n                else next_state = S1;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) state <= S;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S: z = 1'b0;\n            S1: z = 1'b0;\n            S10: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "2014_q3c", "doubao_output": ["always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule", "always_comb begin\n    case ({y[2:0], x})\n        4'h0: Y0 = 0;\n        4'h1: Y0 = 1;\n        4'h2: Y0 = 1;\n        4'h3: Y0 = 0;\n        4'h4: Y0 = 0;\n        4'h5: Y0 = 1;\n        4'h6: Y0 = 1;\n        4'h7: Y0 = 0;\n        4'h8: Y0 = 1;\n        4'h9: Y0 = 0;\n        default: Y0 = x;\n    endcase\nend\n\nalways_comb begin\n    case (y[2:0])\n        3'h0: z = 0;\n        3'h1: z = 0;\n        3'h2: z = 0;\n        3'h3: z = 1;\n        3'h4: z = 1;\n        default: z = x;\n    endcase\nend\n\nendmodule"]}
{"task_id": "gatesv", "doubao_output": ["assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\n\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\n\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\n\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0] ^ in[0]};\nendmodule", "assign out_both = in[2:0] & in[3:1];\nassign out_any = in[2:0] | in[3:1];\nassign out_different = {in[3:1] ^ in[3:1], in[0]};\n\nendmodule"]}
{"task_id": "m2014_q6", "doubao_output": ["    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E || state == F);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11, E = 2'b100, F = 2'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11, E = 2'b100, F = 2'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11, E = 2'b100, F = 2'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w? A : B;\n            B: next_state = w? D : C;\n            C: next_state = w? D : E;\n            D: next_state = w? A : F;\n            E: next_state = w? D : E;\n            F: next_state = w? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive edge of clk\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E || state == F);\n\nendmodule", "    // Define states\n    parameter A = 6'b000001, B = 6'b000010, C = 6'b000100, D = 6'b001000, E = 6'b010000, F = 6'b100000;\n    reg [5:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E || state == F);\n\nendmodule", "    // Define states\n    parameter A = 6'b000001, B = 6'b000010, C = 6'b000100, D = 6'b001000, E = 6'b010000, F = 6'b100000;\n    reg [5:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule"]}
{"task_id": "rule110", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0})) |\n            ((~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0})) |\n            ((q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0})) |\n            ((~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0})) |\n            ((q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= ~(\n            ((q[511:1] & q[511:0] & {q[510:0], 1'b0}) |\n            (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n            (q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}))\n        );\n    end\nend\nendmodule"]}
{"task_id": "circuit8", "doubao_output": ["    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\n\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\n\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\n\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\n\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\n\nendmodule", "    always @(negedge clock) begin\n        q <= a;\n    end\n\n    always @(a) begin\n        if (clock) begin\n            p <= a;\n        end\n    end\nendmodule"]}
{"task_id": "mux9to1v", "doubao_output": ["always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule"]}
{"task_id": "2012_q1g", "doubao_output": ["    always_comb begin\n        case(x)\n            4'h0: f = 1'b1;\n            4'h1: f = 1'b1;\n            4'h2: f = 1'b0;\n            4'h3: f = 1'b0;\n            4'h4: f = 1'b1;\n            4'h5: f = 1'b1;\n            4'h6: f = 1'b1;\n            4'h7: f = 1'b0;\n            4'h8: f = 1'b0;\n            4'h9: f = 1'b0;\n            4'ha: f = 1'b0;\n            4'hb: f = 1'b0;\n            4'hc: f = 1'b1;\n            4'hd: f = 1'b0;\n            4'he: f = 1'b1;\n            4'hf: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\nendmodule", "    always_comb begin\n        case(x)\n            4'h0: f = 1'b1;\n            4'h1: f = 1'b1;\n            4'h2: f = 1'b0;\n            4'h3: f = 1'b0;\n            4'h4: f = 1'b1;\n            4'h5: f = 1'b1;\n            4'h6: f = 1'b1;\n            4'h7: f = 1'b0;\n            4'h8: f = 1'b0;\n            4'h9: f = 1'b0;\n            4'ha: f = 1'b0;\n            4'hb: f = 1'b0;\n            4'hc: f = 1'b1;\n            4'hd: f = 1'b0;\n            4'he: f = 1'b1;\n            4'hf: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\nendmodule", "always_comb begin\n    case(x)\n        4'h0: f = 1'b1;\n        4'h1: f = 1'b1;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'b0;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'b1;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'b0;\n        4'hb: f = 1'b0;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'b0;\n        4'he: f = 1'b1;\n        4'hf: f = 1'b1;\n        default: f = 1'b0;\n    endcase\nend\nendmodule", "    always_comb begin\n        case(x)\n            4'h0: f = 1'b1;\n            4'h1: f = 1'b1;\n            4'h2: f = 1'b0;\n            4'h3: f = 1'b0;\n            4'h4: f = 1'b1;\n            4'h5: f = 1'b1;\n            4'h6: f = 1'b1;\n            4'h7: f = 1'b0;\n            4'h8: f = 1'b0;\n            4'h9: f = 1'b0;\n            4'ha: f = 1'b0;\n            4'hb: f = 1'b0;\n            4'hc: f = 1'b1;\n            4'hd: f = 1'b0;\n            4'he: f = 1'b1;\n            4'hf: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1;\n        4'h1: f = 1;\n        4'h2: f = 0;\n        4'h3: f = 0;\n        4'h4: f = 1;\n        4'h5: f = 1;\n        4'h6: f = 1;\n        4'h7: f = 0;\n        4'h8: f = 0;\n        4'h9: f = 0;\n        4'ha: f = 0;\n        4'hb: f = 0;\n        4'hc: f = 1;\n        4'hd: f = 0;\n        4'he: f = 1;\n        4'hf: f = 1;\n        default: f = 0;\n    endcase\nend\nendmodule", "    always_comb begin\n        case(x)\n            4'h0: f = 1'b1;\n            4'h1: f = 1'b1;\n            4'h2: f = 1'b0;\n            4'h3: f = 1'b0;\n            4'h4: f = 1'b1;\n            4'h5: f = 1'b1;\n            4'h6: f = 1'b1;\n            4'h7: f = 1'b0;\n            4'h8: f = 1'b0;\n            4'h9: f = 1'b0;\n            4'ha: f = 1'b0;\n            4'hb: f = 1'b0;\n            4'hc: f = 1'b1;\n            4'hd: f = 1'b0;\n            4'he: f = 1'b1;\n            4'hf: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\nendmodule", "    always_comb begin\n        case (x)\n            4'h0: f = 1'b1;\n            4'h1: f = 1'b1;\n            4'h2: f = 1'b0;\n            4'h3: f = 1'b0;\n            4'h4: f = 1'b1;\n            4'h5: f = 1'b1;\n            4'h6: f = 1'b1;\n            4'h7: f = 1'b0;\n            4'h8: f = 1'b0;\n            4'h9: f = 1'b0;\n            4'ha: f = 1'b0;\n            4'hb: f = 1'b0;\n            4'hc: f = 1'b1;\n            4'hd: f = 1'b0;\n            4'he: f = 1'b1;\n            4'hf: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\nendmodule", "always_comb begin\n    case(x)\n        4'h0: f = 1'b1;\n        4'h1: f = 1'b1;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'b0;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'b1;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'b0;\n        4'hb: f = 1'b0;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'b0;\n        4'he: f = 1'b1;\n        4'hf: f = 1'b1;\n        default: f = 1'b0;\n    endcase\nend\nendmodule", "always_comb begin\n    case (x)\n        4'h0: f = 1;\n        4'h1: f = 1;\n        4'h2: f = 0;\n        4'h3: f = 0;\n        4'h4: f = 1;\n        4'h5: f = 1;\n        4'h6: f = 1;\n        4'h7: f = 0;\n        4'h8: f = 0;\n        4'h9: f = 0;\n        4'ha: f = 0;\n        4'hb: f = 0;\n        4'hc: f = 1;\n        4'hd: f = 0;\n        4'he: f = 1;\n        4'hf: f = 1;\n        default: f = 0;\n    endcase\nend\nendmodule", "always_comb begin\n    case(x)\n        4'h0: f = 1'b1;\n        4'h1: f = 1'b1;\n        4'h2: f = 1'b0;\n        4'h3: f = 1'b0;\n        4'h4: f = 1'b1;\n        4'h5: f = 1'b1;\n        4'h6: f = 1'b1;\n        4'h7: f = 1'b0;\n        4'h8: f = 1'b0;\n        4'h9: f = 1'b0;\n        4'ha: f = 1'b0;\n        4'hb: f = 1'b0;\n        4'hc: f = 1'b1;\n        4'hd: f = 1'b0;\n        4'he: f = 1'b1;\n        4'hf: f = 1'b1;\n        default: f = 1'b0;\n    endcase\nend\nendmodule"]}
{"task_id": "bugs_case", "doubao_output": ["    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: begin\n                valid = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule", "    initial begin\n        out = 4'b0;\n        valid = 1'b1;\n    end\n\n    always @(*) begin\n        case (code)\n            8'h45: out = 4'd0;\n            8'h16: out = 4'd1;\n            8'h1e: out = 4'd2;\n            8'h26: out = 4'd3;\n            8'h25: out = 4'd4;\n            8'h2e: out = 4'd5;\n            8'h36: out = 4'd6;\n            8'h3d: out = 4'd7;\n            8'h3e: out = 4'd8;\n            8'h46: out = 4'd9;\n            default: valid = 1'b0;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "review2015_fsmseq", "doubao_output": ["    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define states\n    parameter S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            S: next_state = data ? S1 : S;\n            S1: next_state = data ? S11 : S;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? Done : S;\n            Done: next_state = Done;\n            default: next_state = S;\n        endcase\n    end\n\n    // State update logic (sequential)\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define states\n    parameter S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define states\n    parameter S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define the states\n    parameter S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define states\n    localparam S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define states\n    parameter S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S: begin\n                if (data) begin\n                    next_state = S1;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S1: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S;\n                end\n            end\n            S11: begin\n                if (data) begin\n                    next_state = S11;\n                end else begin\n                    next_state = S110;\n                end\n            end\n            S110: begin\n                if (data) begin\n                    next_state = Done;\n                end else begin\n                    next_state = S;\n                end\n            end\n            Done: begin\n                next_state = Done;\n            end\n            default: next_state = S;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule", "    // Define the states\n    parameter S = 2'b00, S1 = 2'b01, S11 = 2'b10, S110 = 2'b11, Done = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            S: next_state = data ? S1 : S;\n            S1: next_state = data ? S11 : S;\n            S11: next_state = data ? S11 : S110;\n            S110: next_state = data ? Done : S;\n            Done: next_state = Done;\n            default: next_state = S;\n        endcase\n    end\n\n    // State update (sequential)\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == Done);\n\nendmodule"]}
{"task_id": "lfsr32", "doubao_output": ["    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule", "    reg [31:0] q_next;\n\n    always @(*) begin\n        q_next = {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1;\n        end\n        else begin\n            q <= q_next;\n        end\n    end\n\nendmodule"]}
{"task_id": "vectorr", "doubao_output": ["assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"]}
{"task_id": "review2015_fsmonehot", "doubao_output": ["// State definitions\nparameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b0100000000;\nparameter Wait = 10'b1000000000;\n\n// Assign outputs based on state conditions\nassign B3_next = (state == B2);\nassign S_next = ((state == S && !d) || (state == S1 && !d) || (state == S110 && !d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = (state == B3) || (state == Count && !done_counting);\nassign Wait_next = (state == Count && done_counting) || (state == Wait && !ack);\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "parameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b0100000000;\nparameter Wait = 10'b1000000000;\n\nassign B3_next = (state == B2);\nassign S_next = ((state == S && ~d) || (state == S1 && ~d) || (state == S110 && ~d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = ((state == B3) || (state == Count && ~done_counting));\nassign Wait_next = ((state == Count && done_counting) || (state == Wait && ~ack));\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "// Define state constants\nlocalparam S = 10'b0000000001;\nlocalparam S1 = 10'b0000000010;\nlocalparam S11 = 10'b0000000100;\nlocalparam S110 = 10'b0000001000;\nlocalparam B0 = 10'b0000010000;\nlocalparam B1 = 10'b0000100000;\nlocalparam B2 = 10'b0001000000;\nlocalparam B3 = 10'b0010000000;\nlocalparam Count = 10'b0100000000;\nlocalparam Wait = 10'b1000000000;\n\n// Assign outputs based on state conditions\nassign B3_next = (state == B2);\nassign S_next = ((state == S && !d) || (state == S1 && !d) || (state == S110 && !d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = ((state == B3) || (state == Count && !done_counting));\nassign Wait_next = ((state == Count && done_counting) || (state == Wait && !ack));\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "parameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b0100000000;\nparameter Wait = 10'b1000000000;\n\nassign B3_next = (state == B2);\nassign S_next = ((state == S && !d) || (state == S1 && !d) || (state == S110 && !d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = (state == B3) || (state == Count && !done_counting);\nassign Wait_next = (state == Count && done_counting) || (state == Wait && !ack);\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "// State definitions\nlocalparam S = 10'b0000000001;\nlocalparam S1 = 10'b0000000010;\nlocalparam S11 = 10'b0000000100;\nlocalparam S110 = 10'b0000001000;\nlocalparam B0 = 10'b0000010000;\nlocalparam B1 = 10'b0000100000;\nlocalparam B2 = 10'b0001000000;\nlocalparam B3 = 10'b0010000000;\nlocalparam Count = 10'b0100000000;\nlocalparam Wait = 10'b1000000000;\n\n// Combinational logic for outputs\nassign B3_next = (state == B2);\nassign S_next = ((state == S && ~d) || (state == S1 && ~d) || (state == S110 && ~d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = (state == B3) || (state == Count && ~done_counting);\nassign Wait_next = (state == Count && done_counting) || (state == Wait && ~ack);\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "// State definitions\nparameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b0100000000;\nparameter Wait = 10'b1000000000;\n\n// Assign outputs based on state\nassign B3_next = (state == B2);\nassign S_next = ((state == S && !d) || (state == S1 && !d) || (state == S110 && !d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = ((state == B3) || (state == Count && !done_counting));\nassign Wait_next = ((state == Count && done_counting) || (state == Wait && !ack));\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "    parameter S = 10'b0000000001, S1 = 10'b0000000010, S11 = 10'b0000000100, S110 = 10'b0000001000, B0 = 10'b0000010000, B1 = 10'b0000100000, B2 = 10'b0001000000, B3 = 10'b0010000000, Count = 10'b0100000000, Wait = 10'b1000000000;\n\n    assign B3_next = state[B2];\n    assign S_next = (state[S] && ~d) || (state[S1] && ~d) || (state[S110] && ~d) || (state[Wait] && ack);\n    assign S1_next = state[S] && d;\n    assign Count_next = state[B3] || (state[Count] && ~done_counting);\n    assign Wait_next = (state[Count] && done_counting) || (state[Wait] && ~ack);\n    assign done = state[Wait];\n    assign counting = state[Count];\n    assign shift_ena = state[B3] || state[B2] || state[B1] || state[B0];\n\nendmodule", "parameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b0100000000;\nparameter Wait = 10'b1000000000;\n\nassign B3_next = (state == B2);\nassign S_next = ((state == S && !d) || (state == S1 && !d) || (state == S110 && !d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = ((state == B3) || (state == Count && !done_counting));\nassign Wait_next = ((state == Count && done_counting) || (state == Wait && !ack));\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "parameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b0100000000;\nparameter Wait = 10'b1000000000;\n\nassign B3_next = (state == B2);\nassign S_next = ((state == S && ~d) || (state == S1 && ~d) || (state == S110 && ~d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = ((state == B3) || (state == Count && ~done_counting));\nassign Wait_next = ((state == Count && done_counting) || (state == Wait && ~ack));\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule", "parameter S = 10'b0000000001;\nparameter S1 = 10'b0000000010;\nparameter S11 = 10'b0000000100;\nparameter S110 = 10'b0000001000;\nparameter B0 = 10'b0000010000;\nparameter B1 = 10'b0000100000;\nparameter B2 = 10'b0001000000;\nparameter B3 = 10'b0010000000;\nparameter Count = 10'b0100000000;\nparameter Wait = 10'b1000000000;\n\nassign B3_next = (state == B2);\nassign S_next = ((state == S && !d) || (state == S1 && !d) || (state == S110 && !d) || (state == Wait && ack));\nassign S1_next = (state == S && d);\nassign Count_next = (state == B3) || (state == Count && !done_counting);\nassign Wait_next = (state == Count && done_counting) || (state == Wait && !ack);\nassign done = (state == Wait);\nassign counting = (state == Count);\nassign shift_ena = (state == B3) || (state == B2) || (state == B1) || (state == B0);\n\nendmodule"]}
