{"question": "What does it mean if a task is declared with the automatic keyword in Verilog?\n\n```\ntask automatic do_things;\n  input [31:0] number_of_things;\n  reg [31:0] tmp_thing;\n  begin\n    // ...\n  end\nendtask;\n```\n\n\nNote: This question is mostly because I'm curious if there are any hardware programmers on the site. :)\n", "answer": [{"body": "It means that the task is re-entrant - items declared within the task are dynamically allocated rather than shared between different invocations of the task.\n\nYou see - some of us do Verilog...  (ugh)\n", "accept": true, "score": 20}, {"body": "The \"automatic\" keyword also allows you to write recursive functions (since verilog 2001). I believe they should be synthesisable if they bottom out, but I'm not sure if they have tool support.  \n\nI too, do verilog! \n", "accept": false, "score": 3}, {"body": "As Will and Marty say, the automatic was intended for recursive functions.\n\nIf a normal (i.e. not automatic) function is called with different values and processed by the simulator in the same time slice, the returned value is indeterminate. That can be quite a tricky bug to spot! This is only a simulation issue, when synthesised the logic will be correct.\n\nMaking the function automatic fixes this.\n", "accept": false, "score": 1}, {"body": "\"automatic\" does in fact mean \"re-entrant\".  The term itself is stolen from software languages -- for example, C has the \"auto\" keyword for declaring variables as being allocated on the stack when the scope it's in is executed, and deallocated afterwards, so that multiple invocations of the same scope do not see persistent values of that variable.  The reason you may not have heard of this keyword in C is that it is the default storage class for all types :-)  The alternatives are \"static\", which means \"allocate this variable statically (to a single global location in memory), and refer to this same memory location throughout the execution of the program, regardless of how many times the function is invoked\", and \"volatile\", which means \"this is a register elsewhere on my SoC or something on another device which I have no control over; compiler, please don't optimize reads to me away, even when you think you know my value from previous reads with no intermediate writes in the code\".\n\n\"automatic\" is intended for recursive functions, but also for running the same function in different threads of execution concurrently.  For instance, if you \"fork\" off N different blocks (using Verilog's fork->join statement), and have them all call the same function at the same time, the same problems arise as a function calling itself recursively.\n\nIn many cases, your code will be just fine without declaring the task or function as \"automatic\", but it's good practice to put it in there unless you specifically need it to be otherwise.\n", "accept": false, "score": 32}, {"body": "In computing, a computer program or subroutine is called re-entrant if multiple invocations can safely run concurrently (Wikipedia). \nIn simple words, the keyword automatic makes it safe, when multiple instances of a task run at a same time.\n:D\n", "accept": false, "score": 0}, {"body": "Automatic is just opposite to static in usual programming. So is the case with Verilog. . See the Verilog description below:\n```\nfor (int i = 0; i < 3; i++) begin\n    static int f = 0;\n    f = f + 1;\nend\n```\n\nResult of the above program will be `f = 3`. Also, see the program below:\n```\nfor (int i = 0; i < 3; i++) begin\n    int f = 0;\n    f = f + 1;\nend\n```\n\nThe result of above program is `f = 1`. What makes a difference is static keyword.\nConclusion is tasks in Verilog should be automatic because they are invoked (called) so many times. If they were static (if not declared explicitly, they are static), they could have used the result from the previous call which often we do not want.\n", "accept": false, "score": 0}], "score": [40.0, 5.696068353931807e-234, 2.0, 5.303655337672357e-232, 0.0, 0.0]}
{"question": "I need to implement a 4-to-1 function in Veriog.  The input is 4 bits, a number from 0-15.  The output is a single bit, 0 or 1.  Each input gives a different output and the mapping from inputs to outputs is known, but the inputs and outputs themselves are not.  I want vcs to successfully optimizing the code and also have it be as short/neat as possible.  My solution so far:\n\n```\nwire [3:0] a;\nwire b;\nwire [15:0] c;\n\nassign c = 16'b0100110010111010; //for example but could be any constant\nassign b = c[a];\n```\n\n\nHaving to declare c is ugly and I don't know if vcs will recognize the K-map there.  Will this work as well as a case statement or an assignment in conjunctive normal form?\n", "answer": [{"body": "My preference - if it makes sense for your problem - is for a case statement that makes use of enums or `defines. Anything to make code review, maintenance and verification easier.\n", "accept": false, "score": 2}, {"body": "I totally agree with Dallas. Use a case statement - it makes your intent clearer.  The synthesis tool will build it as a look-up table (if it's parallel) and will optimise whatever it can.\n\nAlso, I wouldn't worry so much about keeping your RTL code short.  I'd shoot for clarity first.  Synthesis tools are cleverer than you think...\n", "accept": false, "score": 3}, {"body": "What you have is fine.  A case statement would also work equally well.  It's just a matter of how expressive you wish to be.  \n\nYour solution, indexing, works fine if the select encodings don't have any special meaning (a memory address selector for example).  If the select encodings do have some special semantic meaning to you the designer (and there aren't too many of them), then go with a case statement and enums.\n\nSynthesis wise, it doesn't matter which one you use.  Any decent synthesis tool will produce the same result.\n", "accept": true, "score": 5}, {"body": "For things like this, RTL clarity trumps all by a wide margin.  SystemVerilog has special always block directives to make it clear when the block should synthesize to combinational logic, latches, or flops (and your synthesis tool should throw an error if you've written RTL that conflicts with that (e.g. not including all signals in the sensitivity list of an always block).  Also be aware that the tool will probably replace whatever encoding you have with the most hardware-efficient encoding (the one that minimizes the area of your total design), unless the encoding itself propagates out to the pins of your top-level module.\n\nThis advice goes in general, as well.  Make your code easy to understand by humans, and it will probably be more understandable to the synthesis tool as well, which allows it to more effectively bring literally  of man-years of algorithms research to bear on your RTL.\n\nYou can also code it using ternary operators if you like, but i'd prefer something like:\n\n```\nalways_comb //or \"always @*\" if you don't have an SV-enabled tool flow\nbegin \n  case(a)\n  begin\n    4'b0000: b = 1'b0;\n    4'b0001: b = 1'b1;\n    ...\n    4'b1111: b = 1'b0;\n    //If you don't specify a \"default\" clause, your synthesis tool\n    //Should scream at you if you didn't specify all cases,\n    //Which is a good thing (tm)\n  endcase //a\nend //always\n```\n\n", "accept": false, "score": 2}, {"body": "Apparently I am using a lousy synthesis tool.  :-)  I just synthesized both versions (just the module using a model based on fan-outs for wire delays) and the indexing version from the question gave better timing and area results than the case statements.  Using Synopsys DC Z-2007.03-SP.\n", "accept": false, "score": 1}], "score": [1.9401146886781146e-245, 5.194142006516215e-237, 10.0, 7.552398029412605e-156, 4.291663601522078e-240]}
{"question": "In my day job I, and others on my team write a lot of hardware models in Verilog-AMS, a language supported primarily by commercial vendors and a few opensource simulator projects. \nOne thing that would make supporting each others code more helpful would be a LINTER that would check our code for common problems and assist with enforcing a shared code formatting style. \nI of course want to be able to add my own rules and, after I prove their utility to myself, promote them to the rest of the team.. \nI don't mind doing the work that has to be done, but of course also want to leverage the work of other existing projects. \n\nDoes having the allowed language syntax in a yacc or bison format give me a leg up? \nor should I just suck each language statement into a perl string, and use pattern matching to find the things I don't like? \n\n(most syntax and compilation errors are easily caught by the commercial tools.. but we have some of our own extentions.) \n", "answer": [{"body": "In trying to find my answer, I found this on [ANTLR](http://www.ibm.com/developerworks/edu/au-dw-au-parsingwithantlr-i.html) - might be of use\n", "accept": false, "score": 0}, {"body": "`yacc`/`bison` definitely gives you a leg up, since good linting would require parsing the program. Regex (true regex, at least) might cover trivial cases, but it is easy to write code that the regexes don't match but are still bad style.\n", "accept": false, "score": 0}, {"body": "If you use Java at all (and thus IDEA), the IDE's [extensions for custom languages](http://www.jetbrains.com/idea/plugins/developing_custom_language_plugins.html) might be of use\n", "accept": false, "score": 0}, {"body": "ANTLR looks to be an alternative path to the more common (OK  heard about them before) YACC/BISON approach, which it turns out also commonly use LEX/FLEX as a front end. \n\na Quick read of the FLEX man page kind of make me think It could be the framework for that regex type of idea.. \n\nOk.. I'll let this stew a little longer, then see how quickly I can build a prototype parser in one or the other. \n\nand a little bit longer\n", "accept": false, "score": 0}, {"body": "lex/flex and yacc/bison provide easy-to-use, well-understood lexer- and parser-generators, and I'd really recommend doing something like that as opposed to doing it procedurally in e.g. Perl.  Regular expressions are powerful stuff for ripping apart strings with relatively-, but not totally-fixed structure.  With any real programming language, the size of your state machine gets to be simply unmanageable with anything short of a Real Lexer/Parser (tm).  Imagine dealing with all possible interleavings of keywords, identifiers, operators, extraneous parentheses, extraneous semicolons, and comments that are allowed in something like Verilog AMS, with regular expressions and procedural code alone.\n\nThere's no denying that there's a substantial learning curve there, but writing a grammar that you can use for flex and bison, and doing something useful on the syntax tree that comes out of bison, will be a much better use of your time than writing a ton of special-case string-processing code that's more naturally dealt with using a syntax-tree in the first place.  Also, what you learn writing it this way will truly broaden your skillset in ways that writing a bunch of hacky Perl code just won't, so if you have the means, I highly recommend it ;-)\n\nAlso, if you're lazy, check out the Eclipse plugins that do syntax highlighting and basic refactoring for Verilog and VHDL.  They're in an incredibly primitive state, last I checked, but they may have some of the code you're looking for, or at least a baseline piece of code to look at to better inform your approach in rolling your own.\n", "accept": true, "score": 19}, {"body": "I've written a couple verilog parsers and I would suggest PCCTS/ANTLR if your favorite programming language is C/C++/Java. There is a [PCCTS/ANTLR Verilog grammar](http://www.antlr.org/grammar/verilog/verilog.g) that you can start with. My favorite parser generator is [Zebu](http://www.cliki.net/Zebu) which is based on Common Lisp.\n\nOf course the big job is to specify all the linting rules. It makes sense to make some kind of language to specify the linting rules as well.\n", "accept": false, "score": 2}, {"body": "Don't underestimate the amount of work that goes into a linter. Parsing is the easy part because you have tools (bison, flex, ANTLR/PCCTS) to automate much of it.\n\nBut once you have a parse, then what? You must build a semantic tree for the design. Depending on how complicated your inputs are, you must elaborate the Verilog-AMS design (i.e. resolving parameters, unrolling generates, etc. If you use those features). And only then can you try to implement rules.\n\nI'd seriously consider other possible solutions before writing a linter, unless the number of users and potential time savings thereby justify the development time.\n", "accept": false, "score": 2}], "score": [0.0, 0.0, 0.0, 0.0, 38.0, 9.920977336266055e-238, 1.8333555449485676e-236]}
{"question": "I am a self-taught embedded developer. I mostly use AVRs programmed in C and ASM, but I have dabbled with other systems. I am looking to move onto more complex devices like CPLDs and FPGAs, but I have no idea where to start. So my one and a half questions are:\n\n\n1. Do you prefer VHDL or Verilog and why?\n2. What is a good way for one with no prior experience in HDLs get started in learning such a beast?\n\n\n", "answer": [{"body": "Buy a cheap starter kit from Xilinx or Altera (the two big FPGA players). A Xilinx Spartan3 starter kit is $200.\n\nI personally prefer VHDL. It is strongly typed and has more advanced features than Verilog. VHDL is more popular in Europe and Verilog is dominating in the US. \n\nBuy a book (e.g. Peter Ashendens The Designers Guide to VHDL) and start simulating your designs in a free simulator. ModelSim from Mentor Graphis is a good one and there are free versions available (with crippled simulation speed).\n\nMake up some interesting project (mini cpu, vga graphics, synthesizer) and start designing. Always simulate and make sure your design works before putting your design into the hardware ...\n\nIf you have no background in digital electronics buy a book in that subject as well.\n", "accept": true, "score": 7}, {"body": "Also check out [opencores.org](http://www.opencores.org/) - There are some articles and a lot of open source code in both Verilog and VHDL you can learn from.\n\nAs far as I can tell, VHDL vs Verilog gets just as religious as Ruby vs Python or Java vs C#. Different people have their own favourites.\n", "accept": false, "score": 2}, {"body": "Back in the day when I worked on ASIC design, it was in verilog. In many cases as a designer you don't get to choose: the ASIC synthesis tools for an HDL cost a substantial amount of money, and companies only purchase the full toolchain for one \"blessed\" language. My employer had standardized on verilog, so that is what we used.\n\nFPGA synthesis tools are substantially cheaper, so you have more freedom as an FPGA designer to pick your favored language and tools.\n\nThere are also free verilog simulators available at [verilog.net](http://www.verilog.net/free.html).\n\nAs @kris mentioned, an FPGA starter board is also a good way to go. Having your verilog code light up an LED on a board is infinitely more satisfying than a simulator waveform on the screen.\n", "accept": false, "score": 4}, {"body": "One additional thing to think about is whether you should start by learning an HDL, or by learning boolean logic, Karnaugh maps, DeMorgan's theorem, gates, implementing arithmetic in gates, etc.  It's easy to write non-synthesizable HDL if you don't have an accurate mental model of what the underlying hardware will look like.  \n\n[This book](https://rads.stackoverflow.com/amzn/click/com/0077211642) is the Verilog version of the one I used in undergrad, and it did a pretty good job in my opinion.  It starts you out with the material mentioned above, as well as some basic, basic info on the transistor-level implementation of gates, then introduces you to an HDL, and has you build progressively more complex structural and behavioral hardware blocks.  Yes, I know it's ungodly expensive, as are most college textbooks, but this is one of those things for which the information I've been able to find online, at least, has been woefully inadequate.\n\nOnce you're ready to choose an HDL, I heartily recommend Verilog (having learned VHDL first).  Yes, VHDL was once much more feature-rich than Verilog, but later revisions of the language (Verilog 2001, Verilog 2005, SystemVerilog, etc..) have cherry-picked most of the interesting features, and there is far more robust toolchain support for Verilog and its variant these days, in addition to it being the dominant language in use in the US (in my experience, VHDL is only used here when dealing with extreme legacy blocks, and in academic contexts, partially due to the tools support mentioned previously).  Finally, once you've learned the HDL, you have a hardware verification language (HVL) in SystemVerilog with strict-superset syntax, saving you a good bit of the learning curve.  Not so for VHDL, to my knowledge.\n", "accept": false, "score": 1}, {"body": "Altera and Xilinx have simulators build into their free tool sets.  They are limited versions of the very popular Mentor ModelSim tools.  They will handle the size of designs you are likely to get to fit in a < $500 (US) board.\n\nFor HDL choice Verilog is to C as VHDL is to ADA. So Verilog is easier to get started with, but you can make mistakes more easily.  Check your simulation and compilation warnings to avoid those problems.\n", "accept": false, "score": 1}, {"body": "Check out this site:\n[http://www.fpga4fun.com/](http://www.fpga4fun.com/)\n\nNice simple projects using simple tools. I used one of these boards a few years ago to build a small VGA display system for use as a notice board.\n\nLooking at the site again I'm thinking of getting a Xylo-LM board as it has an ARM processor as well as SDRAM and a Xilinx Spartan 3e.\n\nAnother board I used before was the XPort 2 from Charmed Labs. This plugs into a Gameboy Advance which is well supported with open source development tools.\n\nCheck out:\n[http://www.charmedlabs.com/index.php?option=com_virtuemart&page=shop.browse&category_id=6&Itemid=43](http://www.charmedlabs.com/index.php?option=com_virtuemart&page=shop.browse&category_id=6&Itemid=43)\n", "accept": false, "score": 2}, {"body": "\n1. Verilog 2.http://www.opensparc.net/\n\n\n\nHTH\n", "accept": false, "score": 1}, {"body": "Verilog is much easier to learn and simpler syntax.  Its also a newer language.  Secondly, most people use verilog.  VHDL has many datatypes which give it a learning curve.  Once you know verilog it will be easier to bridge the gap to VHDL.  Oh and theres also macros in verilog which are very neet.  I invented a language with it. Finally, you will eventually be able to do mixed language HW design.  I started out with VHDL, then learned verilog and am now pro verilog.  \n", "accept": false, "score": 1}, {"body": "Before plunging into Verilog/VHDL or buying an FPGA dev kit I'd recommend taking an introductory class on digital design. There are good online [OpenCourseWare MIT](http://ocw.mit.edu/OcwWeb/web/home/home/index.htm)classes. \n\nGood luck.\n", "accept": false, "score": 0}, {"body": "I was in the same boat as you are now a semester ago. My preferred book was [this](https://rads.stackoverflow.com/amzn/click/com/0123704979) one, since it talked about FPGAs by reviewing digital logic. It also shows side-by-side comparisons of VHDL and Verilog code so that, instead of choosing one that people may push you to, you can learn the one that you like stylistically.\n\nAs for an FPGA itself, use Xilinx's [ISE webpack](http://www.xilinx.com/products/design-tools/ise-design-suite/ise-webpack.htm) to do your programming (it's free), and start off with FPGAs like the [Basys2 FPGA board](http://www.digilentinc.com/Products/Detail.cfm?Prod=BASYS2). It's a very small FPGA that should get you started for a small price, but has the added advantage that you learn resource and memory management very early. You can use Digilent's [Adept](http://www.digilentinc.com/Products/Detail.cfm?Prod=ADEPT2) (also free) to make life easy in uploading your \"compiled\" code to the board.\n\nGood luck!\n", "accept": false, "score": 1}], "score": [14.0, 1.2086224648333725e-236, 0.0, 0.0, 1.2793268890653506e-236, 0.0, 0.0, 3.5228120082517626e-241, 0.0, 0.0]}
{"question": "What best practices should be observed when implementing HDL code?\n\nWhat are the commonalities and differences when compared to more common software development fields?\n", "answer": [{"body": "The best book on this topic is [Reuse Methodology Manual](http://www.amazon.com/exec/obidos/tg/detail/-/1402071418/ref=ase_penguintelecomin/102-8353601-4848123?v=glance&s=books).  It covers both VHDL and Verilog.\n\nAnd in particular some issues that don't have an exact match in software: \n\n- - - - - - - \n\nSome that are the same include\n\n- - - - - - \n", "accept": true, "score": 51}, {"body": "HDL's like Verilog and VHDL really seem to encourage spaghetti code.  Most modules consist of several 'always' (Verilog) or 'process' (VHDL) blocks that can be in any order.  The overall algorithm or function of the module is often totally obscured.  Figuring out how the code works (if you didn't write it) is a painful process.\n\nA few years ago I came across [this paper](http://www.gaisler.com/doc/vhdl2proc.pdf) that outlines a more structured method for VHDL design.  The basic idea is that each module has only 2 process blocks.  One for combinatorial code, and other for synchronous (the registers).  It is great for producing readable and maintainable code.  \n", "accept": false, "score": 27}, {"body": "- in HDL, some parts of the code can work at the same time, for example two lines of code \"can work\" at the same time, this is an advantage, to use wisely. \nthis is something that a programmer who is accustomed to line by line languages may find hard to grasp at first:- - - - Special attention should be given to the booting process - once your chip is functional, you have made a huge way.\n\nDebugging on hardware is usually much harder than debugging software so:\n\n- Simple code is preferred, sometimes there are other ways to speed-up your code, after \nit is already running, for example using an higher speed chip, etc'. - Avoid \"smart\" protocols between components.- A working code in HDL is more precious than on other software, as hardware is so hard to debug, so reuse, and also consider using \"libraries\" of modules which some are free and others sold.- designing should consider not only bugs in the HDL code, but also failures on the chip you are programming, and on other hardware devices that interface with the chip, so one should really think about a design that is easy to check. \n\nSome debugging tips:\n\n- If a design includes several building blocks, one would probably want to create lines from the interfaces between those blocks to testing points outside the chip.- You will want to save enough lines in your design to divert interesting data to be inspected with external devices. also you can use this lines, and your code as a way of telling you the current state of execution - for example if you receive data at some \npoint, you write some value to the lines, at a later stage of execution you write another value, etc' If your chip is reconfigurable this will become even more handy, as you can tailor specific tests, and reprogram the outputs for each test as you go (this looks very well with leds :). )\n\n\n\nBy smart protocols, I've meant that should two of your physical units connect, they should communicate with the simplest communication protocol available. that is, do not use any sophisticated home-made protocols, between them.   \n\nThe reason, is this -\nFidning bugs \"inside\" an FPGA/ASIC is reletivly easy as you have simulators.\nSo if you are sure that data comes as you want it, and goes out as your program sends it,\nyou've reached Hardware utopia - being able to work at software level :) (with the simulator).\nBut if your data doesn't get to you, the way you want it to, and you have to figure out why... you'll have to connect to the lines, and that's not that easy.\n\nFinding a bug on the lines, is hard as you have to connect to the lines with special equipment, that record the states of the lines, on different times, and you'll have to  make sure your lines act according to the protocol.  \n\nIf you need to connect two of your physical units make the \"protocol\" as simple as it can , up to the point it won't be called a protocol :) \nFor example if the units share a clock, add x data lines between them, and make one unit write those and the other unit read, thus passing one \"word\" which has x bits between them on each clock fall, for example. \nIf you have FPGA's, should the original clock rate be too fast for parallel data - you can control the speed of this, according to your experiments, for example making the data stay on lines of at least 't' clock cycles etc'. \nI assume parallel data transfer is simpler, as you can work with at lower clock rates and get the same performances, without the need to split your words on one unit, and reassemble on the other. (hopefully there is no delay between the 'clock' each unit receives).\nEven this is probably too complex :)\n\nRegarding SPI, I2C etc' I haven't implemented any of them,\nI can say that I've connected legs of two FPGA's running from the same clock, (don't remember the exact formation of resistors in the middle), at much higher rates, so I really can't think of a good reason to use those, as the main way to pass data between your own FPGA's, unless the FPGA's are located very far one from another, which is one reason to use a serial rather than a parallel bus.  \n\n[JTAG](http://en.wikipedia.org/wiki/Joint_Test_Action_Group) is used by some FPGA companies, to test/program their products, but not sure if it's used as way to transport data at high speeds, and It is a protocol... (still one which may have some built-in on chip support).\n\nIf you do have to implement any known protocol, consider using a pre-made HDL code for this - which can be found or purchased.\n", "accept": false, "score": 6}, {"body": "\n## This is the question that requires JBDAVID's 10 commandments for Hardware design.\n\n\n\n\n1. Use Revision/Version Control, just like in Software. SVN and Hg are free.\n2. Require the code to pass syntax checking before check-in. A LINT tool is better.\n3. Use a full-strength Hardware Verification Language for design Verification. System-Verilog is nearly a safe choice.\n4. Track Bugs. Bugzilla and GNATS are free tools. FogBugz requires a little $.\n5. Use Assertions to catch issues with incorrect use.\n6. The Coverage Triad makes for a stable design: Measure Code coverage, Functional coverage and Assertion coverage in both simulation and formal tools.\n7. Power is King: use CPF or UPF to capture, enforce and verify your Power-Intent.\n8. the real design is often mixed signal, Use a Mixed-Signal language to verify the analog with the digital. Verilog-AMS is one such solution. But don't go overboard. Realnumber modeling can accomplish most of the functional aspects of mixed-signal behavior.\n9. Use Hardware Acceleration to validate the Software that has to work with the silicon!\n10. Syntax Aware text editors for your HDL/HVL are a minimum requirement for developer IDE.\n\n\n", "accept": false, "score": 6}, {"body": "For FPGAs, Xilinx has [this page](https://www.xilinx.com/support/documentation/white_papers/wp231.pdf). Almost all would apply to other FPGA vendors, or would have equivalent rules.  A great deal is applicable to ASIC designs.\n\nIntel has Recommended HDL Coding Styles and Design Recommendations(PDF)[under this page](https://www.intel.com/content/www/us/en/programmable/products/design-software/fpga-design/quartus-prime/user-guides.html).\n", "accept": false, "score": 5}, {"body": "Sort of an old thread, but wanted to put in my $0.02.  This isn't really specific to Verilog/VHDL.. more on hardware design in general... specifically synthesizable design for custom ASICs. \n\nThis is my  based on years of industry (as opposed to academic) experience on design.  They are in no particular order \n\nMy umbrella statement is to Design for validation execution.  In hardware design, validation is paramount.  Bugs are a lot more expensive when found in actual silicon.  You can't just re-compile.  Therefore, pre-silicon is given much more focus. \n\n- Know the difference between control paths and data paths.  This enables you to create much more elegant and maintainable code.  Also allows you to save gates and minimize X propagation.  For instance, data paths should never need resettable flops, control paths should always need it.- Prove functionality before validation.  Either through a formal approach or through waveforms.  This has many advantages, I will explain 2.  First, it will save you wasted time onion peeling through issues.  Unlike lots of application level design (esp while learning) and most course work, the turn-around time for code changes is very large (anywhere from 10 minutes to days, depending on complexity).  Every time you change code, you need to go through elaboration, lint checking, compiling, waveform bring-up, and finally actual simulation.. which can itself take hours.  Second, you are much less likely to have difficult to hit corner cases.   Note this is with respect to pre-silicon validation.  These will surely hit at post-silicon costing you lots of $$$.  Trust me, the up front cost of proving functionality greatly minimizes risk and is well worth the effort. This is sometimes difficult to convince recent college grads.- Have \"chicken bits\".  Chicken bits are bits in MMIO set via the driver to disable a feature in silicon.  It's intended to revert changes made in which confidence is not high (confidence is directly proportional to validation efforts).  It is next to impossible to hit every possible state in pre-silicon.  Confidence on your design cannot truly be met until it's proven in post-silicon.  Even if there is only 1 state that is hit 0.000005% of the time that exposes the bug, it WILL HIT in post-silicon, but not necessarily in pre-silicon.- Avoid exceptions in the control path at all costs.  Every new exception you have doubles your validation efforts.  This one is hard to explain.  Lets say there is a DMA block that will save out data to memory that another block will use.  Lets say the data structure saved out is dependent on some function being done.  If you decided to design such that the data structure saved was different between different functions, you just multiplied your validation efforts by the number of DMA functions.  If this rule is followed, the data structure saved out would be a super-set of all data available for every function where the content locations are hardcoded.  Once the DMA save logic is validated for 1 function its  validated for all functions.- Minimize interfaces (read minimize control paths).  This is related to minimizing exceptions.  First, every new interface requires validation.  This includes new checkers/trackers, assertions, coverage points, and bus functional models in your testbench.  Secondly, it can increase your validation efforts exponentially!  Lets say you have 1 interface for reading data in caches.  Now lets say (for some odd reason) you decide you want another interface for reading main memory. You just quadrupled your validation efforts.  You now need to validate these combinations at any given time :- - - - - Understand and communicate assumptions.  Lacking this is the main reason for block to block communication issues.  You could have a perfect block fully validated.. however,  without understanding all assumptions, your block will fail when its connected.- Minimize potential states.  The less states (intended or unintended) a design has, the less effort required to validate.  It's good practice to group like functions into 1 top level function (like sequencers and arbiters).  It is very difficult to identify and define this high level function such that it encompasses as many smaller functions as possible, but in doing so you vastly eliminate state and in turn potential for bugs.- Always provide a strong signal leaving your block.  Most of the time flopping it is the solution. You have no idea what the endpoint block(s) will do with it.  You could run into timing issues which can have a direct impact on your perfect implementation.- Avoid mealy type FSMs unless performance is negatively impacted.  Mealy FSMs are more likely to produce timing issues over Moore- .. and finally the one I dislike the most: \"if it ain't broke, don't fix it\"  Because of the risk involved and the high cost of bugs, many times hacking is a more practical solution to solving problems.  Others have eluded to this by mentioning utilization of existing components.\n\nAs for comparing against more  software design:\n\n- discrete event driven programming is a completely different paradigm.  People see verilog syntax and think \"oh, its just like C\"... however, this cannot be further from the truth.  Although the syntax is similar, one must think differently.  For example, a traditional debugger is virtually meaningless on synthesizable RTL (Testbench design is different).  Waveforms on paper are the best tool available.  However, that being said, FSM design can at times mimic procedural programming.  People with a software background tend to go crazy with FSMs (I know I did at first).- System Verilog has lots and lots (and lots) of testbench specific features.  It is completely object oriented.  As far as testbench design goes, its very similar to traditional software design.  However, it does have 1 more dimension associated with it, that of time.  race conditions and protocol delays must be accounted for- As for validation, it is also different (and the same).  There are 3 main approaches; - - - \n\n... for completeness, I need to also discuss best test-bench design practices... but that's for another day\n\nSorry for the length.. I was in \"The Zone\" :)\n", "accept": false, "score": 66}], "score": [102.0, 1.910454407960121e-238, 1.447554086385848e-231, 8.063725718849764e-233, 4.542725957859125e-239, 132.0]}
{"question": "Consider the following problem. You have a bit-string that represents the current scheduled slave in one-hot encoding. For example, \"00000100\" (with the leftmost bit being #7 and rightmost #0) means that slave #2 is scheduled. \n\nNow, I want to pick the next scheduled slave in a round-robin scheduling scheme, with a twist. I have a \"request mask\" which says which slaves actually want to be scheduled. The next slave will be picked only from those that want to.\n\nSome examples (assume round-robin scheduling is done by rotating left). \nExample1:\n\n- - - \n\nExample2:\n\n- - - \n\n\n---\n\n\n\nNow, this can be easily coded in a loop, I know. But I actually want to get my result by a bit-twiddling operation, without loops. The motivation: I want to implement this in hardware (in an FPGA) in VHDL/Verilog.\n\nA bonus is to make up an algorithm that's generic for any amount of slaves N.\n\nBy the way, this is not a homework question. It's an important problem whenever one wants to schedule slaves in some manner, and condition the scheduling by the slaves' requests. My current solution is somewhat \"heavy\" and I wanted to know if I'm missing something obvious.\n", "answer": [{"body": "Assuming twos complement representation, call your two words `mask` and `current`, in C:\n\n```\nmask_lo = (current << 1) - 1; // the bits to the right and including current\nmask_hi = ~mask_lo;           // the bits to the left of current\n                              // the left bits, otherwise right:\nnext = (mask & mask_hi) ? (mask & mask_hi) : (mask & mask_lo);\nreturn (next & -next);        // the least significant bit set\n```\n\n", "accept": false, "score": 2}, {"body": "Subracting 1 is the essential idea here. It's used to cascade borrows through the bits to find the next task.\n\n```\nbits_before_current = ~(current-1) & ~current\nbits_after_current = current-1\ntodo = (mask & bits_before_current) \nif todo==0: todo = (mask & bits_after_current) // second part is if we have to wrap around\nnext = last_bit_of_todo = todo & -todo\n```\n\n\nThis will use a loop internally though...\n", "accept": false, "score": 2}, {"body": "Interesting problem!  I can't help but wonder if you can't simplify your scheduler operation so this sort of operation would be necessary.\n\nGiven that you know VHDL, I won't go into detail, but my suggestion would be the following:\n\nUse a 3 bit encoder to turn the currently scheduled task into a number:\n\n01000000 --> 6\n\nThen use a barrel shifter to rotate the mask by that number + 1 (to skip the current task):\n\n00001010 --> 00010100\n\nThen use a priority encoder to find the first available \"next\" task:\n\n00010100 --> 00000100 --> 2\n\nThen reverse the barrel shift by addition:\n\n(2+7) % 8 = 1\n\nWhich when re-encoded will give the next scheduled task:\n\n00000010\n\nShould be very fast and straightforward, although the barrel shifter is 'expensive' in terms of realestate, but I don't see an easy way to get around that at the moment.\n\nEdit: Doug's solution is significantly more elegant...\n\n-Adam\n", "accept": false, "score": 2}, {"body": "A loop does not have to be bad. \n\nI would simply do \n\n```\ncurrent[i] = current[i-1] & mask[i] |                         // normal shift logic\n                mask[i] & current[i-2] & !mask[i-1] |         // here build logic \n                ...                                          // expression for \n                                                             // remaining\n```\n\n\nAnd then put it into a generate loop (ie it will get unrolled into hardware), which will produce parallel hardware for the expressions. \n\nOther here mentioned solutions use multiple \"-\". I can only discourage them, as this will get you a really expensive operation. Esp. in one hot you can get easily more than > 32 bits, which will not easily be implementable in HW, as the borrow has to go through all bits (the deadicated carry logic on certain fpgas make it approachable for small number of bits). \n", "accept": false, "score": 6}, {"body": "The following solution works for any number of slaves (K), and is O(n) in your FPGA. For each bit in the field, you will require three logic gates and two inverters. I tested out the concept with a basic logic simulator, and it works.\n\nThe chain of logic gates between  and  essentially creates a priority system that favors bits \"lower down\" in the chain. This chain is looped at the ends, but the  bits are used to break the chain.\n\nTo visualize the operation, imagine that bit  is set in the  field, and follow the signal downwards in the diagram. The logical one at bit  places a logical zero at the input to the first AND gate, which guarantees that the output of that AND gate will also be zero (this is where the OR-gate chain is broken). The zero at the output of the first AND gate places a one at the input to the second AND gate. This makes bit  of  directly dependent on bit  of .\n\nNow, the chain of OR gates comes into play.\n\nIf bit  of  was set, the logical output of the OR gate directly to the left of it will also be a one, which will place a logical one at the input to the AND gate below bit  of  (which will be zero, since only one bit in  can be set at a time). The logical one at the output of the top AND gate places a logical zero at the input of the bottom AND gate, thus setting bit  of  equal to zero.\n\nIf bit  of  was not set, both inputs to the OR gate would be zero, so the output of the AND gate below bit  of  would be a zero, placing a one at the input to the bottom AND gate, and therefore making bit  of  dependent on bit  of .\n\nThis logic follows the chain of OR gates \"up\" the bits, looping around from the left side back over to the right, ensuring that only one bit in  can be set to a one. The loop stops once it makes its way back to bit  of , as a result of that bit being set. This prevents the circuit from staying in a perpetual loop.\n\nI have no experience with Verilog or VHDL, so I'll leave the actual code up to you [and the rest of stackoverflow](https://stackoverflow.com/questions/486471/how-would-you-implement-this-digital-logic-in-verilog-or-vhdl).\n\n[alt text http://img145.imageshack.us/img145/5125/bitshifterlogicdiagramkn7.jpg](http://img145.imageshack.us/img145/5125/bitshifterlogicdiagramkn7.jpg)\n\n\n\n\n1. This solution is only partial. It will still require some kind of latching mechanism to hold the bit fields.\n2. Keep in mind that as you increase the number of bits, the time required for the gate voltages to settle will also increase.\n3. There will have to be some logic in place to handle the case where the current field is equal to zero. See this stackoverflow question.\n\n\n", "accept": false, "score": 3}, {"body": "This should do what you want:\n\n```\nnumber_of_tasks= <number of tasks, in the example this is 8>\nnext_mask= current | (current - 1);\nnext_barrel= next | (next << number_of_tasks);\nnext_barrel&= ~number_of_tasks;\nnext_barrel&= -next_barrel;\nnext_barrel|= next_barrel >> number_of_tasks;\nnext_task_mask= next_barrel & -next_barrel;\n```\n\n\nBasically, duplicate the bits of the next task mask, mask off the bits we don't want to consider, find the lowest set bit, fold the high bits back in, then take the lowest bit set. This runs in constant time.\n\nEdit: Updating to take into account current == 00010000 and next_mask == 00111000\n", "accept": false, "score": 1}, {"body": "I've found the following Verilog code for implementing the task in the Altera advanced synthesis cookbook. \n\n```\n// 'base' is a one hot signal indicating the first request\n// that should be considered for a grant.  Followed by higher\n// indexed requests, then wrapping around.\n//\n\nmodule arbiter (\n    req, grant, base\n);\n\nparameter WIDTH = 16;\n\ninput [WIDTH-1:0] req;\noutput [WIDTH-1:0] grant;\ninput [WIDTH-1:0] base;\n\nwire [2*WIDTH-1:0] double_req = {req,req};\nwire [2*WIDTH-1:0] double_grant = double_req & ~(double_req-base);\nassign grant = double_grant[WIDTH-1:0] | double_grant[2*WIDTH-1:WIDTH];\n\nendmodule\n```\n\n\nIt uses subtraction (only once, though), so conceptually it's quite similar to Doug's solution.\n", "accept": true, "score": 4}, {"body": "Untested, but off the top of my head, I'd be surprised if this didn't produce ma reasonable synthesis... Has the advantage of being relatively readable (to me anyway) unlike typical bit-twiddling hacks.\n\n```\nfor i in current'range loop\n  current := rotate_left(current, 1);\n  if or_reduce(mask and current) = '1' then\n     current:= mask and current;\n  end if;\nend loop;\n```\n\n", "accept": false, "score": 1}, {"body": "Complete parametrizable arbiter implementation that can be configured for round-robin or priority arbitration:\n\n[https://github.com/alexforencich/verilog-axis/blob/master/rtl/arbiter.v](https://github.com/alexforencich/verilog-axis/blob/master/rtl/arbiter.v)\n\nThis design uses a pair of priority encoders to select the next output in the sequence.  The priority encoders used are implemented efficiently as trees.  \n", "accept": false, "score": 0}], "score": [1.1930567841609633e-156, 1.2484262950063107e-156, 2.0, 0.0, 7.356246022158964e-232, 1.333444532275213e-157, 8.0, 1.929079468237971e-157, 0.0]}
{"question": "Although I tagged this homework, it is actually for a course which I am doing on my own for free. Anyway, the course is called \"From Nand to Tetris\" and I'm hoping someone here has seen or taken the course so I can get some help. I am at the stage where I am building the ALU with the supplied hdl language. My problem is that I can't get my chip to compile properly. I am getting errors when I try to set the output flags for the ALU. I believe the problem is that I can't subscript any intermediate variable, since when I just try setting the flags to true or false based on some random variable (say an input flag), I do not get the errors. I know the problem is not with the chips I am trying to use since I am using all builtin chips.\n\nHere is my ALU chip so far:\n\n```\n/**\n * The ALU.  Computes a pre-defined set of functions out = f(x,y)\n * where x and y are two 16-bit inputs. The function f is selected \n * by a set of 6 control bits denoted zx, nx, zy, ny, f, no.\n * The ALU operation can be described using the following pseudocode:\n *     if zx=1 set x = 0       // 16-bit zero constant\n *     if nx=1 set x = !x      // Bit-wise negation\n *     if zy=1 set y = 0       // 16-bit zero constant\n *     if ny=1 set y = !y      // Bit-wise negation\n *     if f=1  set out = x + y // Integer 2's complement addition\n *     else    set out = x & y // Bit-wise And\n *     if no=1 set out = !out  // Bit-wise negation\n *\n * In addition to computing out, the ALU computes two 1-bit outputs:\n *     if out=0 set zr = 1 else zr = 0 // 16-bit equality comparison\n *     if out<0 set ng = 1 else ng = 0 // 2's complement comparison\n */\n\nCHIP ALU {\n\nIN  // 16-bit inputs:\n    x[16], y[16],\n    // Control bits:\n    zx, // Zero the x input\n    nx, // Negate the x input\n    zy, // Zero the y input\n    ny, // Negate the y input\n    f,  // Function code: 1 for add, 0 for and\n    no; // Negate the out output\n\nOUT // 16-bit output\n    out[16],\n\n    // ALU output flags\n    zr, // 1 if out=0, 0 otherwise\n    ng; // 1 if out<0, 0 otherwise\n\nPARTS:\n// Zero the x input\nMux16( a=x, b=false, sel=zx, out=x2 );\n\n// Zero the y input\nMux16( a=y, b=false, sel=zy, out=y2 );\n\n// Negate the x input\nNot16( in=x, out=notx );\nMux16( a=x, b=notx, sel=nx, out=x3 );\n\n// Negate the y input\nNot16( in=y, out=noty );\nMux16( a=y, b=noty, sel=ny, out=y3 );\n\n// Perform f\nAdd16( a=x3, b=y3, out=addout );\nAnd16( a=x3, b=y3, out=andout );\nMux16( a=andout, b=addout, sel=f, out=preout );\n\n// Negate the output\nNot16( in=preout, out=notpreout );\nMux16( a=preout, b=notpreout, sel=no, out=out );\n\n// zr flag\nOr8way( in=out[0..7], out=zr1 );   // PROBLEM SHOWS UP HERE\nOr8way( in=out[8..15], out=zr2 );\nOr( a=zr1, b=zr2, out=zr );\n\n// ng flag\nNot( in=out[15], out=ng );\n\n}\n```\n\n\nSo the problem shows up when I am trying to send a subscripted version of 'out' to the Or8Way chip. I've tried using a different variable than 'out', but with the same problem. Then I read that you are not able to subscript intermediate variables. I thought maybe if I sent the intermediate variable to some other chip, and that chip subscripted it, it would solve the problem, but it has the same error. Unfortunately I just can't think of a way to set the zr and ng flags without subscripting some intermediate variable, so I'm really stuck!\n\nJust so you know, if I replace the problematic lines with the following, it will compile (but not give the right results since I'm just using some random input):\n\n```\n// zr flag\nNot( in=zx, out=zr );\n\n// ng flag\nNot( in=zx, out=ng );\n```\n\n\nAnyone have any ideas?\n\n Here is the [appendix of the book for the course](http://www1.idc.ac.il/tecs/book/appendixA.pdf) which specifies how the hdl works. Specifically look at section 5 which talks about buses and says: \"An internal pin (like v above) may not be subscripted\".\n\n Here is the exact error I get: \"Line 68, Can't connect gate's output pin to part\". The error message is sort of confusing though, since that does not seem to be the actual problem. If I just replace \"Or8way( in=out[0..7], out=zr1 );\" with \"Or8way( in=false, out=zr1 );\" it will not generate this error, which is what lead me to look up in the appendix and find that the out variable, since it was derived as intermediate, could not be subscripted.\n", "answer": [{"body": "Have you tried:\n\n```\n// zr flag\nOr8way(\n    in[0]=out[ 0], in[1]=out[ 1], in[2]=out[ 2], in[3]=out[ 3],\n    in[4]=out[ 4], in[5]=out[ 5], in[6]=out[ 6], in[7]=out[ 7],\n    out=zr1);\nOr8way(\n    in[0]=out[ 8], in[1]=out[ 9], in[2]=out[10], in[3]=out[11],\n    in[4]=out[12], in[5]=out[13], in[6]=out[14], in[7]=out[15],\n    out=zr2);\nOr( a=zr1, b=zr2, out=zr );\n```\n\n\nI don't know if this will work but it seems to make sense from looking at this document [here](http://moodle.cornellcollege.edu/0809/file.php/944/qa218-31Oct2008.pdf).\n\nI'd also think twice about using `out` as a variable name since it's confusing trying to figure out the difference between that and the keyword `out` (as in \"`out=...`\").\n\nFollowing your edit, if you cannot subscript intermediate values, then it appears you will have to implement a separate \"chip\" such as `IsZero16` which will take a 16-bit value as input (your intermediate `out`) and return one bit indicating its zero-ness that you can load into `zr`. Or you could make an `IsZero8` chip but you'd have to then call it it two stages as you're currently doing with `Or8Way`.\n\nThis seems like a valid solution since you  subscript the input values to a chip.\n\nAnd, just looking at the error, this may be a different problem to the one you suggest. The phrase \"Can't connect gate's output pin to part\" would mean to me that you're unable to connect signals from the output parameter back into the chips processing area. That makes sense from an electrical point of view.\n\nYou may find you have to store the output into a temporary variable and use that to both set `zr` and `out` (since once the signals have been \"sent\" to the chips output pins, they may no longer be available).\n\nCan we try:\n\n```\nCHIP SetFlags16 {\n    IN  inpval[16];\n    OUT zflag,nflag;\n    PARTS:\n        Or8way(in=inpval[0.. 7],out=zr0);\n        Or8way(in=inpval[8..15],out=zr1);\n        Or(a=zr0,b=zr1,out=zflag);\n        Not(in=inpval[15],out=nflag);\n}\n```\n\n\nand then, in your ALU chip, use this at the end:\n\n```\n// Negate the output\nNot16( in=preout, out=notpreout );\nMux16( a=preout, b=notpreout, sel=no, out=tempout );\n\n// flags\nSetFlags16(inpval=tempout,zflag=zr,nflag=ng);\n\n// Transfer tempout to out (may be a better way).\nOr16(a=tempout,b=tempout,out=out);\n```\n\n", "accept": false, "score": 1}, {"body": "The solution as Pax suggested was to use an intermediate variable as input to another chip, such as Or16Way. Here is the code after I fixed the problem and debugged:\n\n```\nCHIP ALU {\n\nIN  // 16-bit inputs:\n    x[16], y[16],\n    // Control bits:\n    zx, // Zero the x input\n    nx, // Negate the x input\n    zy, // Zero the y input\n    ny, // Negate the y input\n    f,  // Function code: 1 for add, 0 for and\n    no; // Negate the out output\n\nOUT // 16-bit output\n    out[16],\n\n    // ALU output flags\n    zr, // 1 if out=0, 0 otherwise\n    ng; // 1 if out<0, 0 otherwise\n\nPARTS:\n// Zero the x input\nMux16( a=x, b=false, sel=zx, out=x2 );\n\n// Zero the y input\nMux16( a=y, b=false, sel=zy, out=y2 );\n\n// Negate the x input\nNot16( in=x2, out=notx );\nMux16( a=x2, b=notx, sel=nx, out=x3 );\n\n// Negate the y input\nNot16( in=y2, out=noty );\nMux16( a=y2, b=noty, sel=ny, out=y3 );\n\n// Perform f\nAdd16( a=x3, b=y3, out=addout );\nAnd16( a=x3, b=y3, out=andout );\nMux16( a=andout, b=addout, sel=f, out=preout );\n\n// Negate the output\nNot16( in=preout, out=notpreout );\nMux16( a=preout, b=notpreout, sel=no, out=preout2 );\n\n// zr flag\nOr16Way( in=preout2, out=notzr );\nNot( in=notzr, out=zr );\n\n// ng flag\nAnd16( a=preout2, b=true, out[15]=ng );\n\n// Get final output\nAnd16( a=preout2, b=preout2, out=out );\n}\n```\n\n", "accept": true, "score": 5}, {"body": "For anyone else interested, the solution the emulator supports is to use multiple outputs\nSomething like:\n\n```\nMux16( a=preout, b=notpreout, sel=no, out=out,out=preout2,out[15]=ng);\n```\n\n", "accept": false, "score": 23}, {"body": "Here's one also with a new chip but it feels cleaner\n\n```\n/**\n * Negator16 - negates the input 16-bit value if the selection flag is lit\n */\nCHIP Negator16 {\n  IN sel,in[16];\n  OUT out[16];\n\n  PARTS:\n  Not16(in=in, out=negateIn);\n  Mux16(a=in, b=negateIn, sel=sel, out=out);\n}\n\nCHIP ALU {\n  // IN and OUT go here...\n  PARTS:\n  //Zero x and y if needed\n  Mux16(a=x, b[0..15]=false, sel=zx, out=x1);\n  Mux16(a=y, b[0..15]=false, sel=zy, out=y1);\n\n  //Create x1 and y1 negations if needed\n  Negator16(in=x1, sel=nx, out=x2);\n  Negator16(in=y1, sel=ny, out=y2);\n\n  //Create x&y and x+y\n  And16(a=x2, b=y2, out=andXY);\n  Add16(a=x2, b=y2, out=addXY);\n\n  //Choose between And/Add according to selection\n  Mux16(a=andXY, b=addXY, sel=f, out=res);\n\n  // negate if needed and also set negative flag\n  Negator16(in=res, sel=no, out=res1, out=out, out[15]=ng);\n\n  // set zero flag (or all bits and negate)\n  Or16Way(in=res1, out=nzr);\n  Not(in=nzr, out=zr);\n}\n```\n\n", "accept": false, "score": 1}, {"body": "This is how I did the ALU:\n\n```\nCHIP ALU {\nIN  // 16-bit inputs:\n    x[16], y[16],\n    // Control bits:\n    zx, // Zero the x input\n    nx, // Negate the x input\n    zy, // Zero the y input\n    ny, // Negate the y input\n    f,  // Function code: 1 for add, 0 for and\n    no; // Negate the out output\nOUT // 16-bit output\n    out[16],\n    // ALU output flags\n    zr, // 1 if out=0, 0 otherwise\n    ng; // 1 if out<0, 0 otherwise\nPARTS:      \n    Mux16(a=x, b=false, sel=zx, out=M16x);\n    Not16(in=M16x, out=Nx);\n    Mux16(a=M16x, b=Nx, sel=nx, out=M16M16x);\n\n    Mux16(a=y, b=false, sel=zy, out=M16y);\n    Not16(in=M16y, out=Ny);\n    Mux16(a=M16y, b=Ny, sel=ny, out=M16M16y);\n\n    And16(a=M16M16x, b=M16M16y, out=And16);\n    Add16(a=M16M16x, b=M16M16y, out=Add16);\n    Mux16(a=And16, b=Add16, sel=f, out=F16);\n\n    Not16(in=F16, out=NF16);\n    Mux16(a=F16, b=NF16, sel=no, out=out, out[15]=ng, out[0..7]=zout1, out[8..15]=zout2);\n\n    Or8Way(in=zout1, out=zr1);\n    Or8Way(in=zout2, out=zr2);\n    Or(a=zr1, b=zr2, out=zr3);\n    Not(in=zr3, out=zr);\n}\n```\n\n", "accept": false, "score": 6}], "score": [5.522747411140165e-79, 10.0, 6.988778000541185e-157, 4.69079964863453e-79, 1.582899594907076e-78]}
{"question": "I am assigned with the task of verifying some verilog based RTL code. Now, coding the RTL testbench using verilog seems to be very difficult (for me). So I would like to try one of the following.\n- Try providing a PLI interface to the RTL and thereby invoke 'C functions for testing\n- Using system 'C for interfacing the 'C functions\n\nPS: I already have a extensive 'C code that was used for testing the behavioral model. I am new to the world of hardware programming. Any pointers would be greatly appreciated.\n", "answer": [{"body": "If you already have extensive C code that was used to test the behavioral model, then the thing to do is to just add a PLI (or DPI) interface that will allow you to call that c code from verilog.\n\nSystemC is basically C++ with a lot of classes that allow you to model HW. I don't see how you would benefit from learning SystemC for the task you are attempting as you already have a C model available that you can test the HW against. Learning SystemC is probably overkill for what you are trying to do.\n\nFYI. If you want to learn something that is heavily used in the industry today then I would suggest that you learn SystemVerilog. These days SystemVerilog, basically verilog with a bunch of high level software language features built in; along with \"VMM\", a \"verification methodology\" (i.e. a bunch of libraries), seems to be all the rage in hardware verification land.\n", "accept": true, "score": 5}, {"body": "The question is not so easy to answer without knowing your DUV (device under verification) or the C code you have. You need means to stimulate and check your design, here you probably need to translate from/to transaction level (C data structures) to/from pin level. SystemVerilog interfaces or SystemC may be an approach. I haven't used DPI/PLI interfaces yet.\n\nTo have a \"state-of-the-art\" testbench you should consider to use one of the testbench methodologies out there, namely [VMM](http://www.vmm-sv.org/) or [OVM](http://www.ovmworld.org/). They will also provide you with documentation how to get started.\n", "accept": false, "score": 4}, {"body": "Sounds like you should get a tool like Mentor's or Cadence's simulators that combine RTL and SystemC code under a single system. Not free, certainly, but they are the solution for that exists in practice. \n\nThe structurally correct solution you need is for the C or SystemC to call into the RTL, not the other way around. Doing this implies integrating some RTL simulator with your C program or SystemC program. It is certainly doable, but a pretty big undertaking.\n\nAlso, i think that using SystemVerilog makes a lot of sense.\n", "accept": false, "score": 0}, {"body": "I've used both for SystemC and System Verilog/VMM for verification, and the answer is, it depends.  When I was with a startup that was on a shoestring budget trying to get their first ASIC out the door, SystemC was a natural choice because it ran on our low-budget simulator and SystemVerilog did not.  With SystemC, you don't need to use the PLI or the DPI.  You actually instantiate your SystemC model as a component in your testbench, which is interesting.  \n\nHowever, SystemC is a C++ library that does NOT have a very intuitive syntax.  You should have a decent C++ background before attempting to learn the SystemC library.  The books for this that are available mostly suck, except for \"SystemC from the Ground Up\" by David Black.\n\nThat begin said, from what I've seen, SystemC is naturally a high-level modeling language, not a verification language, and nobody with any budget to buy real simulators is using SystemC for verification anymore.  From a general career development standpoint, I would use System Verilog if it is available to you.  Plus, you can always use the DPI to interface to your C model for output checking, which still using generators, monitors and scoreboards written in SV/VMM.\n", "accept": false, "score": 0}], "score": [10.0, 8.0, 0.0, 0.0]}
{"question": "Currently I am testing some RTL, I am using ncverilog, and it is very ... very slow. I have heard that, if we use some kind of FPGA boards, then things will be faster. Is it for real?\n", "answer": [{"body": "What kind of RTL are you testing ? If you use FPGA boards, then you can compile\nyour code provided you have the right tool for the right FPGA. Since FPGA are reprograammable, then of course you can test your code on the board, and have the target (FPGA) execute your code (RTL)\n\nBut it is no more a simulation, it is a test, with a given hardware, at a given clock speed.\nAnd you don't get nice result on the screen, you need to use physical probe and scope. Plus you don't get to see how the internal of your code is working.\n\nverilog or VHDL simulation is sort of like running code using a debugger. FPGA testing is more like debugging with printf. The big difference is that when simulating, your CPU has to simulate the behaviour of all those logic gate that results of your code. On the FPGA, there is no simulation, you just 'run' the code, so it is much faster, but you have less information.\n\nYou should use simulation for very small components, and then test your whole program on a FPGA.\n", "accept": false, "score": 2}, {"body": "You're talking about two different things. \n\nNCVerilog is a simulation tool while an FPGA board is real hardware. So, there will be differences. Real hardware will be generally faster but with a simulator, you can have all sorts of debugging fun. Trying to probe a specific signal is just a matter of adding a line to the testbench. Also, you can easily make changes to the simulated model instead of having to redesign the FPGA board.\n\nIf you run simulation on a sufficiently powerful machine, you can sometimes approximate real-world performance (assuming that the FPGA is a slow one).\n\nAll in all, you should do both. Use a simulator to do your basic development and evaluation. Move onto your FPGA hardware once your design is sufficiently well defined.\n", "accept": true, "score": 3}, {"body": "We've had the same issues with simulation speed too.  However, we stick with simulations for the majority of our verification.  Each sim checks a specific function and are much quicker than system-level sims.  We've also made them self-checking and are useful for regressions tests (unit-tests).\n\nFor long system tests on real-world signals that take too much time to simulate, we move these to the FPGA if we can.  We need to manually re-check all these testcases again after code changes, so it can be slow in its own way.\n\nSometimes though, FPGAing a design is just not feasible. Sometimes full designs are too large to fit into an FPGA, or the clock rate is too high.  But remember that you don't necessarily have to FPGA your entire design, it may be enough to get the important block you're interested in and check this out fully.\n", "accept": false, "score": 3}, {"body": "You can trace activity on signals in a running FPGA design using \"embedded logic analyzer\" software tools like Altera SignalTap or Xilinx ChipScope.  Before synthesizing/mapping your RTL to the device, you would use these tools to attach soft probes to the signals you want to watch.  You can set triggers so that a signal's values only get logged under certain conditions.  Then you generate the bitfile and program the device with JTAG.  The logic analyzer communicates with your PC over JTAG and logs activity on your probes, which you can then analyze.\n\nIt's a bit complicated to set up, as these tools are not especially easy to use, but you will get results much faster than with RTL simulation.\n", "accept": false, "score": 3}, {"body": "You're probably asking about hardware simulation accelerators. \nHere is one of them : [GateRocket](http://www.gaterocket.com/)\n", "accept": false, "score": 1}], "score": [1.6053711764843032e-232, 6.0, 3.0, 0.0, 4.385488964314366e-236]}
{"question": "I need to generate pseudo-random numbers for my genetic algorithm on a Spartan-3E FPGA and i want to implement it in verilog: could you give me any pointers on this?\n", "answer": [{"body": "Typically you'd use the [IEEE.math_real](http://www.csee.umbc.edu/help/VHDL/stdpkg.html) uniform function \n\n```\nuse IEEE.math_real.all;\nprocedure UNIFORM (variable Seed1,Seed2:inout integer; variable X:out real);\n```\n\n\nBut do a tiny bit a research on pseudo random number generators (PRNGs) and you'll find many variants that are simple [LFSR](http://en.wikipedia.org/wiki/Linear_feedback_shift_register)'s - which look remarkably similar to CRC generators.\n\nHere are several resources if you want to roll your own starting from existing, working PRNGs:\n\n[http://www.opencores.org/?do=project&who=systemc_rng](http://www.opencores.org/?do=project&who=systemc_rng)\n\n[http://verificationguild.com/modules.php?name=Downloads&d_op=viewdownload&cid=3](http://verificationguild.com/modules.php?name=Downloads&d_op=viewdownload&cid=3)\n\nHere's a CRC VHDL code generator:\n\n[http://www.easics.be/webtools/crctool](http://www.easics.be/webtools/crctool)\n", "accept": true, "score": 3}, {"body": "Of course the random generator by Adam is not synthesizable! You have to explicitly create an [LFSR](http://en.wikipedia.org/wiki/LFSR).\n\nFollowing example might help. It is an 8-bit maximal LFSR\n\n```\nmodule lfsr(input clk, reset, en, output reg [7:0] q);\n  always @(posedge clk or posedge reset) begin\n    if (reset)\n      q <= 8'd1; // can be anything except zero\n    else if (en)\n      q <= {q[6:0], q[7] ^ q[5] ^ q[4] ^ q[3]}; // polynomial for maximal LFSR\n  end\nendmodule;\n```\n\n", "accept": false, "score": 16}, {"body": "The pointer above to OpenCores has a file in the verilog folder called: [rng.v](http://opencores.org/project,systemc_rng)\n\nI have used it in a Spartan-3AN and it works great. My code used the random number generator to select a random PWM after I programmed the part and it covered all the selectable PWMs.\n", "accept": false, "score": 2}, {"body": "There is an online tool that can generate Verilog or VHDL code for a pseudo-random number generator. It's on [OutputLogic.com](http://OutputLogic.com)\n", "accept": false, "score": 3}, {"body": "I agree with the LFSR.  I have made one before and it is used for encryption.  \n", "accept": false, "score": 0}, {"body": "You've already got some good answers, but I'll just point out the canonical guide to LFSRs in FPGAs is here:\n\n[http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf](http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf)\n\nIt's a bit Xilinx specific in places (which is OK for your FPGA :) but the principles are transferable to others.\n", "accept": false, "score": 9}], "score": [6.0, 16.0, 1.2904510523207149e-242, 1.4677384625226494e-251, 0.0, 18.0]}
{"question": "Recently I am working with a hardware design group developing an [ASIC](https://en.wikipedia.org/wiki/Application-specific_integrated_circuit). And I am drawing a lot of timing diagrams for which I am using Microsoft Excel, as it is easy to import into Word document. But, things are getting more and more difficult with Excel.\n\nWhat can be used to draw timing diagrams? Is there any easy tool out there?\n", "answer": [{"body": "[drawtiming](http://drawtiming.sourceforge.net/samples.html) looks interesting.\n", "accept": false, "score": 5}, {"body": "Some time ago we used [IGOR](http://www.wavemetrics.com/index.html) for all kinds of measurement data visualization. But it's not for free, if that's a requirement.\n", "accept": false, "score": 1}, {"body": "If you like LaTeX and don't mind the extra steps to get the generated image into Word (on which I guess you depend), [tikz-timing](http://www.ctan.org/tex-archive/graphics/pgf/contrib/tikz-timing/) is very nice. I find it very easy to use and the diagrams look very good!\n\nApart from that, the companies I worked in so far used Visio for this kind of tasks.\n", "accept": false, "score": 10}, {"body": "I have the same problem and tried the following tools:\n\n- - [LaTeX](http://en.wikipedia.org/wiki/LaTeX)- - [Microsoft Visio](http://en.wikipedia.org/wiki/Microsoft_Visio)\n\nAfter trying all these I now ended up using Visio and pen&pencil. All other programs lacked support for adding arrows/relationships between signals easily. In Visio, such things are absolutely easy. And you can export the diagrams directly to [PowerPoint](http://en.wikipedia.org/wiki/Microsoft_PowerPoint) or even as [PDF](http://en.wikipedia.org/wiki/Portable_Document_Format) for using them in LaTeX.\n", "accept": true, "score": 13}, {"body": "[Timing Designer](http://www.timingdesigner.com) and [Timing Diagrammer](http://www.syncad.com/timing_diagrammer_timing_diagram_editor.htm) are the two main commercial programs.  They are similar in functions and user interface.  Both have OLE and other export capability.\n", "accept": false, "score": 5}, {"body": "If you are happy with simpler waveforms on a regular grid, you can quickly create something with [Timing Font](http://www.pcserviceselectronics.co.uk/fonts/) or XWave (linked from the first link). Another option would be\nGnome Dia, a simple vector drawing program.\n", "accept": false, "score": 2}, {"body": "I find it necessary to add [TimingAnalyzer](https://www.timing-diagrams.com/) to the mix.  It is only in Beta but at least he is actively developing it.  ~T\n", "accept": false, "score": 3}, {"body": "The post [Re: Visio Timing Diagram](http://www.tech-archive.net/Archive/Visio/microsoft.public.visio.developer/2004-08/0002.html) has a link to a [Visio stencil](http://www.mvps.org/visio/FTP/TIMEDIA.VSS).\n", "accept": false, "score": 7}, {"body": "I've used [Timing Designer](http://www.ema-eda.com/Products/EMADesignAutomation/TimingDesigner.aspx) and [Waveformer](http://www.syncad.com/waveformer_waveform_editor.htm). They can read basic [Verilog](http://en.wikipedia.org/wiki/Verilog) files. Waveformer has a decent demo version for Windows. You can't save designs, but you can screen capture them. For very basic timing diagrams, I've used the Visio templates mentioned in other answers. \n", "accept": false, "score": 0}, {"body": "[WaveDrom](http://wavedrom.com/) is a free and open source online digital timing diagram rendering engine that uses [JavaScript](http://en.wikipedia.org/wiki/JavaScript), [HTML5](http://en.wikipedia.org/wiki/HTML5) and [SVG](http://en.wikipedia.org/wiki/Scalable_Vector_Graphics) to convert WaveJSON input text description into SVG vector graphics.\n", "accept": false, "score": 27}, {"body": "WaveDrom tool, mentioned above, moved to GitHub [wavedrom.com](http://wavedrom.com).\n", "accept": false, "score": 3}, {"body": "You can use a \"Free Online Digital Diagram Generator\" to draw the diagram then copy and past the screen in to your documents. If you want to try a tool that do not need your login or email, and can save your editing for future use. You can try this javascript tool on google.\n[http://hardwarelanguages.blogspot.com/2016/08/free-online-digital-diagram-generator.html](http://hardwarelanguages.blogspot.com/2016/08/free-online-digital-diagram-generator.html)\n\nYour digital waveform diagram is saved in the URL encrypted, no one else can see it until your share the links with email/skypee/facebook, and etc.\n", "accept": false, "score": 0}, {"body": "Waveme [http://waveme.weebly.com/](http://waveme.weebly.com/)\n\nI just released a new free GUI-based timing diagram drawing tool for Windows (and Linux/MacOS via Wine).\n\nIt draws digital waveforms (signals and buses) with gaps, arrows and labels, and is highly customizable.\n\nI hope you find it useful.\n", "accept": false, "score": 3}, {"body": "I use an online spreadsheet like Google Docs or Excel for timing diagrams - by making all cells equal width and height and play with the borders of the cell. This is great quick way to explain simple concepts especially during collaborative (online) work.\n", "accept": false, "score": 1}], "score": [5.318985246896317e-242, 3.9134906404547264e-243, 6.043112324166863e-236, 26.0, 7.894074037118808e-240, 3.982017819080486e-240, 2.5860110319081675e-238, 1.8221178888471173e-239, 0.0, 2.8722520333240112e-241, 2.3581368227220828e-241, 0.0, 3.0, 3.21238873836367e-244]}
{"question": "I have looked on the web and the discussions/examples appear to be for traditional software development.  Since Verilog and VHDL (used for chip design, e.g. FPGAs and ASICs) are similar to software development C and C++ it would appear to make sense.  However they have some differences being fundamentally parallel and requiring hardware to fully tests.\n\nWhat experiences, good and bad, have you had?  Any links you can suggest on this specific application?\n\nEdits/clarifications:\n10/28/09:  I'm particularly asking about TDD.  I'm familiar with doing test benches, including self-checking ones.  I'm also aware that SystemVerilog has some particular features for test benches.\n\n10/28/09:  The questions implied include 1) writing a test for any functionality, never using waveforms for simulation and 2) writing test/testbenches first.\n\n11/29/09: In [Empirical Studies Show Test Driven Development Improves Quality](http://www.infoq.com/news/2009/03/TDD-Improves-Quality) they report for (software) TDD \"The pre-release defect density of the four products, measured as defects per thousand lines of code, decreased between 40% and 90% relative to the projects that did not use TDD. The teams' management reported subjectively a 15\u201335% increase in initial development time for the teams using TDD, though the teams agreed that this was offset by reduced maintenance costs.\"  The reduced bugs reduces risk for tape-out, at the expense of moderate schedule impact.  [This](http://www.agile-itea.org/public/deliverables/ITEA-AGILE-D2.7_v1.0.pdf) also has some data.\n\n11/29/09: I'm mainly doing control and datapath code, not DSP code.  For DSP, the typical solution involves a Matlab bit-accurate simulation.\n\n03/02/10: The advantage of TDD is you make sure the test fails first.  I suppose this could be done with assertions too.\n", "answer": [{"body": "The SystemVerilog extensions to the IEEE Verilog Standard include\na variety of constructs which facilitate creating thorough test suites\nfor verifying complex digital logic designs. SystemVerilog is one of\nthe Hardware Verification Languages (HVL) which is used to verify ASIC chip\ndesigns via simulation (as opposed to emulation or using FPGA's).\n\nSignificant benefits over a traditional Hardware Design Language (Verilog) are:\n\n- - - \n\nThe key is to have access to simulation software which supports\nthis recent (2005) standard.  Not all simulators fully support\nthe more advanced features.\n\nIn addition to the IEEE standard, there is an open-source SystemVerilog library\nof verification components available from VMM Central ([http://www.vmmcentral.com](http://www.vmmcentral.com)).  It provides a reasonable framework for creating a test environment.\n\nSystemVerilog is not the only HVL,and VMM is not the only library.\nBut, I would recommend both,  you have access to the appropriate\ntools.  I have found this to be an effective methodology in finding design\nbugs  becoming silicon.\n", "accept": false, "score": 4}, {"body": "I never actively tried TDD on an RTL design, but I had my thoughts on this. \n\nWhat I think would be interesting is to try out this approach in connection with assertions. You would basically first write down in form of assertions what you assume/expect from your module, write your RTL and later you can verify these assertions using formal tools and/or simulation. In contrast to \"normal\" testcases (where you probably would need to write directed ones) you should have much better coverage and the assertions/assumptions may be of use later (e.g. on system level) as well.\n\nHowever I wouldn't fully rely on assertions, this can become very hairy.\n\nMaybe you can express your thoughts on this as well, as you are asking for it I guess you carry some ideas in your head?\n", "accept": false, "score": 1}, {"body": "I write code for FPGAs, not ASICS... but TDD is my still my preferred approach.  I like to have a full suite of tests for all the functional code I write, and I try (not always successfully) to write testcode first.  Staring at waveforms always happens at some point when you're debugging, but it's not a good way of validating your code (IMHO).\n\nGiven the difficulty of performing proper tests in the real hardware (stimulating corner cases is particularly hard) and the fact that a VHDL-compile takes seconds (vs a \"to hardware\" compile that takes many minutes (or even hours)), I don't see how anyone can operate any other way!\n\nI also build assertions into the RTL as I write it to catch things I know shouldn't ever happen.  Apparantly this is seen as a bit \"weird\", as there's a perception that verification engineers write assertions and RTL designers don't.  But mostly I'm my own verification engineer, so maybe that's why!\n", "accept": true, "score": 29}, {"body": "I don't know a lot about hardware/chip design, but I am deeply into TDD, so I can at least discuss suitability of the process with you.\n\nThe question I'd call most pertinent is:  How quickly can your tests give you feedback on a design?  Related to that:  How quickly can you add new tests?  And how well do your tools support refactoring (changing structure without changing behavior) of your design?\n\nThe TDD process depends a great deal on the \"softness\" of software - good automated unit tests run in seconds (minutes at the outside), and guide short bursts of focused construction and refactoring.  Do your tools support this kind of workflow - rapidly cycling between writing and running tests and building the system under test in short iterations?\n", "accept": false, "score": 4}, {"body": "What is TDD for you? Do you mean having all your code exercised by automatic tests at all times, or do you go further to mean that tests are written before the code and no new code is written unless tests fail?\n\nWhichever approach you prefer, HDL code testing isn't very different from software testing. It has its pluses (much better coverage and depth of testing) and minuses (difficult to set up and cumbersome relatively to software).\n\nI've had very good experience with employing Python and generic HDL transactors for implementing comprehensive and automatic tests for synthesizable HDL modules. The idea is somewhat similar to what [Janick Bergeron](http://janick.bergeron.com/) presents in his books, but instead of SystemVerilog, Python is used to (1) generate VHDL code from test scenarios written in Python and (2) verification of results written by the monitoring transactors that accept waveforms from the design during simulation.\n\nThere's much more to be written about this technique, but I'm not sure what you want to focus on.\n", "accept": false, "score": 1}, {"body": "With regard to refactoring tools for hardware languages, I'd like to point you to our tool [Sigasi HDT](http://www.sigasi.com). Sigasi provides an IDE with built-in VHDL analyzer and VHDL refactorings.\n\nPhilippe Faes, Sigasi\n", "accept": false, "score": 2}, {"body": "[ANVIL](http://anvil.sourceforge.net/)\u2013 ANother Verilog Interaction Layer talks about this some.  I haven't tried it.\n", "accept": false, "score": 2}, {"body": "I use [VUnit](https://vunit.github.io/) for test driven development with VHDL.\n\nVUnit is a Python library that invokes the VHDL compiler and simulator and reads the results of the simulation. It also provides several nice VHDL libraries that makes it a lot easier to write better test benches, such as a [communication library](https://vunit.github.io/com/user_guide.html), [logging library](https://vunit.github.io/logging/user_guide.html) and a [checking library](https://vunit.github.io/check/user_guide.html).\n\nThere are many possibilities since it is invoked from Python. It is possible to both generate test data, as well as check the output data from the test in Python. I saw this example the other day where they used [Octave - a Matlab copy - for plotting test results](https://www.linkedin.com/pulse/vunit-matlab-integration-lars-asplund/).\n\nVUnit seems very active and I have several times been able to actually ask questions directly to the developers and gotten help quite quickly.\n\nA downside is that it is harder to debug compilation errors since there are so many function/procedure variations with the same name in the libraries. Also, some stuff is done behind the scene by preprocessing the code, which means that some errors might show up in unexpected places.\n", "accept": false, "score": 13}], "score": [2.9711109144002503e-232, 1.1516133654928377e-234, 58.0, 2.547757411629732e-237, 9.453018152174305e-236, 1.5519019640258361e-236, 4.385298283735036e-251, 13.0]}
{"question": "I've always kinda wanted to make my own microprocessor.. I've read [How can I make my own microcontroller?](https://stackoverflow.com/questions/632698/how-can-i-make-my-own-microcontroller) .\n\nI tried multiple times to learn some Verilog and VHDL. But for the life of me I just can not get my head around the language styles. I come from a C/C++/C# background and have dabbed some(with success) with doing functionalish programming with Ruby. \n\nCan anyone suggest a book or online resource for teaching an HDL language from scratch(so that I can unlearn my procedural way of thinking) \n\nAlso, I am having trouble getting my head around exactly how to simulate an HDL program. There is nothing like printing or stuff in hardware, so what is the best way of testing programs without an FPGA(I'm going to order one of those sometime though!). How exactly does simulating it work? \n\nBasically I'm just needing someone to help me get my head around HDLs and their simulation. \n", "answer": [{"body": "Remember, HDLs were intended to model hardware.  With hardware everything happens at once.  By hardware, I mean a collection of logic gates connected to inputs and to the outputs of other logic gates in some fashion.  This is essentially what an FPGA or an ASIC is (in an FPGA those connections are programmable).  Wiggle an input and the effects ripple through the chain of logic gates - think of every logic gate as a little processor that's constantly evaluating it's inputs.\n\nSo in an HDL the first thing you need to consider is that all assignments are happening at the same time.  The only place things happen in the \"normal\" sense (one statement following another as in a regular programming language) is inside of a process block (in VHDL, or an always block in Verilog).  But then you have to realize that all of the process blocks (or always blocks in Verilog) are also executing concurrently.\n\nHDLs are just trying to model the concurrency of hardware. \n\nAs far as books that try to teach HDLs to software developers... I don't think there are any.  Most are aimed at Hardware Engineers.\n\nYou mentioned that you've done some Ruby programming.  If you want to play with an HDL written in Ruby you can try out RHDL: [http://rhdl.rubyforge.org/](http://rhdl.rubyforge.org/)  The basic HDL concepts are there and it looks a lot like VHDL, but it's Ruby so you can experiment a bit more with the innards.  You can write models and then simulate them.  There are some examples included.\n", "accept": true, "score": 3}, {"body": "For debugging Verilog offers printf like system tasks like $display or $monitor. These are of course not synthesizable, but every simulator should understand them.\nDebugging then is on the one hand done, just like SW debugging, by printing out signal values and whatever else to the console using the already mentioned $diplay and stuff. And on the other hand by staring at signal wave forms until you find the ill spot.\nFor these things you not even need an FPGA, a good simulator is all you need. But having a FPGA to make some LEDs blink is always nice :)\n\nFor simulation you should have a look on Modelsim. If you are on windows there is a student edition available for free.\n[http://www.model.com/content/modelsim-pe-student-edition-hdl-simulation](http://www.model.com/content/modelsim-pe-student-edition-hdl-simulation)\n\nAnother option is Xilinx' ISE Web-Pack. This even works on linux and includes the complete FPGA flow.\n[http://www.xilinx.com/tools/webpack.htm](http://www.xilinx.com/tools/webpack.htm)\nBut I recommend Modelsim for simulation.\n\nSome starting points I have at hand are:\n[http://www.asic-world.com/](http://www.asic-world.com/)\n[http://www.doulos.com/knowhow/verilog_designers_guide/](http://www.doulos.com/knowhow/verilog_designers_guide/)\n", "accept": false, "score": 0}, {"body": "Debugging is done with the simulator and its waveform viewer - you can watch what all your internals are doing over time.  In addition, with Modelsim you can also do software-like breakpoints inside processes.\n\nYou can print things out with VHDL using the \"report\" statement, but you have to do your formatting in a very non-SW way:\n\n`report \"The value is not \" & integer'image(some_integer_variable);`\n\nFor somewhat easier printing, use the [textio package](http://www.stefanvhdl.com/vhdl/vhdl/txt_util.vhd).\n\nAnother tip - lots of code out there has `use ieee.std_logic_arith.all;` in it.  That library is non-standard (despite the IEEE moniker), use `ieee.numeric_std.all` instead.\n\nStart simple - create a counter which goes up by one each time the clock ticks (use the `if rising_edge(clk) then` idiom).  When the counter gets to a particular value, toggle a signal.  \n\nCreate a testbench to simulate it, which basically means just making the clk signal go '0', '1', '0', '1'.\n\nAn easy to understand way is this:\n\n```\nprocess:\nbegin\n    clk <= '0';\n    wait for 5 ns;\n    clk <= '1'; \n    wait for 5 ns;\nend process;\n```\n\n\nRun the sim, watch your counter go up, and the toggle signal toggle.  If you make your counter big enough, you can then build an FPGA and watch an LED flash on and off by wiring up that toggle signal to an LED pin.\n\nThat's the FPGA equivalent to \"Hello World\"!\n", "accept": false, "score": 2}, {"body": "My answer might be years late, but this is for future viewers who might have the same query.\n\nI also came from a C++/C# background. My answer only concerns with Verilog HDL and not VHDL though. I'm currently taking a course this term and here are the books that helped me understand Verilog better:\n\n- [Verilog HDL: Digital Design and Modeling](https://rads.stackoverflow.com/amzn/click/com/1420051547)- [Verilog HDL: A Guide to Digital Design and Synthesis](http://www.amazon.ca/Verilog-HDL-paperback-2nd-Edition/dp/0132599708:)\n\nYou can find a lot of books [here](http://www.asic-world.com/verilog/books.html) as listed in [asic-world](http://www.asic-world.com/verilog) site.\n\nAs skorgon had answered, you can use Xilinx ISE for simulation. It's the closest to Visual Studio with C++/C# as to Verilog. But for a primitive feel (no IDE), you might want to try iVerilog or [Icarus Verilog](http://iverilog.icarus.com). It is the one used in our course. Here's how to execute Verilog files using iVerilog:\n\nType your code on a text editor, save as `.vl` inside the bin folder\n    of iVerilog. On command prompt, go to the bin folder. Then type the following:\n\n```\niverilog -o <name of exe file you want for your .vl file> <your .vl file>\nvvp <name of exe file>\n```\n\n\nExample:\n\n```\niverilog -o samp sample.vl\nvvp samp\n```\n\n\nHope this helps!\n", "accept": false, "score": 0}, {"body": "Sometimes one need to print the instance name. This is useful if many instance of the same component are used in a design:\n\"... While it is simple in VERILOG (%m in the display system function), in VHDL a bit more code writing is required.\n$display(\"dbg instance name %m at %d\", $time);\nAn example how to print an instance name in systemc is also available on this site.\n\nThe importance of such debug information is when a design contains many instances of the very same component.\n\nFirst text IO library has to be called and line variable should be declared. Please refer to print example to see details.\n\nNext you have to select between two options: One is: instance name only in debug string and the other option gives more information such as entry and architecture names...\"\n[http://bknpk.ddns.net/my_web/MiscellaneousHW/vhdl_path_name_print.html](http://bknpk.ddns.net/my_web/MiscellaneousHW/vhdl_path_name_print.html)\n", "accept": false, "score": 0}, {"body": "If you are strong in C programming, you can learn any other programming language very easily. Hardware description languages are not very different. But you must know the basics of commonly used hardware components. For example, the design of a [full adder](http://www.techmasterplus.com/TMP/verilog/verilog-fulladder.php) is very simple if you know what are the inputs and outputs of the full adder. Also you must know the relationship between inputs and outputs. The [pdf](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-884-complex-digital-systems-spring-2005/lecture-notes/l02_verilog.pdf)may be useful for a beginner.\n", "accept": false, "score": 0}], "score": [6.0, 0.0, 7.404016052545713e-156, 0.0, 0.0, 0.0]}
{"question": "( insert really basic question disclaimer here )\n\nMore specifically, I have the following declaration:\n\n```\noutput reg icache_ram_rw\n```\n\n\nAnd in some point of the code I need to put the zero value in this reg. Here's what I've tried and the outcomes:\n\n```\nassign icache_ram_rw = 1'b0;\n( declarative lvalue or port sink reg icache_ram_rw must be a wire )\n\nicache_ram_rw <= 1'b0;\n( instance gate/name for type \"icache_ram_rw\" expected - <= read )\n```\n\n\nHow do I do it after all?!\n", "answer": [{"body": "The `assign` statement is used for driving `wire`s.\n\nIf you've somethings declared as a `reg`, then you have to give it values inside a procedure ( `always` or `initial` blocks ). It's best practice to only set values of `reg`s in the same `always` block. eg: \n\n```\nalways @( * ) begin // combo logic block\n   if( some_condition ) begin\n      icache_ram_rw = 1'b0;\n   end else begin\n      icache_ram_rw = something_else;\n end\n```\n\n\nThere are important differences between `reg`s and `wire`s that you should read up on.\n\nI've a feeling though that you'll need some clocked logic if you're driving RAM signals. In this case, you'll need code that looks something like this:\n\n```\n// some parameter definitions to make logic 'read' clearer.\nlocalparam READ = 1'b0; \nlocalparam WRITE = 1'b1;\n\n// standard clocked logic 'template' that synthesis tools recognise.\nalways @( posedge clk or negedge resetb )\n  if( !resetb ) begin  // asynchronous active low reset\n     icache_ram_rw <= READ;\n  end else if( some_enable_condition ) begin\n     icache_ram_rw <= WRITE;\n  end else begin\n     icache_ram_rw <= READ;\n  end\n```\n\n", "accept": true, "score": 17}, {"body": "Note that you can also assign an initial value to a reg when you declare it, like this:\n\n`output reg icache_ram_rw = 1'b0;`\n\nThis will ensure it starts with the zero value in simulation. For synthesis, your results will depend on the synthesis tool and target technology (for FPGAs, you can generally assign an initial value for hardware; for ASIC, that's not the case).\n", "accept": false, "score": 3}, {"body": "Remove \"reg\" from the output declaration and the code should work (defaults to wire output type).\n\nThere are two things that most self-taught or poorly-taught engineers find difficult to understand in Verilog: (1) blocking -vs- nonblocking assignments (see my paper on this topic: [http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf](http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf)) and (2) reg -vs- wire. Let's clear up the latter topic right now.\n\nAnything on the Left-Hand-Side (LHS) or a procedural assignment (always, initial, task, function) must be declared as a variable type (typically a reg). Everything else in the language is a net (typically a wire). No exceptions. It's really that simple. I don't know of any Verilog book that says it that simply.\n\nHow did this happen? I asked Phil Moorby, good friend and inventor of the Verilog language, \"why reg??\" Phil told me that when he invented Verilog, there were no synthesis tools and he thought everything coming out of an always block was going to be a register. He was wrong, and now we are stuck with this \"reg\" keyword. \n\nI have tried to get this changed on the Veirlog and SystemVerilog committees for more than a decade. I would like to declare everything as wire and first usage would determine if the \"wire\" behaves like a reg (first assignment from a procedural block and last assignment wins) or behaves like a wire (first assignment is from a driving source such as a module output or continuous assignment and multiple drivers are resolved as in Verilog today) and it would be illegal to make both procedural assignments and driver assignments to the same signal. Alas, I have not had enough votes on the committee to succeed in passing this proposal.\n\nThis is the mistake I make most often in my own code. Just get used to error messages like, \"illegal LHS assignment\" or \"illegal assignment to wire.\" They both mean the same thing, you forgot to declare your regs.\n\nRegards - Cliff Cummings - Verilog & SystemVerilog Guru\n", "accept": false, "score": 35}, {"body": "\n1. The issue is that the assign statement when synthesized will create the port/pin thats why its need a wire as output .\n2. The reg named icache_ram_rw created by you is now a register and is not same as pin\n3. so to assign an register you need to use a proper format of verilog\n4. verilog allows the same by using always statement , a DFF is created and the input pin of that DFF would be your icache_ram_rw , the format is already been provided by others .\n\n\n", "accept": false, "score": 1}], "score": [34.0, 3.5627204155631664e-233, 70.0, 5.5487839337538305e-233]}
{"question": "I am getting the warning that:\n\n> One or more signals are missing in the\n  sensitivity list of always block.\n\n```\nalways@(Address)begin\n  ReadData = instructMem[Address];\nend\n```\n\n\nHow do I get rid of this warning?\n", "answer": [{"body": "Add InstructMem to the sensitivity list.\n", "accept": false, "score": 1}, {"body": "Verilog does not require signal names in the sensitivity list. Use the `@*` syntax to signify that the `always` block should be triggered whenever any of its input signals change:\n\n```\nalways @* begin \n    ReadData = instructMem[Address]; \nend\n```\n\n", "accept": true, "score": 6}, {"body": "Declare `ReadData` as a wire instead of a reg and then replace your always block with an assign.\n\n```\nassign ReadData = instructMem[Address];\n```\n\n", "accept": false, "score": 1}, {"body": "I am not sure what the declaration of instructMem looks like. Anyway, ReadData = instructMem[address] is going to result in a multiplexer with address being treated as selection logic and instructMem as data lines of the multiplexer using a typical synthesis tool. You would need to put in instructMem in the sensitivity list since whenever this changes so should ReadData.\n\nI tried Icarus, and you anyway cannot do something like always @(instructMem or address) where instructMem has a declaration like reg [7:0] instructMem [255:0] --> implying memory.\n\nNote: do not try to synthesize Verilog memories this way, typically you are supposed to instantiate memory IPs and connect to their ports. Vendors provide memory models for such purposes. \n", "accept": false, "score": 0}], "score": [4.7063806102496097e-237, 12.0, 2.516118098618079e-156, 0.0]}
{"question": "In (regular) software I have worked at companies where the gcc option -Wall is used to show all warnings.  Then they need to be dealt with.  With non-trivial FPGA/ASIC design in Verilog or VHDL there are often many many warnings.  Should I worry about all of them?  Do you have any specific techniques to suggest?  My flow is mainly for FPGAs (Altera and Xilinx in particular), but I assume the same rules would apply to ASIC design, possibly more so due to the inability to change the design after it is built.\n\nUpdate 4/29/2010: I was originally thinking of synthesis and P&R (Place & Route) warnings, but the simulation warnings are valid too.\n", "answer": [{"body": "Here's what I do, for reference.  I inspect all the log files from the tool(s).\n\nFor Altera Quartus II that includes the map, fit and merge reports.  I also turn on the Design Rule Check (DRC) option and check that file.  For some messages that are easy to fix, e.g. port missing from the instantiation or incorrect constant width, I fix them.  Other ones I look into.  For ones that are in the cores, e.g. a width mismatch because I'm not using the full output deliberate, I mark them to be suppressed in the .srf file.  I only suppress the specific messages, not all of the \"similar messages\" since there may be others, either now or in the future, which are problems.\n", "accept": false, "score": 3}, {"body": "I wrote a script which applies a set of regexps to the logfile to throw away lines which I \"know are OK\".  It helps, but you have to be a bit careful with the regexps - what did jwz say about them :)\n", "accept": false, "score": 2}, {"body": "Here is my perspective from the ASIC world (99% Verilog, 1% VHDL).\n\nWe make an effort to eliminate all warnings from our log files, because in general, we interpret warnings as the tool telling us that we should not expect predictable results.\n\nSince there are many types of tools which can generate warnings (simulation/debugger/linter/synthesis/equivalence-checking, etc.), I will focus this discussion on  warnings.\n\nWe analyze warnings and categorize them into two main groups: ones which we deem will not affect the results of our simulation, and others which may affect the results.  First, we use a tool's options to explicitly enable as many warnings as possible. For the first group, we then use a tool's options to selectively disable those warning messages.  For the second group, we fix the Verilog source code to eliminate the warnings, then we promote the warnings to errors.  If any warnings are later introduced in those categories, we force ourselves to fix them before we are allowed to simulate.\n\nAn exception to the above methodology is for third-party IP, whose Verilog code we are not allowed to modify.\n\nThat method works fairly well for RTL simulations, but it gets much more difficult when we run gate simulations using back-annotated SDF.  There is simply not enough time to analyze and eliminate the literally millions of warnings.  The best we can do is to use scripts (Perl) to parse the log files and categorize the warnings.\n\nIn summary, we try our best to eliminate the warnings, but it is not always practical to do so.\n", "accept": true, "score": 10}, {"body": "The most important reason that I can think of is simulation-synthesis mismatch. Synthesis tools do a lot of optimizations (as they rightly should) and if you leave loopholes in your design you are asking for trouble. Refer to IEEE 1364.1-2002 for details about the synthesis standard.\n", "accept": false, "score": 2}, {"body": "Some warnings are expected and there is a problem if you don't get a warning. \n\nfor example if you really really want a latch but there is no warning about inferring a latch then your synthesis might not have made what you intended. \n\nso no, you don't always want to 'deal' with all warnings.\n", "accept": false, "score": 0}, {"body": "There is no need to remove all warnings, but all should be reviewed. To make this possible for big designs, some warnings can be suppressed by its type or id.\n\nFor example, some synthesis tools give a warning if a Verilog `parameter` is defined and no value assigned during the module instantiation. For me, this warning is just an advice to use `localparam`. It's a good idea to suppress it by its id (e.g. LINT-01).\n\nIn some cases, I want to see the warnings and don't suppress them. For example, my tool gives a warning whenever I define a virtual clock by constraints. The warning doesn't mean there is a problem, but I can catch a missing `source` of a clock that wasn't intended to be virtual.\n\nSometimes non-existence of warnings points out a problem. For example, if I change an application variable, there should be a warning.\n\nThere are too many cases. Sometimes the warning is unavoidable. Sometimes it's nice to have warnings to be able to review some critical stuff. If the designer knows what he/she does, there is no problem.\n", "accept": false, "score": 1}], "score": [6.0, 2.0, 20.0, 2.363543547789323e-244, 0.0, 2.83251181661611e-234]}
{"question": "I have translated the following code using ternary. However, I knew there was something wrong with it. Can someone please point me into the right direction?\n\n```\nForwardA = 0;\nForwardB = 0;\n\n//EX Hazard\nif (EXMEMRegWrite == 1) begin\n if (EXMEMrd != 0)\n    if (EXMEMrd == IDEXrs)\n        ForwardA = 2'b10;\n   if (EXMEMrd == IDEXrt && IDEXTest == 0)\n        ForwardB = 2'b10;\nend\n\n\n//MEM Hazard\n\nif (MEMWBRegWrite == 1) begin\n if (MEMWBrd != 0) begin\n    if (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrs)))\n            if (MEMWBrd == IDEXrs)\n                ForwardA = 2'b01;\n    if (IDEXTest == 0) begin\n        if (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrt)))\n            if (MEMWBrd == IDEXrt)\n                ForwardB = 2'b01;\n    end\n end\nend\n\n\n\nForwardA = (MEMWBRegWrite && MEMWBrd != 0 && (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrs))) && (MEMWBrd == IDEXrs)) ?  \n                                    2'b01 : ((EXMEMRegWrite && EXMEMrd != 0 && EXMEMrd == IDEXrs) ? 2'b10 : 0);\n\nForwardB = (IDEXTest == 0 && MEMWBRegWrite && MEMWBrd != 0 && (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrt))) && (MEMWBrd == IDEXrs)) ?  \n                                    2'b01 : ((EXMEMRegWrite && EXMEMrd != 0 && EXMEMrd == IDEXrt && IDEXTest == 0) ? 2'b10 : 0);\n```\n\n", "answer": [{"body": "Surprisingly enough, I'm going to risk downvotes and tell you that the  is to leave your code in its relatively readable state.\n\nI suspect the only thing you could do that would be worse would be to do it as a regular expression or convert it to inline assembly :-)\n\nThe fact that it's  converting easily should tell you something about the wisdom in what you're attempting.\n\n\n---\n\n\n\nBased on your comment elsewhere:\n\n> This is verilog and therefore I need to do it in ternary and can't have an if else, otherwise I would need an always block before and I don't want that... I want the remaining to be 0 if none of the conditions in the if else above is satisfied \n\nWell, if you  do it, against my advice (and I'm not alone here in offering this advice), here's the method you should use (I have no idea what an \"always block\" even is so I'm not qualified to argue the point with you).\n\nSince your current code is setting `ForwardA` and `ForwardB` to values then only changing them under certain conditions, you can transform that into a ternary by reversing the order. That's because, in your `if` version, later code takes precedence but earlier code takes precedence in the ternary.\n\nFind out under what circumstances `ForwardA` and `ForwardB` are set in reverse order and reconstruct those conditions.\n\nHere's your original code, compressed a bit. I've also changed your `2'b10` things into `2'b10'` so we still get nice formatting in the SO rendering engine - don't forget to change them back.\n\n```\nForwardA = 0;\nForwardB = 0;\nif (EXMEMRegWrite == 1) begin\n if (EXMEMrd != 0)\n    if (EXMEMrd == IDEXrs)\n        ForwardA = 2'b10';\n   if (EXMEMrd == IDEXrt && IDEXTest == 0)\n        ForwardB = 2'b10';\nend\nif (MEMWBRegWrite == 1) begin\n if (MEMWBrd != 0) begin\n    if (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrs)))\n            if (MEMWBrd == IDEXrs)\n                ForwardA = 2'b01';\n    if (IDEXTest == 0) begin\n        if (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrt)))\n            if (MEMWBrd == IDEXrt)\n                ForwardB = 2'b01';\n    end\n end\nend\n```\n\n\nYou can see B is set in three places. It's set to `2'b01` in the bottom `if`, `2'b10` in the top one and `0` at the start. Converting the conditions:\n\n```\nForwardB = ((MEMWBRegWrite == 1) &&\n            (MEMWBrd != 0) &&\n            (IDEXTest == 0) &&\n            (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrt))) &&\n            (MEMWBrd == IDEXrt))\n            ? 2'b01'\n            : ((EXMEMRegWrite == 1) &&\n               (EXMEMrd != 0) &&\n               (EXMEMrd == IDEXrt && IDEXTest == 0))\n               ? 2'b10'\n               : 0;\n```\n\n\nSimilarly for A:\n\n```\nForwardA = ((MEMWBRegWrite == 1) &&\n            (MEMWBrd != 0) &&\n            (!(EXMEMRegWrite == 1 && EXMEMrd != 0 && (EXMEMrd == IDEXrs))) &&\n            (MEMWBrd == IDEXrs))\n            ? 2'b01'\n            : ((EXMEMRegWrite == 1) &&\n               (EXMEMrd != 0) &&\n               (EXMEMrd == IDEXrs))\n               ? 2'b10'\n               : 0;\n```\n\n\nNow the theory behind that is good but I wouldn't be the least bit surprised if I'd made an error in the transcription, or if Verilog just threw its hands up in disgust, picked up its ball, and trotted off home :-)\n\nCan I at least suggest, if you must follow this path, you both:\n\n- - \n\nSeriously, you'll thank me in six months time when you're looking over this again, trying to figure out what on Earth you were thinking :-)\n", "accept": true, "score": 10}, {"body": "Well, assuming that you insist on keeping it in ternary form for whatever reason, your readability would go up considerably if you'd just format it correctly.\n\n```\nconst bool cond1 = MEMWBRegWrite && MEMWBrd != 0 &&\n                   !(EXMEMRegWrite == 1 && EXMEMrd != 0 && EXMEMrd == IDEXrs) &&\n                   MEMWBrd == IDEXrs;\nForwardA = cond1\n           ? 2'b01\n           : ((EXMEMRegWrite && EXMEMrd != 0 && EXMEMrd == IDEXrs) ? 2'b10 : 0);\n\nconst bool cond2 = IDEXTest == 0 &&\n                   MEMWBRegWrite && MEMWBrd != 0 &&\n                   !(EXMEMRegWrite == 1 && EXMEMrd != 0 && EXMEMrd == IDEXrt) &&\n                   MEMWBrd == IDEXrs;\nForwardB =  cond2\n            ? 2'b01\n            : ((EXMEMRegWrite && EXMEMrd != 0 && EXMEMrd == IDEXrt && IDEXTest == 0) ? 2'b10 : 0);\n```\n\n\nNow, that code is formatted as if it were C++ rather than whatever you're actually using, but it becomes much easier to figure out what's going on.\n\nHowever, I would point out that your if-statements can't possibly match your ternary expressions. Your if statements have no else clause, and ternary expressions  have else clauses. However, since your question doesn't even make it entirely clear whether you're trying to convert the if-statements into ternary expressions or the ternary expressions into if-statements, it's a bit hard to give you exactly what you want.\n\n: Ternary expressions  have both an if and an else clause. You  directly turn an if statement without an else clause into a ternary because you wouldn't have the else portion of the ternary. Now, you can pull some tricks in some cases if you need to, like setting a variable to itself. For instance,\n\n```\nForwardA = cond1 ? newValue : FordwardA;\n```\n\n\nYou're basically saying not to change the value in the else clause - but that's assuming that you're assigning the result to a variable. The more complicated the expression, the harder it is to pull that sort of trick, and the more convoluted the code becomes when you do. Not to mention, depending on what optimizations that the compiler does or doesn't do, it could be assigning the variable to itself, which isn't terribly efficient.\n\nGenerally-speaking, translating if-statements with no else clauses into ternary expressions is a bad idea. It can only be done by pulling tricks rather than directly saying what you mean, and it just complicates things. And this code is complicated enough as it is.\n\nI'd advise not using a ternary here unless you really need it. And if you do, at least break down the expression. Even if your ternary expression were correct, it's  harder to read than the if-statements.\n\n: If you really do need this to be a ternary expression, then I'd advise that you sit down and figure out the exact conditions under which ForwardA should be what set of values and create a ternary expression based on that rather than trying to directly convert the if-statements that you have (and the same for ForwardB). Your if-statments are not only deciding what value to assign to each variable, but which variable to assign that value to, and that complicates things considerably.\n\nIn other languages (I don't know about verilog), you can use a ternary expression for choosing which variable to assign the value to in addition to whatever you're doing on the right side of the expression, but that's getting really complicated. It might be best to create a temporary which holds the value which is to be assigned and a separate ternary to determine which variable to assign it to.\n\nNot knowing verilog, I really don't know what you can and can't do with if-statements and ternary expression, but I would think that there's got to be a better way to handle this than using a ternary. Maybe not, but what you're trying to do is very difficult and error-prone.\n", "accept": false, "score": 1}, {"body": "First  there's no point, in doing so. It doesn't compile to better code and is less readable, as you noticed in your tries to correct it. If you need it as an expression it would be better to code it as an inline function.\n", "accept": false, "score": 1}, {"body": "You don't need to do this.  Stick the code in an 'always @*' block, and declare anything you're assigning to as 'reg'.\n\n```\nreg [1:0] ForwardA;\nreg [1:0] ForwardB;\n\nalways @(*) begin\n   // Your combo logic here..\nend\n```\n\n", "accept": false, "score": 3}], "score": [20.0, 1.92413385169327e-155, 1.7313806688387382e-237, 2.601975385434426e-155]}
{"question": "Hardware design with VHDL or Verilog is more like programming nowadays. However, I see SO members are not so actively talking about VHDL/Verilog programming.\n\nIs there any forum dealing with hardware design with Verilog/VHDL/SystemVerilog or SystemC?\n", "answer": [{"body": "IRC: ##verilog, ##vhdl, ##fpga on irc.freenode.net\n\nNetnews: comp.arch.fpga ([http://groups.google.com/group/comp.arch.fpga/topics](http://groups.google.com/group/comp.arch.fpga/topics))\n", "accept": false, "score": 4}, {"body": "The [Verification Guild](http://verificationguild.com) forum deals with hardware design  with Verilog/VHDL/SystemVerilog.\n\nUpdate:\nAnother forum I discovered recently is: [edaboard.com](http://www.edaboard.com)\n", "accept": false, "score": 3}, {"body": "comp.lang.vhdl\n\n[http://groups.google.com/group/comp.lang.vhdl/](http://groups.google.com/group/comp.lang.vhdl/)\n\nI haven't actively read it in a couple years, but I recall it being a great source, with some very knowledgeable and helpful people.  Looking at it now it appears to be getting a lot of spam, which is unfortunate.\n", "accept": false, "score": 4}, {"body": "[Xilinx](http://forums.xilinx.com/) and Altera FPGA forums deal with different aspects of using Verilog/VHDL for FPGAs.\n", "accept": false, "score": 4}, {"body": "[Logic Design](http://area51.stackexchange.com/proposals/45270/logic-design) was closed because of too little attention. It's now reopened, but interest remains low.\n", "accept": true, "score": 14}, {"body": "Verilog News Group:\n[http://www.rhinocerus.net/forum/lang-verilog/](http://www.rhinocerus.net/forum/lang-verilog/)\n", "accept": false, "score": 1}, {"body": "From the [FPGA|DSP|embedded]related.com pages: [www.fpgarelated.com/](http://www.fpgarelated.com/)\n", "accept": false, "score": 1}, {"body": "Here is a summary:\n- [comp.arch.fpga](http://groups.google.com/group/comp.arch.fpga/)- [comp.lang.verilog](http://groups.google.com/group/comp.lang.verilog/)- [comp.lang.vhdl](http://groups.google.com/group/comp.lang.vhdl/)- [EDA Board](http://www.edaboard.com/)- [Altera Forum](http://www.alteraforum.com/)- [Cadence Community Forum](http://www.cadence.com/community/forums/)- [Mentor Verification Academy (SystemVerilog User's Group, OVM/UVM)](https://verificationacademy.com/forums/systemverilog/all?sort_by=created)- [Xilinx Forum](http://forums.xilinx.com/)- [Verification Guild](http://verificationguild.com/)- [EETop](http://bbs.eetop.cn/)- [Sonsivri](http://www.sonsivri.to/forum/index.php)- [LinkedIn](http://www.linkedin.com)\n", "accept": false, "score": 5}], "score": [5.117307556261402e-236, 6.6138138712768786e-236, 4.0, 6.315259229695046e-240, 28.0, 4.1239219794822026e-238, 1.0501354592844605e-237, 2.1263474745859774e-236]}
{"question": "I've asked the question before what language should I learn for embedded development. Most embedded engineers said c and c++ are a must, but also pointed out that it depends on the chip. \n\nCan someone clarify? Is it a compiler issue or what? Do chips come with their own specific compilers (like a c compiler or c++ compiler) and that's why you have to use the language the compiler knows? Is it not possible to code and compile it elsewhere, then burn it to the chip directly in its compiled state? (I think I heard an acquaintance say something to this effect)\n\nI'm not sure how this works, as clearly I don't know much embedded systems or how they work. It's probably an easy answer for those of you who know. \n", "answer": [{"body": "Yes, there are many architectures for which a C compiler exists but a C++ compiler does not.  The smaller and less fully-featured a processor you choose, the more likely this situation is to occur.\n\nFor embedded development, you almost always compile the code 'elsewhere', as you say, and then send it to the chip for execution/debugging.  The process of compiling code for a different architecture than the compiler itself is built for is called 'cross-compiling'.\n", "accept": false, "score": 3}, {"body": "Probably, they meant some toolchains do not support C++.  Yes, many chips and boards do come with their own toolchains.  Different processors have different instruction sets, which means a different compiler (or more specifically a different backend).  That doesn't mean you always have to relearn everything.  Many of these are based on GCC (often considered the most ported compiler).  The final executable/image formats also vary, so you need a specific linker.  Most likely, you will be (cross-)compiling the chip on a \"regular\" computer, then burning it to the chip. However, that doesn't mean you can use a typical compiler and linker targeted towards a desktop operating system.\n", "accept": false, "score": 6}, {"body": "You are correct: chips have variations on compilers. Most/many modern chips have a gcc port; but not all. \n", "accept": false, "score": 3}, {"body": "The term 'embedded' is used to describe a vast range of hardware. Most embedded software engineering will consist of writing C/C++ code to produce a binary for a target microprocessor, but there are devices that you may work with that are not coded with compiled binary.\n\nOne example is a Programmable Logic Controller (PLC). These devices use a language called \"[Ladder Logic](http://en.wikipedia.org/wiki/Ladder_logic)\". It's a wonderful language. I have enjoyed working with it in the past.\n\nAnother thing you may encounter, as I have in the past, is devices that have interpreted BASIC emulators. Hopefully that is rare today.\n", "accept": false, "score": 1}, {"body": "It \"depends on the chip\" in three possible ways:\n\n\n1. Some very constrained architectures are not suited to C++, or at least C++ provides constructs not suited to such architectures so offers no benefit over C. Most 8 bit devices fall into this category, but by no means all; I have seen useful C++ code implemented on MegaAVR for example.\n2. Some devices are not supported by a C++ compiler. For example Microchip's dsPIC/PIC24 compiler is C only (third-party tools may have C++ support).\n3. The chip architecture is designed specifically for a particular language; for example INMOS Transputers invariably ran OCCAM.\n\n\n\nAs well as C, C++, other possibilities are assembler, Forth, Ada, Pascal and many others, but C is almost ubiquitous; few chip vendors will release a new architecture or device without a C compiler being available from day-one.  For other languages you will generally have to wait until a third-part decides to develop one, and that wait may be forever for a niche architecture.\n\n> Is it not possible to code and compile it elsewhere, then burn it to the chip directly in its compiled state?\n\nThat is called cross-compilation or cross-development, and is the usual development method for embedded systems.  Most embedded systems lack the OS, file, performance and memory resources to self-host a compiler, and most developers want the comfort of a sophisticated development environment with IDEs, debuggers etc. in a familiar user-oriented desktop OS.\n\n> I'm not sure how this works, as\n  clearly I don't know much embedded\n  systems or how they work.\n\nGet up-to-speed with some of these:\n\n- [http://www.state-machine.com/arm/Building_bare-metal_ARM_with_GNU.pdf](http://www.state-machine.com/arm/Building_bare-metal_ARM_with_GNU.pdf)- [http://www.eetimes.com/design/embedded](http://www.eetimes.com/design/embedded)- [http://www.amazon.com/exec/obidos/ASIN/020179523X](https://rads.stackoverflow.com/amzn/click/com/020179523X)- [http://www.amazon.com/Embedded-Systems-Firmware-Demystified-CD-ROM/dp/1578200997](https://rads.stackoverflow.com/amzn/click/com/1578200997)\n", "accept": true, "score": 4}, {"body": "C/C++ are a very good choice for firmware development. So the software you make will run on a embedded CPU/Microcontroller. In order to proper programmer the device, you will need to know the language and the device architecture. \n\nThe same code probably will not work in different devices. So, you have to learn the language, and the device architecture.\n\nAnother options are FPGAs, which are not microcontroller. FPGA are devices with specialized cell capable to transform itself in any type of synchronous circuit, including microcontroller. FPGAs are programed with Hardware Description languages, like verilog and VHDL. The \"compiled\" (synthesized) version of the software are called gateware. \n\nThe HDLs are the same languages used for ASICs designe also. The path to properly learn\nthe language are long. So I recommend start with C/C++ with pic form Microchip, which is a \nlow cost and highly accepted microcontroller.\n\nIf you intend to do FPGA development, the knowledge gained with C/C++/pic will be helpfull and important, because must FPGAs have embedded CPU/Microcontroller inside.\n", "accept": false, "score": 1}, {"body": "There is no direct scientific reason for it.  In a lot of cases it has to do with the management and politics of the specific company.  \n\nSome companies are driven to create a turn key system and force you to buy that system and pay for maintenance.  It locks out the individual developers, but there are many companies and esp government agencies that prefer this model because the support is often much better and you can often drive the direction of their products to suit your needs.\n\nOther companies do not have the staff or the talent and outsource the solution and sometimes take whatever they can get.  And you might end up with a one time developed tool that after the contractor leaves is never updated or fixed again, or if it is fixed it is a patch job by someone else.  It takes money to make money, but if you run out of money before you can sell your product you still fail.\n\nSometimes you have companies that both have a staff that maintains their in-house must buy from them tool AND has individuals that also contribute to open tools like gcc.  \n\nSometimes the politics or management in the company have individuals that have a strong opinion of how the world must be and only allow tools to be developed for a specific language.  Or perhaps they are owned by or partner with or just like a company that has a specific language and this chip product came to be simply to support that language.\n\nOn top of all of this you have the very real technical problems of memory space, the quality and efficiency of the instruction set and how compiler friendly it is.  Some architectures may be fine for assembler, but higher level compiled code chews up the limited memory resources too quickly. \n\nGcc in particular has a lot of problems internally (not as a people but the software/source code itself).  I challenge you to write a back end, even with the tutorials that are out there.  A company requires specialised talent in order to create and then maintain a gcc backend year after year, otherwise you get dumped.  if your chip architecture is not 32 bit or bigger you are already fighting a losing battle with gcc, your chip architecture might be compiler friendly but just not friendly with the popular compilers design.\n\nIn the near future llvm is going to shine as a cross compiler relative to gcc because it has not yet built this internal bulk, and perhaps because the internal guts are themselves a defined language/system it may never suffer what has happened to gcc.  As more folks get comfortable with llvm we will see a number of architectures ported to it.  The msp430 backend was done specifically to demonstrate that you can add a target literally in an afternoon.  By the end of next month, some motivated individual could have all of the targets most of us have ever heard of ported to llvm.  And you dont have to build a cross compiler it is always a cross compiler.  I only mention llvm because the door is now open for targets that have suffered from bad tools to recover.\n\nSome companies, microcontrollers in particular, can and will make the programming interface proprietary so that you must use their programming tool (and or hack it and take your chances with publishing those results and or a cat and mouse of them changing it to defeat you).  And they may have only made tools for Windows leaving the linux and apple folks hanging in the wind.  Or they make it so that the only binaries it will load are the ones generated by their tools, here again you may hack through the binary format allowing an alternate compiler, and they may or may not work to defeat you.\n\nDespite the technical problems the biggest is the companies politics, management, marketing teams, and supply of or lack of talent in the engineering staff.  The bottom line, follow the dollars not the technology or science to understand why this language is supported and not that, or the support for this language is good, bad, or marginal.\n\nWhat language to learn as a result of all of this?  Start with assembler on at least three different architectures.  Then C and then C++ if you feel you really need it.  C and assembler are your primary languages for embedded (depending on your definition of embedded).  No, we write assembler mostly for initial boot code and to support C, interrupt stuff or special instructions that are needed that the compiler cannot create.  There are places like microcontrollers where it may very well make sense to use assembler for various reasons like tools, limited chip resources, etc.  Even if you dont use assembler knowing it makes you a much better high level programmer.\n\nYou do need to decide what your definition of embedded is.  Is it api and library calls for an application on a(n embedded) linux system (indistinguishable from the same program/calls on a desktop system).  Or at the other end of the spectrum are you talking a microcontroller with maybe 256 or 1024 bytes (not mega or giga, but bytes) of program space?  Or something in the middle?  The majority of the \"embedded\" folks out there are closer to the api calls for applications on an operating system (rtos, linux, wince, etc), than the deeply embedded, so that means C, maybe C++ (always be able to fall back on C), trying to avoid python and other scripty languages that are resource hogs.\n", "accept": false, "score": 1}, {"body": "Some 8-bit parts cannot efficiently access data from a stack.  Instead of using a stack to pass parameters, auto-variables and parameters are statically allocated; typically, a linker allocates the automatic variables for main() at one end of memory, and then allocate the variables for functions that are called by main and nothing else, then allocate the variables for functions that are called by those functions and nothing else, etc.  This will yield an optimal allocation fairly easily, subject to some caveats:\n\n\n1. Recursion can only be supported by adding code to explicitly copy variables onto some sort of stack arrangement; in many compilers, it's simply not supported at all.\n2. If a function looks like it \"might\" call another function, the linker will assume it can do so in all cases (e.g. it may be that when 'foo' calls 'bar', one of its parameters might always have a value such that 'bar' won't call 'boz', but the linker won't know that).\n3. Any call to a function pointer with a certain signature will be regarded as a call to all functions with the same signature whose address is taken.\n4. If the evaluation of more than one parameter to a function requires making additional function calls, additional temporary storage must generally be pessimistically allocated even if optimal placement of the parameter storage could have avoided that.\n\n\n\nThere are many types of C programs for which the above restrictions pose no problem at all, and many more for which they pose a nuisance but not a huge one (e.g. by adding dummy parameters or return values to ensure different classes of indirectly-called functions have different signatures).  Unfortunately, the code generated by an C++ to C pre-compiler will almost always involve function pointers whose call graph cannot be reasonably divined, so using C++ on such a platform is apt to be difficult if not impossible.\n", "accept": false, "score": 0}], "score": [3.8379806671960517e-236, 4.7162736454441656e-241, 8.675100565488004e-242, 5.73354533611378e-236, 8.0, 1.0, 2.0, 0.0]}
{"question": "I am a little confused about how blocking and non blocking assignments are interpreted when it comes to drawing a hardware diagram. Do we have to infer that a non blocking assignment gives us a register? Then according to this statement `c <= a+b`, c would be a register right, but not a and b? \n\n```\nmodule add (input logic clock,  \noutput logic[7:0] f);   \n\nlogic[7:0] a, b, c;  \n\nalways_ff @(posedge clock)  \nbegin   \n  a = b + c;   \n  b = c + a;   \n  c <= a + b;  \nend   \n\nassign f = c;  \n\nendmodule\n```\n\n", "answer": [{"body": "It's definitely a bit tricky to get your head around the differences between blocking and nonblocking assignments initially. But no fear - there's a handy rule of thumb:\n\n> If you want to infer combo logic with an `always` block, use blocking assignments (`=`). If you want sequential logic, use a clocked `always` block with nonblocking assignments (`<=`). And try not to mix the two.\n\nYour code above is probably not the best example. Without knowing what adder/flipflop structure you were trying to build, there's the danger of having combo feedback paths (which are bad). And since you've no input buses, you're essentially trying to construct `a`, `b` & `c` out of thin air!\n\nBut to answer your question, any variable assigned to within a clocked `always` block will infer a flipflop, unless its assigned using the blocking operator (`=`) and used as a kind of a local variable.\n\n```\nmodule add\n  (\n   input clock,\n   input [7:0] in1,\n   input [7:0] in2,\n   output logic [7:0] f1, f2, f3, f4, f5\n   );   \n\n\n   // f1 will be a flipflop\n   always_ff @(posedge clock) begin\n      f1 = in1 + in2;\n   end\n\n\n   // f2 will be a flipflop\n   always_ff @(posedge clock) begin\n      f2 <= in1 + in2;\n   end\n\n\n   // f3 will be a flipflop\n   // c1 will be a flipflop\n   logic [7:0] c1;\n   always_ff @(posedge clock) begin\n      c1 <= in1 + in2;\n      f3 <= c1 + in1;\n   end\n\n\n   // f4 will be a flipflop\n   // c2 is used only within the always block and so is treated\n   // as a tmp variable and won't be inferred as a flipflop\n   logic [7:0] c2;\n   always_ff @(posedge clock) begin\n      c2 = in1 + in2;\n      f4 = c2 + in1;\n   end\n\n\n   // c3 will be a flipflop, as it's used outside the always block\n   logic [7:0] c3;\n   always_ff @(posedge clock) begin\n      c3 = in1 + in2;\n   end\n\n   assign f5 = c3 + in1;\n\nendmodule\n```\n\n\nA big reason for following the rule of thumb and not mixing blocking and nonblocking assignments within an `always` block, is that mixing your assignments can cause serious simulation mismatches between RTL sims and gate-sims/real hardware operation. The verilog simulator treats `=` and `<=` quite differently. Blocking assignments mean 'assign the value to the variable right away this instant'. Nonblocking assignments mean 'figure out what to assign to this variable, and store it away to assign at some future time'. A good paper to read to understand this better is: Also see: [http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf](http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf)\n", "accept": true, "score": 35}, {"body": "The conventional Verilog wisdom has it all wrong. There is no problem with using blocking assignments for a  variable. However, you should never use blocking assignments for synchronous communication, as this is nondeterministic.\n\nA non-blocking assignment within a clocked always block will always infer a flip-flop, as dictated by the semantics.\n\nWhether a blocking assignment within a clocked always block infers a flip-flop or not depends entirely on how it is used. If it is  that the variable is read before being assigned, a flip-flop will be inferred. Otherwise, this is like a temporary variable and it will result in some combinatorial logic.\n", "accept": false, "score": 44}, {"body": "Just want to add to Jan Decaluwe's answer.  It seems that there is very little code in the wild that actually actually uses what Jan Decaluwe's describes, even though it is absolutely right.  Mixing blocking and non-blocking statements is now a taboo, thanks to Mr.Cummings.\n\nThe trouble is, most places avoid using blocking statements for local variables and there is very little code in the immediate search space of Google that looks gives an example of how it is done.  The only place where I have found the coding style as mentioned by Jan is [the winning code in this article](http://www.see.ed.ac.uk/~gerard/Teach/Verilog/manual/Example/lrgeEx2/cooley.html).  And this, I came across accidentally \n", "accept": false, "score": 2}, {"body": "I had a hard time over this too.\n\nBut firstly, you should understand that non-blocking or blocking is actually nothing to do with whether a latch/ff would be created! \n\nFor their difference you could understand it simply(at beginning) by this point: i. If use blocking, sentences after it could not be executed until block sentence LHS assigned value, since what changed to LHS of it could be updated and used if the variable is used. However, for non-blocking, it don't block following sentence like parallel with following sentence(actually RHS calculation should be done first, but it doesn't matter, ignore it when you confuse). The LHS don't change/updated for this time's execution (updated next time when always block trigged again). And following sentence use the old value, as it updated at the end of execution cycle.\n\n```\na = 0; b= 0;\na = 1;\nb = a;\n--> output a = 1, b = 1;\na = 0; b= 0;\na <= 1;\nb = a;\n--> output a = 1, b = 0;\n```\n\n\nOne key point is to find whether in you code (always block) there is any case variable not assigned value but could happen. If you don't pass value to it and that case occurs, then latch/ff is created to keep the value.\n\nFor example,\n\n```\nalways @(*) begin\n    if(in) out = 1;\n    else out = 0;\nend\n--> this end without latch/ff\nalways @(*) begin\n    if(in) out = 1;\nend\n--> this end with one latch/ff to keep value when in = 0, as it might happen and you didn't assign value to out as in=1 do.\n```\n\n\nFollowing could also create latch/ff:\n\n```\nalways @(*) begin\n    if(in) a = 1;\n    else b = 1;\nend\n```\n\n\n--> latch/ffs created for in=1, b no assignment, in=0 a no assignment. \n\nIn addition, when you sense posedge of clk `always @(posedge clk)`, it is bound to end with latch/ff. Because, for clk, there must exist negative edge, and you don't do anything, latch/ffs are created to keep all the old value!\n", "accept": false, "score": 2}, {"body": "please you can always interpret the verilog  in digital domain just you have to understand what will happen if the same code you wrote will be converted in gate level , i personally dont go by the rule that to use non blocking in seq or use blocking in combinational , this will limit your thinking . stick to the digital side of the code only\nhere is what will happen if your code is converted to gate level just see you want this only \n\n\n1. first the full adder wiil be made -- inputs a and b output will go to flip flop creating output a having sync with clk now since the assignment is blocking so the new a will be then applied to next full added having this new a and c as input , output of it will go to dffcsync to clk creating new b now since b = c + a; is there which is blocking statment so b is updated to this new b now its c<=a+b now what happens is a full adder is created having a and b as input which goes to dff sync to clk , now is there would be other condition like again say a=c; then a dff will be created having the old c not the new one just created by the non blocking statement and the output of this dff sync to clk goes to a and a gets updated\n\n\n\nthanks\nregards\nRahul jain\n", "accept": false, "score": 0}, {"body": "I can answer your question, but I think one paper would be best for this so I recommend you to read out this paper of Clifford Cummings. It will clear all your doubts and in addition to it will strengthen your understanding of verilog.\n\n[http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf](http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf)\n", "accept": false, "score": 0}], "score": [70.0, 9.280715198394934e-235, 4.0, 3.5999165578227145e-155, 0.0, 0.0]}
{"question": "I'm new to Verilog, and am having a lot of trouble with it. For example, I want to have an array with eight cells, each of which is 8 bits wide. The following doesn't work:\n\n```\nreg [7:0] transitionTable [0:7];\nassign transitionTable[0] = 10;\n```\n\n\nneither does just doing `transitionTable[0] = 10;` or `transitionTable[0] = 8'h10;` Any ideas?\n\n(In case it is not obvious and relevant: I want to make a finite state machine, and specify the state transitions in an array, since that seems easier than a massive case switch.)\n", "answer": [{"body": "OK, so to answer your question, let's dig a little deeper into Verilog syntax.\n\nFirst of all, to specify a range of bits, either do `[MSB:LSB]` or `[LSB:MSB]`. The standard is `MSB:LSB` but it is really up to you here, but try to be consistent.\n\nNext, in array instantiation we have:\n\n`reg WIDTH reg_name NUMBER;`\n\nwhere `WIDTH` is the \"size\" of each element and `NUMBER` is the number of elements in the array.\n\nSo, you first want to do:\n\n`reg [7:0] transitionTable [7:0];`\n\nThen, to assign particular bytes (8 bits = 1 byte), do:\n\n```\ninitial begin\n    transitionTable[0] = 8'h10;\nend\n```\n\n\nA good book to learn Verilog from is  by Pong P. Chu.\n", "accept": false, "score": 0}, {"body": "When using `assign` you should declare the array as a `wire` instead of a`reg`.\n", "accept": true, "score": 8}, {"body": "Since your goal is to design an FSM, there is no need to store the state values in an array. This is typically done using Verilog `parameter`'s, a `state` register and a `next_state` with a `case/endcase` statement.\n\nThe following paper shows a complete example: [FSM Fundamentals](http://www.sunburst-design.com/papers/CummingsICU2002_FSMFundamentals.pdf)\n", "accept": false, "score": 2}, {"body": "If this is targeted towards synthesis:\n\nA little beyond what was answered above, there are standard FSM coding styles that you should adhere to so the tools can perform better optimization. As described in the Cummings paper, one-hot is usually best for FPGA devices and in fact ISE(with default settings) will ignore your encoding and implement whatever it thinks will best utilize the resources on the device. This almost invariably results in a one-hot encoded FSM regardless of the state encoding you chose, provided it recognizes your FSM.\n", "accept": false, "score": 1}], "score": [0.0, 16.0, 6.0173769287595354e-238, 2.0]}
{"question": "VHDL and Verilog serve the same purpose, but most engineers favor one of both languages. I want to find out who favors which language.\n\nThere are dozens of myths and common wisdoms about the separation between Verilog and VHDL. (ASIC / FPGA, Europe / USA, Commercial / Defense, etc.) If you ask around, people will tell you the same thing over and over, but I want to find out if these myths are based on reality. \n\nSo my question: can anybody provide sources of  data that indicate who uses VHDL and who uses Verilog? Again, I\u2019m looking for , not for gut feelings and general indications.\n", "answer": [{"body": "VHDL and Verilog are both fairly new and fairly specialized languages. Those two characteristics make their qualitative data hard to come by. On the other hand, we can use these characteristics to our advantage. We can attempt to infer the popularity of these languages based on the number of references that are available.\n\n\n\n```\nVHDL        315\nVerilog     132\n```\n\n\n - \n[Source](http://trends.google.com/trends?q=vhdl,+verilog&date=all&geo=all&ctab=0&sort=1&sa=N)![Verilog(red) vs VHDL(blue)](https://i.stack.imgur.com/zCcqf.png)\n\nBy these numbers (and only these numbers) VHDL seems to be more widely-used than Verilog; however, there is no indication on the market share details of each.\n", "accept": true, "score": 6}, {"body": "I work for a large publicly traded hardware design company headquartered in Silicon Valley.  We used to use VHDL, but switched to verilog in 2002(ish).\n\nAround 2008, we switched to system verilog.  As I understand it, most non-military/non-gov't contracting companies use system verilog while military/gov't contracting entities use VHDL these days.. but don't quote me...\n\nIs this what you're asking for?  If so, +1 for system verilog :)\n", "accept": false, "score": 3}, {"body": "I've been an ASIC and FPGA designer/verification engineer for 17 years, and I've worked on both VHDL and verilog projects.  I've been at some huge name companies that use VHDL (Intel, Qualcomm, Lockheed, Raytheon).  However, all the IP I've ever seen is in verilog, for whatever that's worth.  Also, from my limited sample of job interviews and experience, its been pretty evenly divided between VHDL and Verilog over most of my career.\n\nMy take on it is that VHDL and Verilog were pretty even until the mid-2000's, when Verilog evolved into System Verilog, and VHDL stayed fairly static, except for minor changes.  It used to be that VHDL had more non-synthesizable language features that aided verification that old-school verilog.  With System Verilog, VHDL got leap-frogged in that area of strength, and never responded with an evolution of its own, so I'm (anecdotally) seeing a migration towards SV and away from VHDL.\n", "accept": false, "score": 3}, {"body": "At Texas Instruments, Verilog was more popular.  My experience is that designers can use whichever they prefer, usually, and most agree that Verilog is easier to use and the code is shorter (fact) than equivalent VHDL.  Just check any text book that has both, and you can see that difference in length of code.  \n", "accept": false, "score": 3}, {"body": "I don't have the numbers nor any gut feelings for that matter. I'll give you some facts regarding VHDL.\n\n[1] SystemVerilog enhances Verilog-HDL up to par with existing capabilities of VHDL (STD. 1076-2002).\n\n[2] VHDL 2008 (STD. 1076-2008): Has anyone used the latest standard. Kindly use it and then compare with Verilog (STD. 1364-2005).\n\n[3] SystemVerilog extends Verilog-HDL by adding a rich, user-defined type system, and adds strong-typing capabilities, especially in the area of user-defined types.\n... HOWEVER the strength of type-checking in VHDL still exceeds that in SystemVerilog.\n... The downside of Strong-typing is on performance; i.e. Compilation and Simulation (only when run-time checks are enabled) are slow. Slow compilation is not an issue when considering the amount of investment in the project (the reasoning at our firm).\n\nI consider VHDL as a 'safe' language and Verilog as a 'fast' language that lets you write models quickly. The company where I work prefers safety over speed; so we use VHDL predominantly in our design flows.\n\nAlso do check out the new OS-VVM (Open Source VHDL Verification Methodology) developments.\n", "accept": false, "score": 2}], "score": [12.0, 4.081411322760646e-234, 1.043271310561615e-235, 1.9356765784810724e-242, 6.8329720947041805e-233]}
{"question": "In class the professor said that students shouldn't say that they learned to program in Verilog. He said something like Verilog isn't used to program it's used to design. So how is Verilog different from other programming languages?\n", "answer": [{"body": "Verilog is a hardware definition language. Programming languages are generally understood to be languages for telling existing hardware what to do, not for reconfiguring said hardware.\n", "accept": true, "score": 14}, {"body": "It is a programming language, not to program software, but to describe hardware design - but the output is not necessarily an \"application\" as we understand it.\n\nThe language has a formal syntax.\n", "accept": false, "score": 2}, {"body": "Verilog, just like VHDL, is meant to describe hardware. Instead, programming languages such as C or C++ provide a high level description of software programs, that is, a series of instructions that a microprocessor executes. \n\nIn practice, Verilog and VHDL do not offer the same features as programming languages, even though they look very much alike. For instance, a `for` loop in C/C++ describes the  execution of a given snippet of code; instead, a `for ... generate` loop in Verilog/VHDL describes multiple  instances of a same hardware building block (say, a `AND` logic gate). To be precise, there also exists a plain `for` loop in Verilog, but again, it has to be \"synthesizable\", that is, the compiler must be able to generate logic that fits the description. \n\nTypically, a beginner in Verilog/VHDL will be tempted to \"translate\" a given function/algorithm from a C/C++ type of pseudocode directly to Verilog/VHDL: surprisingly, it might sometimes work, but it always lead to dramatically poor design. One must really be aware of these differences in order to become a good Verilog/VHDL programmer.\n", "accept": false, "score": 19}, {"body": "I don't know anything about Verilog but just did a quick googling and the wiki pages seem to do a pretty good job of explaining the differences in concept that your teacher seemed to be eluding to.  As some of the other posters here wrote I don't know that I would dismiss this as not a programming language, I think there's a high tendency for programmers to believe if it isn't somehow application programming or assembly programming then it's not really programming, but in short that's BS.  Everything above machine code is basically the same to me, if it's a file I give to a computer and it tells the computer how to do something it's programming the computer (I guess the problem is drawing a line between users and developers, we like to feel special).  Unless we plan to roll back to punch-cards sometime soon, I think anything that has a C like syntax or allows you to describe in a syntactically strict (well defined) way and modifies the behavior of the computer (what it outputs for a given input) then you've done some programming in one sense or another.\n\n[http://dictionary.reference.com/browse/programming](http://dictionary.reference.com/browse/programming)\n\nFrom the wiki page:\n\n[http://en.wikipedia.org/wiki/Dataflow_language](http://en.wikipedia.org/wiki/Dataflow_language)\n\nDataflow programming focuses on how things connect, unlike imperative programming, which focuses on how things happen. In imperative programming a program is modeled as a series of operations (thing that \"happen\"), the flow of data between these operations is of secondary concern to the behavior of the operations themselves. However, dataflow programming models programs as a series of (sometimes interdependent) connections, with the operations between these connections being of secondary importance.\n\n(I think the key here is the qualifiers of the type of programming not that one is a \"programming language\" and the other is a \"design language\", from what I understand they're both programming languages they just have distinct purposes and implementations).  When I think of design I basically think of this:\n[http://dictionary.reference.com/browse/design](http://dictionary.reference.com/browse/design)\nand that is not a program although a program may utilize designs (and probably should, generally referred to as design patterns, but not what you're doing)\n\nLinked in from: [http://en.wikipedia.org/wiki/Verilog](http://en.wikipedia.org/wiki/Verilog)\n\nTo your teachers point this language would likely be used to solve different problems from your every day Java/C program, and via a different means, however to say it is not a program seems wrong.\n", "accept": false, "score": 2}, {"body": "Verilog contains features to describe logical netlists(RTL) and features to facilitate simulation of them. Describing an RTL description as a program may convey that one who describes it as such does not throughly understand logic design or synthesis. Describing a testbench stimulus as a program would be appropriate.\n", "accept": false, "score": 1}, {"body": "verilog/vhdl is used to create and design specific application system on the chip which embedded into electronic devices.\n\nc/c++ used design softwares on the computer\n", "accept": false, "score": 1}, {"body": "Because it is an HDL, so it is to define hardware, and anything done in verilog (not really anything, but synthesizable things) will be synthesized into actual hardware. So you can't just use programming features like class and OOPS concept because it can't create any hardware.\n\nBut in C, everything will be converted into executable hex file, which will be loaded in your ram while executing the program.\n\n\n", "accept": false, "score": 2}, {"body": "I am going to tackle this question in a different way. What is a purpose of a programming language? Can the output of a program affect real world and your goals and expectation? If yes then ofcourse verilog is a programming language. Console.log has as much meaning as what it translates to in real world eg. console.log(\"you have a million unit\") has no fiat without authority. So verilog is a programming language in certain sense.\n", "accept": false, "score": 0}], "score": [28.0, 3.4627613376774764e-237, 1.1584690460621258e-232, 4.0, 1.9233901856509193e-239, 5.73354533611378e-236, 2.095023808429367e-234, 0.0]}
{"question": "The part that causes problems is `c[1] = p[0] + g[0] & c0;`. What's wrong with it?\n\n```\nmodule CLA_gen(p, g, c0, c);\ninput [3:0] p;\ninput [3:0] g;\ninput c0;\noutput reg [4:1] c;\nbegin\nc[1] = p[0] + g[0] & c0;\nend\nendmodule\n```\n\n", "answer": [{"body": "You might need to use <= instead of = .\n", "accept": false, "score": -1}, {"body": "You most likely want to change:\n\n```\nbegin\n```\n\n\nto:\n\n```\nalways @* begin\n```\n\n\nEvery `begin/end` must be part of another construct, such as `always`, `initial`, etc.\n", "accept": false, "score": 2}, {"body": "You're missing your always block and its sensitivity list.\n\n```\nalways @(*)\n  c[1] = p[0] + g[0] & c0;\n```\n\n\nIn the code you posted above, you don't necessarily need the begin/end since you only have one line.  But it doesn't not hurt to add it in there.\n", "accept": true, "score": 4}, {"body": "Remove the begin and end\ndeclare c only as an output\n\nfollow this\n\n```\nmodule CLA_gen(p, g, c0, c);\ninput [3:0] p;\ninput [3:0] g;\ninput c0;\noutput [4:1] c;\nassign c[1] = p[0] + g[0] & c0;\nendmodule\n```\n\n", "accept": false, "score": 0}], "score": [-1.5788148074237616e-240, 2.9118771861913584e-155, 8.0, 0.0]}
{"question": "I need to split a two-digit number up so that I can display them separately. The problem is that mod only works with numbers that are a power of 2. How can this be done?\n", "answer": [{"body": "From [http://www.edaboard.com/thread112872.html](http://www.edaboard.com/thread112872.html)\n\n> Many synthesis tools don't support\n  integer division/modulus/remainder\n  unless the calculation is trivial,\n  such as division by a power of two. If\n  your value isn't a power of two, then\n  you are probably out of luck.Maybe you can use another approach\n  such as building your own math module,\n  or using a math core from your\n  software's IP library.Or maybe you can approximate the\n  division by multiplying by the\n  fraction 1/K instead of dividing by K.If both operands are small, you could\n  fetch the result from a ROM lookup\n  table.\n", "accept": false, "score": 2}, {"body": "Rather confusinq question. When you say \"display\", I immediately think `$display`, hence modeling and simulation. There are no powers of 2 restrictions on modulo for modeling purposes.\n\nBut even if you mean synthesis, it is not true in general that modulo only works with powers of 2. However, doing this is probably not a very good idea, because it would be quite expensive in hardware.\n", "accept": false, "score": -1}, {"body": "A simple brute force solution would be to use an if-else block to compare your number to multiples of 10.  The largest multiple of ten that is smaller than your number is the \"tens\" digit, and the difference is the \"ones\" digit. \n\n```\nif (number >= 90) begin\n    tens <= 9;\n    ones <= number - 90;\nend else if ...\n```\n\n\nThat said, this isn't scalable, and giant if-else blocks are generally not good practice.\n", "accept": true, "score": 1}, {"body": "If this is a simple incrementing value, you should consider [Binary Coded Decimal](http://en.wikipedia.org/wiki/Binary-coded_decimal) counters. You need 4 bits per digit but it makes interfacing with 7-segment displays much easier. \n\n```\n//BCD counter - I did not test this\nreg [3:0] digit_one, digit_two;    \nalways @(posedge clk)\n  begin : led_digits\n  if(reset)\n    begin\n    digit_one <= 0;\n    digit_two <= 0;\n    end\n  else if(increment)\n    begin\n    //BCD values wrap at 9 \n    if(digit_one == 4'd9)\n      digit_one <= 0;\n    else\n      digit_one <= digit_one + 1;\n\n    //Carry when previous digit wraps\n    if(digit_one == 4'd9)\n      begin\n      if(digit_two == 4'd9)\n        digit_two <= 0;\n      else\n        digit_two <= digit_two + 1;\n      end\n    end\n  end\n```\n\n\nIf you have some arbitrary decimal value you need to display, then it gets more complicated. GuanoLoco's solution should work for a 2 digit output. A more efficient algorithm exists but the [implementation](http://edda.csie.dyu.edu.tw/course/fpga/Binary2BCD.pdf) is not as straightforward.\n", "accept": false, "score": 2}], "score": [1.2153927675182593e-232, -6.98488814306257e-235, 2.0, 3.974873281481815e-155]}
{"question": "When you declare something as input or output, how do you know if you have to also declare it as a `reg` or a `wire`?\n", "answer": [{"body": "An `output reg foo` is just shorthand for `output foo_wire; reg foo; assign foo_wire = foo`.  It's handy when you plan to register that output anyway.  I don't think `input reg` is meaningful for `module` (perhaps `task`).  `input wire` and `output wire` are the same as `input` and `output`: it's just more explicit.\n", "accept": false, "score": 26}, {"body": "`reg` and `wire` specify how the object will be assigned and are therefore only meaningful for outputs.\n\nIf you plan to assign your output in sequential code,such as within an `always` block, declare it as a `reg` (which really is a misnomer for \"variable\" in Verilog). Otherwise, it should be a `wire`, which is also the default.\n", "accept": true, "score": 45}, {"body": "The Verilog code compiler you use will dictate what you  to do. If you use illegal syntax, you will get a compile error.\n\nAn `output` must also be declared as a `reg` only if it is assigned using a \"procedural assignment\".  For example:\n\n```\noutput reg a;\nalways @* a = b;\n```\n\n\nThere is no need to declare an `output` as a `wire`.\n\nThere is no need to declare an `input` as a `wire` or `reg`.\n", "accept": false, "score": 7}, {"body": "basically reg is used to store values.For example if you want a counter(which will count and thus will have some value for each count),we will use a reg.\nOn the other hand,if we just have a plain signal with 2 values 0 and 1,we will declare it as wire.Wire can't hold values.So assigning values to wire leads to problems....\n", "accept": false, "score": 3}, {"body": "seeing it in digital circuit domain\n\n\n1. A Wire will create a wire output which can only be assigned any input by using assign statement as assign statement creates a port/pin connection and wire can be joined to the port/pin\n2. A reg will create a register(D FLIP FLOP ) which gets or recieve inputs on basis of sensitivity list either it can be clock (rising or falling ) or combinational edge .\n\n\n\nso it completely depends on your use whether you need to create a register and tick it according to sensitivity list or you want to create a port/pin assignment \n", "accept": false, "score": 5}], "score": [2.522149095281549e-244, 90.0, 7.753276238705486e-156, 3.06665417491313e-240, 2.00090003002732e-233]}
{"question": "What is the difference between:\n\n```\nif (dataoutput[7:0] == 8'bx) begin\n```\n\n\nand\n\n```\nif (dataoutput[7:0] === 8'bx) begin\n```\n\n\nAfter executing `dataoutput = 52'bx`, the second gives 1, but the first gives 0. Why? (0 or 1 is the comparison result.)\n", "answer": [{"body": "In Verilog:\n\n- - \n", "accept": false, "score": 23}, {"body": "Some data types in Verilog, such as `reg`, are 4-state.  This means that each bit can be one of 4 values: 0,1,x,z.\n\nWith the \"case equality\" operator, `===`, x's are compared, and the result is 1.\n\nWith `==`, the result of the comparison is not 0, as you stated; rather, the result is x, according to the IEEE Std (1800-2009), section 11.4.5 \"Equality operators\":\n\n> For the logical equality and logical\n  inequality operators (== and !=), if,\n  due to unknown or high-impedance bits\n  in the operands, the relation is\n  ambiguous, then the result shall be a\n  1-bit unknown value (x).\n", "accept": true, "score": 42}, {"body": "== For comparing bits (0 or 1)\n=== For comparing all 4 states (0, 1, x, z) \n\n== can be synthesized into a hardware (x-nor gate), but === can't be synthesized as x is not a valid logic level in digital, it is infact having voltages in between 0 and 1. And z is not itself any logic, it shows disconnection of the circuit.\n", "accept": false, "score": 6}, {"body": "As many already commented, in case a signal has an X, the \"normal\" comparison operator can led to unknow states/answers. Therefore, if you are comparing from a RAM that can deliver U or X states and you want to really check a match, then you should use the \"===\" and \"!==\" operators.\nSee picture from the systemverilog reference documentation.\n[](https://i.stack.imgur.com/mM7M4.png)\n", "accept": false, "score": 0}], "score": [4.143280708342567e-232, 84.0, 1.4505855189832628e-232, 0.0]}
{"question": "I work on a high-level simulator written in C++ for some hardware that is written in System Verilog.\n\nThe System Verilog code includes a number of functions that contain only logic (that is, nothing time-consuming, no flip-flops).  I want to reuse this code in my C++ simulator.\n\nIs there any way to reuse these functions in C++ (or C, which is easily linked into C++) by way of:\n\n- - - \n", "answer": [{"body": "A quick search brought [Verilog2C++](http://verilog2cpp.sourceforge.net/) and [Verilator](http://www.veripool.org/wiki/verilator). I haven't used these programs; you need to try them yourself.\n", "accept": false, "score": 2}, {"body": "If you have an underlying SV/Verilog simulator (such as free ones \u00e0 la Icarus/CVC) then you could use DPI. Else one could try Verilator - I guess it is more of Verilog/V2K than SV, maybe you can map your SV code to Verilog?\n", "accept": false, "score": 1}, {"body": "Typically this kind of integration is done in the other direction, meaning calling C/C++ routines from Verilog. Of course, that only makes sense for verification components, obviously that can't be synthesized. The most likely environment to do what you want is a SystemC/Verilog cosimulation, but that implies both the use of a Verilog simulator (which you explicitly don't want), and a C model using SystemC.\n\nSimulators seeking high performance often generate C or native code. I'm not aware of any way to extract specific functions from the generated code in VCS (the simulator I'm most familiar with), but it might be possible to do so with one of the open source simulators. Any commercial (i.e., licensed) simulator is unlikely to support generating code that you can run without a license. I'm not sure if your desire to use the Verilog functions independent of the simulator is driven by licensing, runtime overhead, tool installation burden, or something else entirely.\n\nI'm assuming you don't maintain the SystemVerilog routines, so it may not be possible to change the way they're implemented. However, if it is possible, one common strategy when functionality is needed both in C and in Verilog is to write code generators that can transform a single definition into C and Verilog implementations.\n\nAnother more esoteric possibility is SystemC synthesis. It is relatively new and I don't have experience with it, but if you have access to the tools and they work for your functions, it would allow you to reuse a C implementation for C models, hardware simulation, and synthesis.\n", "accept": true, "score": 3}, {"body": "Verilator is a great tool for your purpose. Basically Verilator can compile your design to a C++ class which is a representation of the your top-level module. Then you can simulate the design by driving and stimulating the C++ class in your custom C++ code. \n\nVerilator also support DPI interfaces, which means you can export Verilog function/task to C++ functions and import C++ function to be used in Verilog code.   \n", "accept": false, "score": 0}, {"body": "Regarding verilator and DPI you may want to take a look at how I evaluated it:\n\n\"... In order to practice cpp (c++) verification benches, with system verilog DPI, using a verilog DUT, I decided to download verilator and do some self study exercises.\n\nFirst I installed the software. This is fairly simple on a debian machine:\napt-get install verilator...\"\n[http://bknpk.ddns.net/my_web/SystemC_MyFirst/verilator_my_first.html](http://bknpk.ddns.net/my_web/SystemC_MyFirst/verilator_my_first.html)\n", "accept": false, "score": 0}], "score": [7.928805297034324e-248, 4.347495397725522e-245, 6.0, 0.0, 0.0]}
{"question": "I have a simple question regarding how to write an `always` block in a Verilog module.\nIf I have the following inputs in my Verilog module:   \n\n```\ninput        [31:0] PCplus4 ;       // Value of PC + 4\ninput        [31:0] A;          // Value A, i.e. RSbus (Use Forwarded Value)\ninput        [31:0] B;          // Value B, i.e. RTbus (Use Forwarded Value)\ninput        [31:0] IMM;            // Extended Immediate Value\ninput        [25:0] TARGET;         // Target Address for Jumps\ninput         [3:0] BR;         // Branch Selector Input\n```\n\n\nIs there any difference if I use  \n\n```\nalways @ (*)\n```\n\n\ninstead of  \n\n```\nalways @ (PCplus4  or A or B or IMM or TARGET or BR)\n```\n\n\nIs this `always @ (*)`   syntax valid for all versions of Verilog?\n", "answer": [{"body": "The `always @(*)` syntax was added to the IEEE Verilog Std in 2001.  All modern Verilog tools (simulators, synthesis, etc.) support this syntax.\n\nHere is a quote from the LRM (1800-2009):\n\n> An incomplete event_expression list of\n  an event control is a common source of\n  bugs in register transfer level (RTL)\n  simulations. The implicit\n  event_expression, @*, is a convenient\n  shorthand that eliminates these\n  problems by adding all nets and\n  variables that are read by the\n  statement (which can be a statement\n  group) of a procedural_timing_\n  control_statement to the\n  event_expression.\n\nSo, your two lines of code may be equivalent (it depends on the code in the body of your `always` block).  However, the `@*` syntax is easier to maintain.\n", "accept": true, "score": 15}, {"body": "`always @(*)` was an addition to the language in the 2001 revision of the standard. It is supported by all recent releases of quality tools. I have no concerns about using the construct in code intended for arbitrary reuse, however, there is a possibility of encountering an old tool that does not support `always @(*)`, especially when in-house utilities are involved. \n", "accept": false, "score": 3}, {"body": "It's just a shortcut for listing all of the wires that the always block depends on. Those wires are the \"sensitivity list\". One advantage of using it is that synthesized code is unlikely to care what you put in the sensitivity list (other than posedge and negedge) because the wires will be \"physically\" connected together. A simulator might rely on the list to choose which events should cause the block to execute. If you change the block and forget to update the list your simulation might diverge from the actual synthesized behavior.\n", "accept": false, "score": 0}, {"body": "Though both are equivalent, using `always@(*)` avoids having any simulation-synthesis mismatch.\nLets assume you have 15 signals in the sensitivity list as below:\n\n```\nalways@( a1 or a2 or ... or a15)\n```\n\n\nNow assume that the designer has missed having a14 in this list by mistake. The synthesis tool ignores this fact and synthesizes the code assuming all the signals on RHS within this block are in the sensitivity list. Whereas the simulation tool behaves differently since it depends on the sensitivity list.\n", "accept": false, "score": 1}, {"body": "For the 1st question....i would say that depends if in second scenario that those are the only inputs you feel can change which will cause a triggering to the output. Ideally it would be better to use * as it indicates \"for any change in inputs\", Also it is helpful in avoiding verbose code.\n\nFor the second question.....it was introduced in verilog -2001 and ever since then it has been used extensively.\n", "accept": false, "score": 0}, {"body": "`*` means all the inputs included, so it is equivalent to writing all the inputs.\nUsing the `*` symbol is also useful with always if you want your module to be combinational circuit not sequential, since there is something always changing whenever any input is changed.\n", "accept": false, "score": 0}], "score": [30.0, 1.2874990804566234e-239, 0.0, 1.4759843466997704e-156, 0.0, 0.0]}
{"question": "I will be in my final year (Electrical and Computer Engineering )the next semester and I am searching for a graduation project in embedded systems or hardware design . My professor advised me to search for a current system and try to improve it using hardware/software codesign and he gave me an example of the \"Automated License Plate Recognition system\" where I can use dedicated hardware by VHDL or verilog to make the system perform better .\n\nI have searched a bit and found some youtube videos that are showing the system working ok .\n\nSo I don't know if there is any room of improvement . How to know if certain algorithms or systems are slow and can benefit from codesign ?\n", "answer": [{"body": "I don't know what codesign is, but I did some verilog before; I think simple image (or signal) processing tasks are good candidates for such embedded systems, because many times they involve real time processing of massive loads of data (preferably SIMD operations).\n\nImage processing tasks often look easy, because our brain does mind-bogglingly complex processing for us, but actually they are very challenging. I think this challenge is what's important, not if such a system were implemented before. I would go with implementing Hough transform (first for lines and circles, than the generalized one - it's considered a slow algorithm in image processing) and do some realtime segmentation. I'm sure it will be a challenging task as it evolves.\n", "accept": false, "score": 2}, {"body": "Any project you end up doing, my suggestion would be to make a software version and a hardware version of the algorithm to do performance comparison. You can also do a comparison on development time etc. This will make your project a lot more scientific and helpful for everyone else, should you choose to publish anything. Blindly thinking hardware is faster than software is not a good idea, so profiling is important.\n", "accept": false, "score": 0}, {"body": "> How to know if certain algorithms or systems are slow and can benefit\n  from codesign ?\n\nIn many cases, this is an architectural question that is only answered with large amounts of experience or even larger amounts of system modeling and analysis. In other cases, 5 minutes on the back of an envelop could show you a specialized co-processor adds weeks of work but no performance improvement.\n\nAn example of a hard case is any modern mobile phone processor. Take a look at the TI [OMAP5430](http://focus.ti.com/en/graphics/wtbu/omap5/OMAP5430-SoC_large.gif). Notice it has a least 10 processors, of varying types(the PowerVR block alone has multiple execution units) and dozens of full-custom peripherals. Anytime you wish to offload something from the 'main' CPUs, there is a potential bus bandwidth/silicon area/time-to-market cost that has to be considered.\n\nAn easy case would be something like what your professor mentioned. A DSP/GPU/FPGA will perform image processing tasks, like 2D convolution, orders of magnitude faster than a CPU. But 'housekeeping' tasks like file-management are not something one would tackle with an FPGA. \n\nIn your case, I don't think that your professor expects you to do something 'real'. I think what he's looking for is your understanding of what CPUs/GPUs/DSPs are good at, and what custom hardware is good at. You may wish to look for an interesting niche problem, such as [those in bioinformatics](http://en.wikipedia.org/wiki/BLAST). \n", "accept": true, "score": 2}, {"body": "First thing to do when partitioning is to look at the dataflows.  Draw a block diagram of where each of the \"subalgorithms\" fits, along with the data going in and out.  Anytime you have to move large amounts of data from one domain to another, start looking to move part of the problem to the other side of the split.\n\nFor example, consider an image processing pipeline which does an edge-detect followed by a compare with threshold, then some more processing. The output of the edge-detect will be (say) 16-bit signed values, one for each pixel.  The final output is a  image (a bit set indicates where the \"significant\" edges are). \n\nOne (obviously naive, but it makes the point) implementation might be to do the edge detect in hardware, ship the edge image to software and then threshold it.  That involves shipping a whole image of 16-bit values \"across the divide\".\n\nBetter, do the threshold in hardware also.  Then you can shift 8 \"1-bit-pixels\"/byte.  (Or even run length encode it).\n\nOnce you have a sensible bandwidth partition, you have to find out if the blocks that fit in each domain are a good fit for that domain, or maybe consider a different partition.\n", "accept": false, "score": 2}, {"body": "I would add that in general, HW/SW codesign is useful when it reduces .\n\nThere are 2 major cost factors in embedded systems: \n\n- - \n\nThe higher is your production volume, the more important is the production cost, and development cost becomes less important.\n\nToday it is harder to develop hardware than software. That means that development cost of codesign-solution will be higher today. That means that it is useful mostly for high-volume production. However, you need FPGAs (or similar) to do codesign today, and they cost a lot.\n\nThat means that codesign is useful when cost of necessary FPGA will be lower than an existing solution for your type of problem (CPU, GPU, DSP, etc), assuming both solutions meet your other requirements. And that will be the case (mostly) for high-performance systems, because FPGAs are costly today.\n\n\n\nThis is a bit simplified and might become false in a decade or so. There is an ongoing research on HW/SW synthesis from high-level specifications + FPGA prices are falling. That means that in a decade or so codesign might become useful for most of embedded systems.\n", "accept": false, "score": 1}], "score": [3.846780371301839e-239, 0.0, 4.0, 1.2607741956635404e-233, 1.0]}
{"question": "This is a Verilog releated question. I am working with XILINX ISE as a dev environment.\n\nI am trying to access variables in the simulation that are automatically generated using genvar but I am receiving the following error -> HDLCompiler:71\n\nProblem Example:\n\n```\ngenvar i;\n\ngenerate\n\nfor(i=0; i < N; i=i+1)\n\nbegin:Sys_Modules\n\n  TypeXModule #(.width(10)) xmod(.dataY(dataY)));\n\nend\n\nendgenerate\n```\n\n\nWhen I ran synthesis or simulation I can see that Sys_Modules[0..N-1].xmod instances are created.\n\nWhen I try to add a line to the simulation accessing the Sys_Modules array:\n\nSys_Modules[i].xmod.dataY\n\nI get the following error:\n\nHDLCompiler:71 dataY is not declared under prefix xmod\n\nIs there any way to access automatically generated values in the simulation?\n\nThanks!\n", "answer": [{"body": "I think you're out of luck. Simulators don't seem to like out-of-module references (OOMRs) pointing into generated blocks as you've discovered.\n\nI encountered a similar problem recently when making a parameterizable testbench monitor. I'd a variable number of sub-blocks instantiated depending on a `parameter`. Within this, I needed to have a toplevel `.start()` task that called the `.start()` tasks in each of the instantiated modules. I couldn't use a `for` loop to do this because of this OOMR problem.\n\nSo I ended up having to:\n\n- `reg``.start()`- `always @``reg`- `generate``.start()`\n\nIf you really need to peek into your `generate`d modules, maybe you could try a workaround like above? For instance, have a bus at the toplevel, and use a`generate` statement to peek inside your original `generate`d instantiations to copy/assign interesting signals on to this toplevel bus.\n", "accept": false, "score": 1}, {"body": "It is legal to write a hierarchical reference to a generated instance. The functionality is described in sections 2.7.2 and 12.1.3 of the IEEE Verilog standard. However, the instance subscript must be a constant so that it can be resolved at compile time.\n", "accept": true, "score": 1}, {"body": "You cannot use cross-instance hierarchical references in synthesized Verilog.\n", "accept": false, "score": 2}, {"body": "I have found and used another solution, posting it here in case someone will find it useful. Worked for me in Vivado 2020.\nSteps:\n\n1. in tb: declare all data you need to print (declare wires) ex:for Sys_Modules[0..N-1], wanting Sys_Modules[i].xmod.dataY => tb: wire [0:N-1][`DATA_SIZE-1:0] tb_Sys_Modules_dataY;\n2. generate all connections using a generate block ex: (N should be a define/parameter) for(i = 0 ; i < N ;i = i + 1) assign tb_Sys_Modules_dataY[i] = Sys_Modules[i].xmod.dataY;\n3. $display wire from tb: ex: $display(\"%d\",tb_Sys_Modules_dataY[i]);\n\n\n", "accept": false, "score": 0}], "score": [3.1385125537969654e-235, 2.0, 5.342386985748538e-250, 0.0]}
{"question": "Which code is better in writing a RAM?\n\n\n1. assigning data_out inside always block: module memory(\n    output reg [7:0] data_out,\n    input [7:0] address,\n    input [7:0] data_in, \n    input write_enable,\n    input clk\n);\n    reg [7:0] memory [0:255];\n\n    always @(posedge clk) begin\n        if (write_enable) begin\n            memory[address] <= data_in;\n        end\n        data_out <= memory[address];\n    end\n\nendmodule\n2. assigning data_out using assign statement: module memory(\n    output [7:0] data_out,\n    input [7:0] address,\n    input [7:0] data_in, \n    input write_enable,\n    input clk\n);\n    reg [7:0] memory [0:255];\n\n    always @(posedge clk) begin\n        if (write_enable) begin\n            memory[address] <= data_in;\n        end\n    end\n\n    assign data_out = memory[address];\n\nendmodule\n\n\n\nAny recommendations?\n", "answer": [{"body": "It depends on your requirements.\n\n1. This registers your memory output. If you are synthesizing this to gates, you will have 8 more flip-flops than in case 2. That means you use a little more area. It also means your output will have less propagation delay relative to the clock than case 2. Furthermore, the output data will not be available until the next clock cycle.\n2. Your output data will be available within the same clock cycle as it was written, albeit with longer propagation delay relative to the clock.\n\n\nYou need to decide which to use based on your requirements.\nA third option is to use a generated RAM, which is a hard macro.  This should have area, power and possibly timing advantages over both case 1 and 2.\n", "accept": true, "score": 13}, {"body": "to add to toolic's answer - if you use the asynchronous read method (case 2), it won't map to a RAM block in an FPGA, as the RAM blocks in all the major architectures I'm aware of have a synchronous read.\n", "accept": false, "score": 9}, {"body": "In the second program, there would be compilation error as we can not 'Assign' a value to 'Reg'.\nIt will give an error saying: ''\n", "accept": false, "score": -2}, {"body": "Both forms are valid, depending on the type of pipelining you want.  I always recommend following the Xilinx RAM coding guidelines -- it's a good way to ensure that the code synthesizes into proper FGPA constructs.  \n\nFor example, your example 1 would synthesize into into Xilinx BRAM (i.e., dedicated Block Ram), since it is synchronous read, and your example 2 would synthesize into Xilinx Distributed Ram (since it is asynchronous read).  \n\nSee the coding guidelines in Xilinx document UG901 (Vivado Design Suite User Guide), in the RAM HDL Coding Techniques section.  It also has a good description of the difference between synchronous read and asynchronous read for RAMs.\n", "accept": false, "score": 1}], "score": [26.0, 18.0, -7.521060160887418e-241, 3.586161147176098e-235]}
{"question": "I am new to Verilog, so this question might be quite dumb.\n\nWhat I am trying: I have a component that has a clk, an 8 bit input and an 8 bit output. What it should do, is:\n\nIf the clock event is negative edge, it should set the output to 0\nIf the clock event is positive edge, it should set the output to whatever input is at this moment of the edge event. During the high phase of the clock, the output should NOT change, regardless changes on the input.\n\nWhat I tried so far:\n\n```\nalways @(negedge clk)\n    _ledOut <= 0;\n\nalways @(posedge clk)\n    _ledOut[RowSize-1:0] <= ledIn[RowSize-1:0];\n```\n\n\nThis tells my, that it can't resolve multiple constant drivers for net _ledOut.\n\nHowever, putting this together in an always @(negedge clk, posedge clk) tells me, it can't test for both conditions.\n\nSo I tried to make just one always @(clk) block and then used an if statement:\n\n```\nalways @(clk) begin\n    if(clk == 0)\n        _ledOut <= 0;\n    else if(clk == 1)\n        _ledOut[RowSize-1:0] <= ledIn[RowSize-1:0];\nend\n```\n\n\nBut this didn't just switch on a clk event. During the high phase of the clock, it links _ledOut with ledIn, so that changes on ledIn do also have effect on _ledOut. What am I doing wrong here?\n\nBest regards,\nMichael\n", "answer": [{"body": "Consider the following stimulus:\n\n```\nmodule tb;\n\nparameter RowSize = 8;\nreg clk;\nreg [7:0] ledIn, _ledOut;\n\nalways @(clk) begin\n    if(clk == 0)\n        _ledOut <= 0;\n    else if(clk == 1)\n        _ledOut[RowSize-1:0] <= ledIn[RowSize-1:0];\nend\n\ninitial begin\n    $monitor($time, \" clk=%b ledIn=%h _ledOut=%h\", clk, ledIn, _ledOut);\n    ledIn = 0;\n    #22 ledIn = 8'h55;\n    #20 $finish;\nend\n\nalways begin\n    #5 clk <= 0;\n    #5 clk <= 1;\nend\n\nendmodule\n```\n\n\nIt produces this output:\n\n```\n0 clk=x ledIn=00 _ledOut=xx\n               5 clk=0 ledIn=00 _ledOut=00\n              10 clk=1 ledIn=00 _ledOut=00\n              15 clk=0 ledIn=00 _ledOut=00\n              20 clk=1 ledIn=00 _ledOut=00\n              22 clk=1 ledIn=55 _ledOut=00\n              25 clk=0 ledIn=55 _ledOut=00\n              30 clk=1 ledIn=55 _ledOut=55\n              35 clk=0 ledIn=55 _ledOut=00\n              40 clk=1 ledIn=55 _ledOut=55\n```\n\n\nNotice at time 22, when `ledIn` changes, the `_ledOut` output does not change.  `_ledOut` only changes at the next posedge of `clk` at time 30.  Therefore, the `always @(clk)` solution is doing what you want: the output only changes at the clock edge, as you specified.\n", "accept": false, "score": 1}, {"body": "> This tells my, that it can't resolve multiple constant drivers for net\n  _ledOut.\n\nFor synthesis you cannot assign reg types from multiple always blocks.\n\n> However, putting this together in an always @(negedge clk, posedge\n  clk) tells me, it can't test for both conditions.\n\nThis essentially describes a DDR register. While many FPGA devices have these they typically cannot be synthesized. Xilinx uses ODDR2 and IDDR2 primitives if you really need this functionality.\n\n> If the clock event is negative edge, it should set the output to 0 If\n  the clock event is positive edge, it should set the output to whatever\n  input is at this moment of the edge event. During the high phase of\n  the clock, the output should NOT change, regardless changes on the\n  input.\n\nIf this is all you need then you can use a D flip flop with an AND gate on the output. The flip-flop will sample ledIn on each rising edge of clk and the AND gate will mask the output whenever the clock is zero. This is not ideal as you generally do not want clocks to touch non-sequential logic but avoiding this would likely mean changing your requirements.\n\nAs toolic indicated, the code you posted will work but you should understand that code will synthesize to a multiplexer controlled by clk. \n", "accept": true, "score": 5}, {"body": "Ok, here is my working solution now. Maybe it's not the best verilog code you have seen out there. ;) This is, however, my first thing I do with it, as a project at my university. So as long as it does what I want it to do, this is a great success to me! ;)\n\nHere is the code I used now, thanks to Adam12:\n\n```\nparameter RowSize = 8;\n\ninput clk;\ninput [RowSize-1:0] ledIn;\noutput [RowSize-1:0] ledOut;\n\nreg[RowSize-1:0] _ledOut;\nassign ledOut = _ledOut & {RowSize{clk}};\n\nalways @(posedge clk) begin\n    _ledOut[RowSize-1:0] <= ledIn[RowSize-1:0];\nend\n```\n\n", "accept": false, "score": 1}, {"body": "This is a pretty unusual question, and it makes me advise you need to give more information about what you are actually trying to achieve, since it may well impact the timing performance and clock constraints if this is targeting an FPGA. Synthesis has been mentioned, but what will you be feeding the clock-gated output into? If it's a pin-pad, then you should read the DDR pad buffers in the device specifications and infer the specific primitive to be able to drive a DDR signal.\n\nIf you are keeping this signal within the chip then this is a very bizarre request. If I needed to generate that waveform, I would probably use a PLL to generate a phase-locked clock at twice the base frequency and put the gated data into that domain, with a toggle to apply the mast, so that the tooling will be able to properly analyse the clock crossings and the resulting data path is still effectively transitioning on a single edge. \n\nThe answers above to infer a register with a combinatorial multiplexer forced on the output is interesting, but whatever you feed this into will have to deal with awkward setup/hold conditions, and if on-chip, would only be sampling one edge anyway, so this is kind of redundant. \n", "accept": false, "score": 0}], "score": [0.03538197127075358, 10.0, 2.0, 0.0]}
{"question": "I'm trying to learn Verilog using Pong P. Chu's book.  I have a question about how an always block is evaluated and implemented.  A style in the authors code is confusing me.  \n\nIn this example he codes an FSM with two output registers 'y1' and 'y2'. The part I'm confused about is in the NEXT STATE LOGIC AND OUTPUT LOGIC always block, where after the begin statement and `always@*` y1 and y0 are set to 0.  I seems that regardless of state, y1 and y0 will toggle to 0 on every clock cycle and signal change.  According to state diagram in the book reg y1 should be equal to 1 while in state 0 or 1.  \n\nSo does y1 toggle to 0 every clock cycle then back to what ever its value at the present state??  I assume that's not the case and that I'm just confused about how the block is evaluated. Can someone explain what that part of the code is doing.  I'm lost. Thanks\n\n```\nmodule fsm_eg_2_seg\n    (\n     input wire clk, reset, a, b,\n     output reg y0, y1\n    );\n\n    //STATE DECLARATION\n    localparam [1:0]    s0 =2'b00, \n                    s1=2'b01, \n                    s2=2'b10;\n\n    // SIGNAL DECLARATION\n    reg [1:0] state_reg, state_next ;\n\n    //STATE REGISTER\n    always @(posedge clk, posedge reset)\n        if (reset)\n            state_reg <= s0;\n        else\n            state_reg <= state_next;\n\n    //NEXT STATE LOGIC AND OUTPUT LOGIC\n    always @*\n    begin\n        state_next = state_reg; // default next state: the same\n        y1 = 1'b0;              // default output:  0\n        y0 = 1'b0;              // default output:  0\n        case (state_reg)\n            s0:  begin\n                y1 = 1'b1;\n                if (a)\n                    if(b)\n                        begin\n                            state_next = s2;\n                            y0 = 1'b1;\n                        end\n                    else\n                        state_next = s1;\n                end\n            s1:  begin\n                    y1 = 1'b1;\n                    if (a) \n                        state_next = s0;\n                    end\n            s2: state_next = s0;\n            default: state_next = s0;\n        endcase\n    end\nendmodule\n```\n\n", "answer": [{"body": "This is a poor example of an FSM. I'm not surprised that you are confused. The way I understand it, an `always` block is scheduled to run only when the inputs in its sensitivity list change.\n\nSo for the first `always` block, it is scheduled to run every clock transition from 0 to 1, and reset is asynchronous.\n\nThe second always block has the `@*` notation, which basically creates a sensitivity list for you based on the logic within the block. Recall that only  matter in a sensitivity list. Therefore, this always block will be scheduled if `a`, `b`, or `state_reg` change.\n\nIn this example, the \n\n```\ny1 = 1'b0;              // default output:  0\n    y0 = 1'b0;              // default output:  0\n```\n\n\nis trying to model an  state, a state where the FSM is outputting 0. If you do a quick study of how the FSM operates, you'll see that once it starts transitioning through the states, (the case statements) it won't come back out.\n\nIdeally you want your  information within a state of its own, not floating outside the state logic, but I suppose this works as a trivial example.\n", "accept": false, "score": 1}, {"body": "Have to say I disagree with aqua. What he (and wisemonkey) says about `@*` is right, but the rest is wrong.\n\nThose two lines have nothing to do with an idle state. Those statements are there as good coding practise. They ensure that those two outputs are always assigned to when that always block is evaluated. Let's see why this is important:\n\n- - `state_reg = S0``a = b = 0`- `y1`- `a`\n\nAt the end of the block `y1 == 1` and `y0 == ...` erm, hang on what does `y0` get? I guess it has to keep it's old value. It didn't get a new one. \n\nThat means it's possible `y0` has to remember it's value from one cycle to the next. That would mean it needs to have some kind of memory involved, like a register or a latch. In this case it would be a latch as it's written in a style that sometimes drives the output and sometimes holds it.\n\n...but we don't want that. `y1` and `y0` were meant to be simple wires. Therefore we must make sure each of them are always assigned to, no matter what the state or inputs are. We could do that by having assignments in all the branches of the logic, but that becomes a lot of work. Alternatively we can have a default assignment which we later override if necessary. \n\nThe reason these statements don't introduce `y1` going to `0` in `s0` or `s1` is because everything that happens inside an always block happens with no time passing. No time passes between the `0` being assigned at the top and the `1` in `s0` or `s1`. All that's visible is the final state.\n\nYou'll note the code does exactly the same thing with the state variable. It has a default assignment that the next state is the current state, and then overrides that it the correct conditions are met.\n\nNice clean state machine. Nothing wrong with it.\n", "accept": false, "score": 4}, {"body": "The expression\n\n```\nalways @* begin : name_of_my_combinational_logic_block\n    // code\nend\n```\n\n\ndescribes combinational logic. Typically the clk and rst signals are not read from inside of this type of always block, so they don't appear in the sensitivity list like wisemonkey says. It is best practice to use @* for the sensitivity lists of combinational logic so that you don't forget to include a signal, which would infer some memory and it would no longer be combinational logic.\n\nInside a combinational logic block, you should use what are called . These look like regular variable assignments in most programming languages and use a single equals. The value that you assign to a variable (a reg) inside of a combinational logic block happens  with respect to other statements and expressions in that same combinational logic block, but does not propagate outside of this combinational logic block until you reach the end. The always block must reach the end before any changes are seen outside of the block. Paul S is right that you want to always assign  to your variables whenever the always block is executed, otherwise you will infer memory.\n", "accept": true, "score": 4}, {"body": "I don't think other answers directly and correctly addresses the question of whether y0 and y1 toggle to 0 and back on every clock cycle.   \n\nLet's say that the state machine changes from s0 to s1.  In both states the end value of y1 is 1  but in re-evaluating the always block y1 is first assigned 0.  This toggling may happen multiple times per clock, or not at all on a clock cycle depending how many times a, b, and state_reg change.  Whether this toggling propagates to the wire attached to output y1 is simulator dependent.  Port assignments are treated as continuous assignments in Verilog, which are separately running threads of execution.  It is perfectly legal for the simulator to suspend execution of the always block after the y1=0 assignment is made, assign 0 to the wire attached to output y1, and resume execution of the always block afterwards.  Practically speaking, it doesn't matter IF good coding styles are practiced because the value of y1 won't get latched into any registers until the next clock cycle, long after all the toggling is done and the final value of y1 is available.  \n\nIn simulation the toggling happens in zero time but it also happens in real hardware when multiple inputs change.  It takes special design practices to build logic that doesn't \"glitch\" like this.  \n", "accept": false, "score": 1}], "score": [9.521738791057664e-233, 2.971166769960791e-232, 8.0, 2.0]}
{"question": "I've run this code to the lint checker (spyglass):\n\n```\n1 module test(\n     2         output  [7:0] O_O,\n     3         input   [7:0] I_1,\n     4         input   [7:0] I_2\n     5 );\n     6\n     7         wire    [14:0] result;\n     8\n     9         assign result = (I_1 + I_2) << 5;\n    10         assign O_O = result[7:0];\n    11 endmodule\n```\n\n\nI get this warning message:\n\n```\nBit-width mismatch in signal assignment (LHS: 'O_O' width 8 should match RHS: '((I_1 + I_2) << 5)' width 14). [Hierarchy:test]\n```\n\n\nTo avoid this warning, I changed my code like this:\n\n```\n1 module test(\n     2         output  [7:0] O_O,\n     3         input   [7:0] I_1,\n     4         input   [7:0] I_2\n     5 );\n     6         wire    [15:0] result;\n     7\n     8         assign result = (I_1 + I_2) << 5;\n     9         assign O_O = result[7:0];\n    10 endmodule\n```\n\n\nThen got this warning message\n\n```\nPort 'O_O[4:0]' is 'tied-low'\n```\n\n\nAny recommendations to fix those warnings?\n", "answer": [{"body": "There must be a way to tell your lint checker that you intend those bits to be always zeros.  You'll have to read the docs to find out how though - maybe a special comment you can add int he source, or a separate config file to say \"expect this warning on this line of code\"\n", "accept": false, "score": 1}, {"body": "Does this work?\n\n```\n1 module test(\n 2         output  [7:0] O_O,\n 3         input   [7:0] I_1,\n 4         input   [7:0] I_2\n 5 );\n 6\n 7         wire    [14:0] result = (I_1 + I_2) << 5;\n 8\n 9         assign O_O = result[7:0];\n10 endmodule\n```\n\n", "accept": true, "score": 1}, {"body": "You can create a waiver file to waive all such warnings in spyglass.\n", "accept": false, "score": 0}, {"body": "In warning window there is option for shifting this warning to waiver file, i,e \n\n```\n.awl\n.swl\n```\n\n\nwhich will show intentionally added stuff and need to ignored, doesn't reflected in warning window any more. \n", "accept": false, "score": 0}], "score": [3.5228120082517626e-241, 2.0, 0.0, 0.0]}
{"question": "I understand that you can declare a string in a Verilog test bench as follows:\n\n```\nreg [8*14:1] string_value;  \n\ninitial \n    string_value = \"Hello, World!\";\n```\n\n\nI can then do things with this string, like use `$display` in a test bench to display it.\n\nI haven't been successful in doing the same in a module when I flash it to my FPGA: \n\n```\nreg [8*14:1] string_value;  \n\nalways @(reset) \nbegin\n    string_value = \"Hello, World!\";\n    // Do stuff with string value\n```\n\n\nEven assigning a single value does not work:\n\n```\nreg [8:1] char_value;  \n\nalways @(reset) \nbegin\n    char_value = \"A\";\n    if (char_value == 8'h41)\n        // Do stuff!\n```\n\n\nI want to shift the individual characters on an 8-bit bus to an LCD screen for display.\n\nHow can I work with strings in Verilog?\n", "answer": [{"body": "Strings seem to work in a module for me:\n\n```\nmodule tb;\n\nreg [8:1] char_value;\n\ninitial begin\n    char_value = \"A\";\n    $display(\"%h\", char_value);\n    if (char_value == 8'h41) begin\n        $display(\"match\");\n    end else begin\n        $display(\"no match\");\n    end\nend\n\nendmodule\n\n/*\n\nPrints out:\n\n41\nmatch\n\n*/\n```\n\n\nWhat doesn't work for you?\n\nThe `string` data type was introduced into the SystemVerilog standard in 2005 (refer to IEEE 1800-2005 or 1800-2009).\n", "accept": false, "score": 0}, {"body": "SystemVerilog should support string assignment as mentioned in spec:\n\n```\nFor example, to store the 12-character string \"Hello world\\n\" requires a variable 8x12, or 96 bits wide. \n     bit [8*12:1] stringvar = \"Hello world\\n\";\n```\n\n\nNot sure if the old verilog supports it or not.\n", "accept": true, "score": -3}, {"body": "You can assign a string to a register type. Anyone who says otherwise is wrong. You might want to make your registers 0' based for it to work properly. I've done this in real FPGAs and it works.\n", "accept": false, "score": 9}, {"body": "This works for me:\n\n```\nreg [8*16:1] line1data = \"Hello, World!   \";\n```\n\n\nBoth in simulation and on a Spartan-3E FPGA\n", "accept": false, "score": 3}, {"body": "```\noutput [8*14:1]string_value1;  \nreg [8*14:1]string_value1;\n\nalways @ (posedge BIWEn)\n\nif (BIWEn==1'b1 ||BIREn==1'b1)\n    begin:START_STATE_WRITE\n        psW=idleW;  //psW is Present State Write\n        string_value1= \"IDLE\";\n    end\n\n![test bench] (c:\\pictures)\n```\n\n", "accept": false, "score": 0}, {"body": "Define an array of bytes, then assign ASCII to each array element: \n\n```\nwire [7:0] foo [0:11];\nassign foo[0]  = \"H\";\nassign foo[1]  = \"e\";\nassign foo[2]  = \"l\";\nassign foo[3]  = \"l\";\nassign foo[4]  = \"o\";\nassign foo[5]  = \" \";\nassign foo[6]  = \"W\";\nassign foo[7]  = \"o\";\nassign foo[8]  = \"r\";\nassign foo[9]  = \"l\";\nassign foo[10] = \"d\";\nassign foo[11] = \"!\";\n```\n\n\nYou now have a constant with ASCII values in it that you can index into. \n\n```\nreg [7:0] data_out;\nreg       data_out_valid;\nreg [3:0] some_index;\n:\n// pushing data onto a bus\ndata_out       <= foo[some_index];\ndata_out_valid <= 1'd1;\nsome_index     <= some_index + 4'd1;\n```\n\n\nWith appropriate index checking and control that should work.\n", "accept": false, "score": 7}], "score": [0.0, 2.0, 6.706088116426682e-259, 1.4386794327626026e-159, 0.0, 1.4298600655911155e-155]}
{"question": "I am developing a  monitor that extends  and I'd like to know how to import the ovm macros that I am using. I am using:\n\n```\n`ovm_component_utils_begin\n`ovm_field_string\n`ovm_component_utils_end\n```\n\n\nI tried the following at the top of my file, both of which do not compile:\n\n```\nimport ovm_pkg::ovm_monitor;\nimport ovm_pkg::ovm_macros;\n```\n\n\nand\n\n```\nimport ovm_pkg::ovm_monitor;\n`include \"ovm_macros.svh\"\n```\n\n\nVCS compile error:\n\n```\nError-[SE] Syntax error\n  Following verilog source has syntax error :\n  \"my_monitor.svh\", 58 (expanding macro): token is '#'\n  `ovm_component_utils_begin(my_monitor)\n                                        ^\n```\n\n\nThe following works, but I consider it bad practice to use * in the import statement:\n\n```\nimport ovm_pkg::*\n```\n\n", "answer": [{"body": "Unfortunately, there isn't a lot of choice about doing import ovm_pkg::*.  The OVM doesn't fully qualify all of its names with the package name internally so it is almost impossible to get code to compile without it.  \n", "accept": false, "score": 0}, {"body": "It looks like there's a missing class definition for ovm_component_registry, among other things. I'm not a real user of OVM but it's  use of nested includes and macros means you'll likely need to look at the preprocessed output.\n\n```\nclass top extends blah;\n\n\n\n   typedef ovm_component_registry #(top,\"top\") type_id; \n           ^\n   static function type_id get_type(); \n     return type_id::get(); \n   endfunction  \n\n   const static string type_name = \"top\"; \n   virtual function string get_type_name (); \n     return type_name; \n   endfunction  \n\n   static bit m_fields_checked = 0; \n   function void m_field_automation (ovm_object tmp_data__=null, \n                                     int what__=0, \n                                     string str__=\"\"); \n   begin \n     top local_data__; /* Used for copy and compare */ \n     string string_aa_key; /* Used for associative array lookups */ \n     /* Check the fields if not already checked */ \n     if(what__ == OVM_CHECK_FIELDS) begin \n       if(! top::m_fields_checked) \n         top::m_fields_checked=1; \n       else \n         return; \n     end \n     /* Type is verified by ovm_object::compare() */ \n     super.m_field_automation(tmp_data__, what__, str__); \n     if(tmp_data__ != null) \n       /* Allow objects in same hierarchy to be copied/compared */ \n       if(!$cast(local_data__, tmp_data__)) return; \n     if(what__ == OVM_CHECK_FIELDS) begin \n       m_field_array.delete(); \n     end \n\n     end \n   endfunction(top)\n\n\nendclass\n```\n\n", "accept": false, "score": 1}, {"body": "Importing with * is actually the best practice. \n\nImporting with * makes all package contents visible but does not do the actual import until used. Importing a function by name immediately imports the function whether used or not (that is the inferior practice). \n\nUsers of OVM or UVM are instructed to never define any user-defined classes or macros using the \"ovm_\" prefix since future versions of OVM may add more ovm_classes or `ovm_macros, so importing OVM packages with * is safe. \n\nIf you were to import two packages with * and if both packages had the same function name defined, if your code does not use the function, there is no problem. If your code does require the function, prefix the function with pkg2::function_name, which again is the best practice. \n\nRegards - Cliff Cummings - Verilog & SystemVerilog Guru\n", "accept": true, "score": 3}, {"body": "This should be a comment on Adam12's response but I can't add comments.\n\n@Victor Lyuboslavsky, If you don't want to use `import ovm_pkg::*`, you will have to look at the macro expansion, or the expanded code produced by the macro, and `import` the necessary identifiers, e.g. `ovm_component_registry`, `ovm_object`, `OVM_CHECK_FIELDS` (based on Adam12's answer).\n\nHowever in future the `ovm_component_utils_*` or `ovm_field_*` macros could change to include more OVM identifiers and you would have to modify the code then to `import` these additional identifiers.\n", "accept": false, "score": 1}], "score": [0.0, 2.0336149633708555e-155, 6.0, 2.0]}
{"question": "I would like to delete an ovm object (and its children) so that I can recreate it with different configs. Is there a way to do this in OVM?\n\nCurrently, when I try to create the object a second time with `new`, I get the following VCS runtime error:\n\n`[CLDEXT] Cannot set 'ap' as a child of 'instance', which already has a child by that name.`\n\nI realize that I can simply use a different name to \"re-create\" the instance, but then I'll still have the old instance sitting around and soaking up memory.\n", "answer": [{"body": "Try assigning null to the object before calling new again.\n", "accept": false, "score": 0}, {"body": "Unless I see someone else answer this question, I'd say there is no easy way to deallocate objects in OVM framework.\n", "accept": false, "score": 0}, {"body": "OVM is just a SystemVerilog library.  That means that all the rules of SystemVerilog apply to OVM.  So, yes, you can use new() with OVM.  Sometimes it's preferable to use the factory, and sometimes it's preferable to use new() (that's a topic for a different discussion). \n\nSystemVerilog does not have a delete operator or a destructor like C++.  Instead, when you are done with an object you just remove all references to it and the garbage collector will clean up the memory.  Here's a quote from the SystemVerilog reference manual (IEEE 1800-2009) section 8.7:\n\n> \n\nIt's not entirely true that you cannot have a memory leak.  You can forget to remove all references to an object and the garbage collector will not know to pick it up.  However, you do not have to worry about memory with the same detail as you do in C++.\n\nThe particular error you received with id CLDEXT is from ovm_component class. From the message it appears that you attempted to create two components with the same name and the same parent.  Components in OVM are typically static.  That is, you create and elaborate them once, usually at time 0, and don't delete or add components after that.  Because of this model there are no methods in ovm_component to remove child components.  So there really isn't a good way to replace a component once it has been instantiated. By the way, this only applies to components.  Other types of objects can be re-allocated.\n\nIf you feel that you need to replace a component with a different one after time 0 you should re-think the architecture of your testbench.  There are probably betters ways to accomplish what you are trying to do without replacing components.\n", "accept": true, "score": 3}, {"body": "OVM testbenches are static and created when the testbench is created.\n\nWhen the environment class is instantiated, it will call new(create), build, connect, end_of_elaboration, start_of_simulation, run and check on all components.\n\nBy the end of the environment build phase all components must be created.\n\nBy the end of the environment connect phase all components must have their TLM ports connected.\n\nBecause of these requirements, you can not change components (or port connections) except for during the phase.\n\nAs part of the static nature of the testbench environment, every component must have a unique get_full_name() response. This is because string lookups are used to identify components in the hierarchy.\n", "accept": false, "score": 0}, {"body": "I have only UVM experience but I think OVM is similar. I would have liked to reply to @Victor Lyuboslavsky's comment but I can't add comments.\n\nThe issue is with the name 'ap' which evidently has already been used for a child of 'instance'. Use this code instead.\n\n```\nstatic int instNum = 0;\ninstance_ap = my_ovm_extended_class::type_id::create\n                ($sformatf (\"ap%0d\", instNum), this);\n```\n\n\nThe first time an object is created & the handle assigned to 'instance_ap', the object would have the name 'instance.ap0'. The next time the code executes an object called 'instance.ap1', and so on.\n\nAs mentioned by other posters this ought to be done only for non-component objects, and components should be static and must be created during/before the build phase & connected to each other during/before the connect phase.\n", "accept": false, "score": 2}, {"body": "Assigning an object to null should deallocate memory. If there is no other handle pointing to that memory location, then it should get reclaimed.\n", "accept": false, "score": 0}], "score": [0.0, 0.0, 6.0, 0.0, 4.579006609049762e-156, 0.0]}
{"question": "[This Verilog tutorial](http://www.asic-world.com/verilog/verilog_one_day1.html#Introduction) (see the table at the end) suggests that `{ }` is a concatenation operator is C. I don't remember curly brackets as being an  in C.\n\nIs `{ }` a concatenation operator in C?\n", "answer": [{"body": "No, that's just nonsense. No idea what that's about.\n", "accept": true, "score": 6}, {"body": "No, in pure C, the braces are not a concatenation operator.\n\nNote that the table of operators on the Verilog page includes a number of other 'non-C, non-C++' operators:\n\n```\n~&    nand\n|     or\n~|    nor\n^     xor\n^~    xnor\n~^    xnor\n```\n\n\nWhere the operators are the same as in C, they have the same meaning as in C.  But there are operators in Verilog that are not in C (and, if that table is complete, operators in C that are not in Verilog).\n", "accept": false, "score": 1}, {"body": "Absolutely not. The curly braces in C as C++, C# and others delimit a block of code. It's an error on their site. There is neither the possibility of operator overloading since we talk of 'pure, old fashioned C programming language'\n", "accept": false, "score": 2}, {"body": "Depends. Curly brackets are not an operator by definition in C, and they do not concatenate strings. But they group statements and introduce new blocks. Maybe this is what the author meant. But however, it is at least inaccurate if not wrong.\n", "accept": false, "score": 0}, {"body": "The only operator C has with `{ }` is the `( ){ }` operator which is the compound literal operator.\n", "accept": false, "score": 1}, {"body": "From the linked tutorial:\n\n> To make life easier for us,  operators (at least the ones in the list below) are exactly the same as their counterparts in the C programming language.\n\nEmphasis mine.  The exceptions are `~&`, `~|`, `~^`, `^~`, and `{}`. \n\nAdjacent string  are automatically concatenated:\n\n```\nchar *str = \"This is the first half \" \n            \"and this is the second half\";\n```\n\n\nAnything involving a `char` buffer, though, requires a library function like `strcat`:\n\n```\nchar buf[SOME_SIZE];\n...\nstrcat(buf, \"This is the first half \");\nstrcat(buf, \"and this is the second half\");\n```\n\n\nThere is also the preprocessor token pasting operator `##`, but the result must be a valid  token.  \n", "accept": false, "score": 3}, {"body": "## is a concatenation operator....\n", "accept": false, "score": -1}], "score": [12.0, 6.810685612517955e-232, 2.3032267309856755e-234, 0.0, 3.171134310938539e-239, 7.896856196865679e-155, -3.4775710352053836e-236]}
{"question": "I'm just starting to learn Verilog. As I understand, Verilog has `net` datatypes.\n\nWhat does `net` stand for?\n", "answer": [{"body": "A net is such a data type, where you don't use it for storing values. They represent physical connections. You can think of wire as a net data type.\nYou can see more on nets [here](http://www.eecis.udel.edu/~elias/verilog/verilog_manuals/chap_3.pdf).\n", "accept": true, "score": 8}, {"body": "A  is short for , and a network is a group of devices that share a common connection, a wire in most cases here. Net's represent connections as opposed to variables which hold values. I wrote a [short article](http://go.mentor.com/wire-vs-reg) to explain why Verilog has nets.\n", "accept": false, "score": 7}, {"body": "Nets : represent structural connections between components.Nets have values continuously driven on them by the outputs of the devices to which they are connected to. i.e. nets get the output value of their drivers. If a net has no driver, it gets the value of z(high impedance).\n", "accept": false, "score": 1}, {"body": "\n\n4.2 Nets and variables:\n\n> There are two main groups of data types: the variable data types and the net data types. These two groups\n  differ in the way that they are assigned and hold values. They also represent different hardware structures.\n\n4.2.1 Net declarations:\n\n> The net data types can represent physical connections between structural entities, such as gates. A net shall\n  not store a value (except for the trireg net). Instead, its value shall be determined by the values of its drivers,\n  such as a continuous assignment or a gate.\n\nand the syntax table that follows says:\n\n> net_type ::=\n  supply0 | supply1\n  | tri | triand | trior | tri0 | tri1 | uwire | wire | wand | wor\n\n\n\nA net is a set of data types, one of which is `wire`.\n\nThose data-types have in common that unlike registers they don't have memory: they are just intermediate results determined by their input. Much like the intuitive notion of wires.\n", "accept": false, "score": 1}], "score": [16.0, 1.4764774179264669e-235, 1.2793268890653506e-236, 4.4417083942046304e-232]}
{"question": "I'm an FPGA noob trying to learn Verilog.  How can I \"assign\" a value to a reg in an always block, either as an initial value, or as a constant.  I'm trying to do something like this in the code below.  I get an error because the 8 bit constant doesn't count as input.  I also don't want to trigger the always off of a clock.  I just want to assign a register to a specific value.  As I want it to be synthesisable I can't use an initial block.  Thanks a lot. \n\n```\nmodule top\n(\n    input wire clk,\n    output wire [7:0] led   \n );\n\n\nreg [7:0] data_reg ; \nalways @*\nbegin\n    data_reg = 8'b10101011;\nend\n\nassign led = data_reg;\n\nendmodule\n```\n\n", "answer": [{"body": "The always @* would never trigger as no Right hand arguments change. Why not use a wire with assign?\n\n```\nmodule top (\n    input wire clk,\n    output wire [7:0] led   \n);\n\nwire [7:0] data_reg ; \nassign data_reg   = 8'b10101011;\nassign led        = data_reg;\n\nendmodule\n```\n\n\nIf you actually want a flop where you can change the value, the default would be in the reset clause.\n\n```\nmodule top\n(\n    input        clk,\n    input        rst_n,\n    input  [7:0] data,\n    output [7:0] led   \n );\n\nreg [7:0] data_reg ; \nalways @(posedge clk or negedge rst_n) begin\n  if (!rst_n)\n    data_reg <= 8'b10101011;\n  else\n    data_reg <= data ; \nend\n\nassign led = data_reg;\n\nendmodule\n```\n\n\nHope this helps\n", "accept": false, "score": 5}, {"body": "When a chip gets power all of it's registers contain random values. It's not possible to have an an initial value. It will always be random.\n\nThis is why we have reset signals, to reset registers to a known value. The reset is controlled by something off chip, and we write our code to use it.\n\n```\nalways @(posedge clk) begin\n    if (reset == 1) begin // For an active high reset\n        data_reg = 8'b10101011;\n    end else begin\n        data_reg = next_data_reg;\n    end\nend\n```\n\n", "accept": false, "score": 4}, {"body": "You can combine the register declaration with initialization.\n\n```\nreg [7:0] data_reg = 8'b10101011;\n```\n\n\nOr you can use an `initial` block\n\n```\nreg [7:0] data_reg;\ninitial data_reg = 8'b10101011;\n```\n\n", "accept": true, "score": 36}, {"body": "You should use what your FPGA documentation recommends. There is no portable way to initialize register values other than using a reset net. This has a hardware cost associated with it on most synthesis targets.\n", "accept": false, "score": 6}, {"body": "The other answers are all good.  For Xilinx FPGA designs, it is best  to use global reset lines, and use `initial` blocks for reset conditions for most logic.  Here is the white paper from Ken Chapman (Xilinx FPGA guru)\n\n[http://japan.xilinx.com/support/documentation/white_papers/wp272.pdf](http://japan.xilinx.com/support/documentation/white_papers/wp272.pdf)\n", "accept": false, "score": 6}], "score": [5.0, 4.114960592660481e-156, 72.0, 1.1690473564398905e-243, 12.0]}
{"question": "I'm a programmer wishing to learn verilog.\n\nWhat would be amazingly neat would be a tutorial where one constructs a tiny microprocessor with a very clean design, something like an Intel 4004, and then goes on to actually make it using an fpga and gets it to flash LEDs to order.\n\nIs there such a tutorial?\n\nIf not, I might have a go at writing one as I try to do it. Has anyone got any recommendations as to resources I might draw on? e.g. nice open source verilog compiler, debugging tools, simulators, verilog tutorials, cheap fpgas and programming tools, breadboards for LEDs, etc.\n", "answer": [{"body": "Not sure about an explicit verilog tutorial, but you might find this class interesting from MIT open courseware:\n\n[http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-004-computation-structures-spring-2009/](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-004-computation-structures-spring-2009/)\n\nAll the class notes are online, and the syllabus sounds like it might be what you're interested in (emphasis mine):\n\n> 6.004 offers an introduction to the engineering of digital systems. Starting with MOS transistors, the course develops a series of\n  building blocks \u2014 logic gates, combinational and sequential circuits,\n  finite-state machines, computers and finally complete systems. Both\n  hardware and software mechanisms are explored through a series of\n  design examples.6.004 is required material for any EECS undergraduate who wants to understand (and ultimately design) digital systems. A good grasp of\n  the material is essential for later courses in digital design,\n  computer architecture and systems. Before taking 6.004, students\n  should feel comfortable using computers; a rudimentary knowledge of\n  programming language concepts (6.001) and electrical fundamentals\n  (6.002) is assumed.The problem sets and lab exercises are intended to give students\n  \"hands-on\" experience in designing digital systems; . Access to workstations as well\n  as help from the course staff is provided in the lab but . \n", "accept": false, "score": 3}, {"body": "All of the FPGA vendors have inexpensive ($200~250 range) development kits.  For example, the [SP601](http://www.xilinx.com/products/boards-and-kits/EK-S6-SP601-G.htm) from Xilinx or the [Cyclone III Starter](http://www.altera.com/products/devkits/altera/kit-cyc3-starter.html) from Altera.  I personally own an [SP605](http://www.xilinx.com/products/boards-and-kits/EK-S6-SP605-G.htm) (~$500) from Xilinx.  You may be able to find cheaper options from other options (e.g. [Sparkfun](http://www.sparkfun.com/categories/136)).\n\nStrictly speaking, while you can find open source VHDL/Verilog tools, I am not aware of any such tools for synthesis (making something the FPGA will use).  Both [Xilinx](http://www.xilinx.com/products/design-tools/ise-design-suite/ise-webpack.htm) and [Altera](http://www.altera.com/products/software/quartus-ii/web-edition/qts-we-index.html) provide free (as in beer) tooling, but they are not open or free (as in libre) software.  The Xilinx tools include a simulator (limited in the free version) and can run on Windows or Linux.  I assume the Altera tools are similar, but I am not familiar with them.\n\nBuilding a simple microprocessor in Verilog/VHDL is a pretty common feature in college computer architecture classes.  You can undoubtedly find class notes and the like from pretty much any major school.\n", "accept": false, "score": 1}, {"body": "There is an excellent open source verilog compiler, Icarus. From the [Icarus web page](http://iverilog.icarus.com/)\n\n> Icarus Verilog is a Verilog simulation and synthesis tool. It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format.\n\nI am not aware of a microprocessor-in-verilog tutorial, but there is the [OpenCores](http://opencores.org) web site. In the Processors tag under Projects, I see many processors implemented in Verilog or VHDL: 8080, 6502, 8051, Z80, 6805, to name a few. I assume one of these would serve you as an example to get you started.\n", "accept": false, "score": 1}, {"body": "I found some glorious slides about an elementary microprocessor here:\n\n[http://www.slideshare.net/n380/elementary-processor-tutorial](http://www.slideshare.net/n380/elementary-processor-tutorial)\n", "accept": true, "score": 6}, {"body": "Altera has great resources on this kind of stuff.\n\nYou can try out this link:\n[http://www.altera.com/education/univ/materials/digital_logic/labs/unv-labs.html](http://www.altera.com/education/univ/materials/digital_logic/labs/unv-labs.html)\n\nThere's a series of lab tutorials that goes through making an embedded processor using Verilog/VHDL.\n", "accept": false, "score": 3}, {"body": "The open source tools are good for development/testing but won't be able to synthesise your hdl to produce a bitstream, you'll need to use one of the manufacturers tools from altera or xilinx (or others).\n\nThe manufacturers tools come as suites ,  are large (5GB install and need 7 to 12 GB drive space) available for windows and linux. altera.com  xilinx.com\n\nThere are plenty of soft cores out there.\nopencores.org  would be a good place to have a look at\nThere is the zpuino which is arduino compatible.\n\nBest idea is start simple and build up\nGet a fpga board, implement a simple design (led flasher) and work up from there.\nQuite a learning curve especially if you haven't done much digital electronics.\n\nRemember its hardware and your designing circuits not writing code\nso timing is everything. \n\nHave a look at the fpga4fun.com projects and work through them\nas a starting point.\n\nxilinx based\ndigilentinc has some low cost boards , as does gadget factory.\navnet has a usb dongle based board for $80.\n\naltera based . \nterasic has some nice boards.\n\nGadget factory has a kickstarter project up at the moment for the paillio + a few addon boards [http://www.kickstarter.com/projects/13588168/retrocade-synth-one-chiptune-board-to-rule-them-al](http://www.kickstarter.com/projects/13588168/retrocade-synth-one-chiptune-board-to-rule-them-al)\n", "accept": false, "score": 6}, {"body": "You can play with Verilog without an actual board using the GNU [Icarus Verilog](http://iverilog.icarus.com/). You can get [a Windows build from here](http://bleyer.org/icarus/).\n\nThere is a also a tutorial by Niklaus Wirth on how to design and build a simple CPU, with code in Verilog for a Xilinx board:\n\n[https://www.inf.ethz.ch/personal/wirth/FPGA-relatedWork/RISC.pdf](https://www.inf.ethz.ch/personal/wirth/FPGA-relatedWork/RISC.pdf)\n[https://www.inf.ethz.ch/personal/wirth/FPGA-relatedWork/ComputerSystemDesign.pdf](https://www.inf.ethz.ch/personal/wirth/FPGA-relatedWork/ComputerSystemDesign.pdf)\n\n~Yes, it is the same Wirth that invented Pascal -- he is playing with FPGAs in his retirement.\n", "accept": false, "score": 6}], "score": [3.0, 4.7063806102496097e-237, 5.73354533611378e-236, 12.0, 1.0209100186523436e-236, 9.153690855136654e-233, 2.3347902081485894e-234]}
{"question": "The other day I've learnt a cool trick in Verilog. When you need to do something repeatedly. You could use a shift register to count the number of incrementation. Just shifting a 1 from LSB to MSB, and when it reach the MSB you're done.\n\nIn C it would be something like this:\n\n```\nfor(j=0b1; !(j & (1<<16)); j=j<<1)\n{\n/*do a thing 16 times*/\n}\n```\n\n\nI know it has limited use because of the bit width, but it isn't involving any addition so it is fast.\nSo my question: \n\nMaybe in embedded systems where resources are limited. \n\nThanks\n", "answer": [{"body": "This is very  worth it. It make the code much less cleaner and harder to read, and the performance difference it negligible. \n\nYour compiler can do these types of optimizations much better than you can. Short loops like this might even be unrolled for performance reasons. However, if you write the loop like that a compiler might not be able to figure that out as easily, so you might even be slowing the program down. \n\nThis is really a case of micro-optimization that will almost certainly never make a noticeable difference on your program's runtime.\n", "accept": false, "score": 8}, {"body": "In a real CPU, addition is one of the fastest things you can do; a bitshift is  any faster. And you will make it harder for the compiler to optimize efficiently.\n", "accept": false, "score": 1}, {"body": "Faster? Are you sure about that? At least on the MIPS architecture, a bit shift takes exactly as long as an addition. I would be surprised if this wasn't true of the most common consumer-oriented processor architectures as well.\n\nBesides, as Oleksi notes, this is rather hard to read. Probably not worth a nonexistant speed gain.\n", "accept": false, "score": 1}, {"body": "In general if you want to always loop a specific number of times > 0 and minimize loop overhead, then I think this will be the \"best\":\n\n```\nunsigned i = 16;\n\ndo {\n// do something here\n} while (--i);\n\n\n\nYou might get the same result with:\n\nunsigned i = 0x8000;\n\ndo {\n// do something here\n} while (i>>=1);\n```\n\n\nAt that point you would have to look at the assembly.\n", "accept": false, "score": 0}, {"body": "It seems to me that most of the guys commenting / answering does not really understand what asker is talking about. Verilog language is for hardware design and hardware design is very different thing than software design, no CPU cycles or anything like that. However, short answer is still: No. Long answer:\n\nFor sure shifting is MUCH simpler than addition. For shifting there is much less logic from FF (flip flop) to FF. For addition, carry has to be propagated from the LSB bit to the MSB bit, which means log2(N) levels of logic (N is the top value that counter would reach).\nOn the other hand, shift register would use N FFs, while adder would only use log2(N) FFs.\nSo there is a performance / area trade off which also heavily depends on N. Some 'independent' info about adder:\n[http://en.wikipedia.org/wiki/Adder_%28electronics%29](http://en.wikipedia.org/wiki/Adder_%28electronics%29)\nCouldn't find similar article for shifting, but once you understand adder, shifter should be obvious.\n\nThis might be important when you are designing the state machine in RTL. But the code you presented has actually nothing to do with the above. This 'for' loop in verilog means all the 'work' will be done in single cycle. So there will actually be N logics. This loop has nothing to do with implementation. It might even only confuse verilog compiler to spit out something strange and affect simulation (where CPU cycles does matter and above answers would be valid). Someone with more experience with tools could comment on that.\n", "accept": false, "score": 5}, {"body": "(As per Stefan's answer, I'm assuming you're asking about the C version inspired by the Verilog version, not about doing this in Verilog.)\n\nOn many architectures, this is actually worse, because the bit shift takes an extra instruction while the addition for the loop variable is completely free.\n\nCompletely?\n\nYes.  Because there are, on many architectures, single instructions that decrement a counter and branch if it is nonzero -- and these instructions take just as much time as any other compare-and-branch instruction.  Whereas, if you're doing a shift, that takes an extra instruction cycle.  It's even worse if your platform doesn't have a \"compare equal and branch\" instruction -- and not all of them do; some make you subtract and compare to zero in two instructions.\n\nEven on a RISC platform with no decrement-compare-branch instruction, the countdown loop is probably faster because you can simply subtract (one instruction) and use the branch-if-nonzero instruction -- whereas, in your loop, you need a shift (one instruction) and a bitwise-and (one instruction) before the branch-if-zero.  And that's assuming you even have a branch-if-zero.\n\nMoreover, for a simple `for (i = 0; i < N; i++)` loop, it's trivial for the compiler to convert it to a \"count down to 0\" loop if that's faster -- you rarely need to even do that bit of cleverness yourself.\n", "accept": false, "score": 2}, {"body": "Increment is a very special case of addition. In most processors and certainly most RISC processors a shift and an increment will be identical in execution time.  In fact in most architectures addition will take no longer either.\n\nWhen you keep your loop code idiomatic, the optimiser is likley to simply unroll the loop and render it faster in any case.  If you make the loop mechanism \"unusual\" the optimiser may be unable to optimise it.\n", "accept": false, "score": 1}, {"body": "> it isn't involving any addition so it is fast\n\nFor which CPU architecture is shift faster than addition? Also, what makes you think the compiler for that specific architecture wouldn't do the optimization from addition to shift automatically, if it would turn out that shift is faster?\n\n> Is there any use of this?\n\nFor optimization purposes, no there isn't any use of it.\n\nFor other purposes, yes, code like that is commonly used for masking out individual bits of a byte. I believe the two most common approaches are these:\n\n```\nuint8_t mask; \n\nfor(mask = 0x01; mask != 0x00; mask<<=1)\n{\n  do_something (data & mask);\n}\n```\n\n\nor\n\n```\nfor(i=0; i<8; i++)\n{\n  do_something (data & (1<<i));\n}\n```\n\n", "accept": true, "score": 1}], "score": [1.2468313679843357e-234, 1.948412260733151e-244, 8.17846318021787e-238, 0.0, 10.0, 4.0, 3.5228120082517626e-241, 2.0]}
{"question": "If I've got an array of 9 wires, is there an easy way to make a new wire that is high if exactly one of the 9 is high?  I know I could do \n\n```\nwire[8:0] data;\nwire exactlyOneActive;\nassign exactlyOneActive = (data[0] & !data[1] & !data[2] ...) | \n                          (!data[0] & data[1] & !data[2] ...) |\n                          (!data[0] & !data[1] & data[2] ...) |\n                          ...etc\n```\n\n\nbut, yuck, right?  Especially since the nine wires will probably be 25 at some point.  Any better way to do this, maybe using `generate`?  It has to be synthesizable too.\n", "answer": [{"body": "I think something like this should work. For loop will be synthesizable as long as it has a constant loop counter, as this does:\n\n```\n#define N 8\n\nwire [N:0] data;\n\nreg [N:0] uniqueActive;\n\nalways @(data) begin\n   for (i=0 ; i < N; i = i+1 ) begin\n      uniqueActive[i] = (data == 1<<i);\n   end\nend\n\nassign exactlyOneActive = (uniqueActive != 0);\n```\n\n", "accept": false, "score": 2}, {"body": "This should be a pretty efficient design.\n\n```\nwire[8:0] data;\nwire exactly_one_active;\n\n//Total is log2_ceiling of data bits wide\n// Remove binary weighting\nwire  [3:0] total = data[8] + data[7] ... + data[0]; \n\nassign exactly_one_active = (total == 4'b1);\n```\n\n", "accept": false, "score": 4}, {"body": "```\nassign zeroOrOnehot     = ~|(data & (data-1));\nassign atLeastOneBitSet = |data;\nassign exactlyOneActive = zeroOrOnehot & atLeastOneBitSet;\n```\n\n\nRegards - Cliff Cummings - Verilog & SystemVerilog Guru\n", "accept": true, "score": 6}, {"body": "Think in terms of logic: what do you want?\nSay you had two wires: and you wanted to know is one high or not ... it's not an and, it's not an or ... wait, it's an xor (exclusive or ... one or the other but not both).\n\nso what you want is:\nassign exactlyOneActive = data[0] ^ data[1]  ^ data[2] ^ ...\n\nperhaps the following is legal: data ^ 1b'0 (xor all bits with one zero bit)\n", "accept": false, "score": -2}, {"body": "All the other solutions require O(N^2) gates.  Note the following pattern \n\n```\n(a#b#c#d#e#f#g#h) & (a&b # c&d # e&f # g&h) & (a&b&c&d # e&f&g&h)\n```\n\n\nwhere you test the aggregate xor, the xor of each pair, the xor of each group of 4, the xor of each group of 8 (not shown), etc, gives you a correct answer in O(N log(N)) gates.  (You can verify logic on [truth table generator](http://turner.faculty.swau.edu/mathematics/materialslibrary/truth/)).  Not sure how to write this in a concise way in Verilog though.\n", "accept": false, "score": 1}, {"body": "Here's an O(N) gate solution\n\n```\nwire[8:0] wires;\nwire isOneHot;\nwire[8:-1] moreThanOne;\nwire[8:-1] atLeastOne;\n\ngenvar i;\ngenerate\n    for (i=0; i<9; i=i+1) begin :b1\n        assign atLeastOne[i] = atLeastOne[i-1] | wires[i];\n        assign moreThanOne[i] = moreThanOne[i-1] | atLeastOne[i-1] & wires[i];\n    end\n    assign isOneHot = atLeastOne[8] & !moreThanOne[8];\nendgenerate\n```\n\n", "accept": false, "score": 1}], "score": [2.360446828402859e-156, 3.989589274947916e-156, 12.0, -6.602118274071864e-234, 2.0, 2.9761452640699586e-156]}
{"question": "The general rule of thumb mentioned in all of books I have read so far is that you have to use non-blocking assignments in always blocks that are driven by the raising or falling edge of the clock. On a contrary, blocking assignments must be used for combinatorial logic description. This rule makes sense to me and authors of examples follow it thoroughly.\n\nHowever, I spotted the following piece of Verilog in one of the production code:\n\n```\nalways @* begin\n   in_ready <= out_ready || ~out_valid;\nend\n```\n\n\nNote that non-blocking assignment `<=` is being used. I don't think it makes any difference in this case because there are no multiple assignments. However, I cannot seem to find any explanation for this. So the question is - does it or does not make any difference, both in the scope of a given always block and as part of the larger design?\n", "answer": [{"body": "Irrelevant but bad practise.\n\nI doubt that the single assignment causes any side effects. The always block will trigger for any change on the right hand side, updating in_ready. There is nothing to block, so non-blocking will not cause issues.\n\nIf a larger design had :\n\n```\nalways @* begin \n  in_ready    <= out_ready || ~out_valid  ;\n  other_ready <= in_ready  || other_ready ;\nend\n```\n\n\nI am not too sure, as it is combinatorial it might just take an extra delta step to resolve.\n", "accept": true, "score": 5}, {"body": "Of course this violates my coding guideline #3: [http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf](http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf)) but it will work.\nThe reason to avoid using nonblocking assignments to code combinational logic is simulation performance. In Munkymorgy's example, after the always block triggers, you will evaluate the right-hand-side (RHS) of all of the equations, go back to the top of the always block, update the LHS of the equations, which will again trigger the always block, which will again force the simulator to evaluate the RHS of the equations, go to the top of the always block, then update the LHS of the equations. For larger blocks, this could cause multiple iterations through the always block, with the corresponding simulation penalty.\nIn your simple 1-line example, there is no internal simulation penalty, but there may be cross-assignment penalties elsewhere.\nGood coders use consistently good coding habits. I would change the code. If changing the code breaks the simulation results, then there are additional bad coding habits buried elsewhere in the code. The code should not be that fragile.\n", "accept": false, "score": 9}, {"body": "its not bad its your choice if you understand the way the circuit will behave its very much fine\nso for example \n\nalways @* begin\n b<=a+c;\n a=b;\n end\n\n\n1. so in this sample code the complete circuit developed inside the always block will get activated when anything inside the sensitivity list which is all inputs will either rise or fall it change its current state\n2. now b <=a+c now here a full adder will be created with 'a' and 'c' as input but\n3. now the design is made or the compiler synthesize the circuit in such a way that the next statement a=b here the wire is taken out from the old value and not from the updated b and is been provided to a ; so simply\n4. if you want the same to happen you are welcome to do no issue will come in synthesizable\n\n\n", "accept": false, "score": 2}, {"body": "Non-blocking assignment in always @(*) is required if one wants to simulate gate delays.\nFor example, the below code properly simulates an OR gate with 3 ns delay at the output. Blocking assignment would not work in this case.\n```\nalways @(*) begin\n  a <= #3 b | c;\nend\n```\n\nFurther reading:\n\n1. http://www.sunburst-design.com/papers/CummingsHDLCON1999_BehavioralDelays_Rev1_1.pdf\n2. https://electronics.stackexchange.com/q/572643/238188\n\n\n", "accept": false, "score": 2}], "score": [10.0, 6.76593777143506e-235, 1.769607962825965e-232, 2.7737526680473645e-79]}
{"question": "I am teaching myself verilog. The book I am following stated in the introduction chapters that to perform division we use the '/' operator or '%' operator. In later chapters it's saying that division is too complex for verilog and cannot be synthesized, so to perform division it introduces a long algorithm.\n\nSo I am confused, can't verilog handle simple division? is the / operator useless?\n", "answer": [{"body": "Division and modulo are never \"simple\". Avoid them if you can do so, e.g. through bit masks or shift operations. Especially a variable divisor is really complicated to implement in hardware.\n", "accept": false, "score": 5}, {"body": "It all depends what type of code you're writing.\n\nIf you're writing code that you intend to be synthesised, that you intend to go into an FPGA or ASIC, then you probably don't want to use the division or modulo operators. When you put any arithmetic operator in RTL the synthesiser instances a circuit to do the job; An adder for `+` & `-`; A multiplier for `*`. When you write `/` you're asking for a divider circuit, but a divider circuit is a very complex thing. It often takes multiple clock cycles, and may use look up tables. It's asking a lot of a synthesis tool to infer what you want when you write `a / b`.\n\n(Obviously dividing by powers of 2 is simple, but normally you'd use the shift operators)\n\nIf you're writing code that you don't want to be synthesised, that is part of a test bench for example, then you can use division all you want.\n\nSo to answer your question, the `/` operator isn't useless, but you have be concious of where and why you're using it. The same is true of `*`, but to a lesser degree. Multipliers are quite expensive, but most synthesisers are able to infer them.\n", "accept": true, "score": 35}, {"body": "> So im confused. cant verilog handle simple division? is the / operator\n  useless?\n\nThe verilog synthesis spec (IEEE 1364.1) actually indicates all arithmetic operators with integer operands should be supported but nobody follows this spec. Some synthesis tools can do integer division but others will reject it(I think XST still does) because combinational division is typically very area inefficient. Multicycle implementations are the norm but these cannot be synthesized from '/'.\n", "accept": false, "score": 6}, {"body": "\"Verilog the language\" handles division and modulo just fine - when you are using a computer to simulate your code you have full access to all it's abilities.  \n\nWhen you are synthesising your code to a particular chip, there are limitations.  The limitations tend to be based on what the tool-vendor thinks is \"sensible\" rather than what is feasible.  \n\nIn the old days, division by anything other than a power-of-two was deemed to be non-sensible for silicon as it took up a lot of space and ran very slowly.  At the moment, some synthesisers with create \"divide by a constant\" circuits for you.  \n\nIn future, I see no reason why the synthesiser shouldn't create you a divider (or make use of one that is in the DSP blocks of a potential future architecture).  Whether it will or not remains to be seen, but witness the progression of multipliers (from \"only powers of two\" to \"one input constant\" to \"full implementation\" in just a few years)\n", "accept": false, "score": 4}, {"body": "Using `result <= a/b` and works perfectly.\n\nRemember when using the `<=` operator, the answer is calculated immediately but the answer is entered inside the \"result\" register at next clock positive edge.\n\nIf you don't want to wait till next clock positive edge use `result = a/b.`\n\nRemember, any arithmetic operation circuit needs some time to finish the operation, and during this time the circuit generates random numbers (bits).\n\nIts like when A-10 warthog attack airplane attacks a tank it shoots lots of bullets. That's how the divider circuit acts while dividing,it spits random bits. After couple of nanoseconds it will finish dividing and return a stable good result.\n\nThis is why we wait until next clock cycle for the \"result\" register. We try to protect it from random garbage numbers.\n\nDivision is the most complex operation, so it will have a delay in calculation. For 16bit division the result will be calculated in approximately 6 nanoseconds.\n", "accept": false, "score": -10}, {"body": "\n1. circuits including only division by 2 : just shift the bit :)\n2. other than 2 .... see you should always think at circuit level verilog is NOT C or C++\n3. / and % is not synthesizable or if it becomes( in new versions) i believe you should keep your own division circuit this is because the ip they provide will be general ( most probably they will make for floating not fixed)\n4. i bet you had gone through morris mano computer architechure book , there in some last chapters the whole flow is given along with algo , go through it follow it and make your own\n5. see now if your works go for only logic verification and no real circuit is needed , sure go for / and % . no problem it will work for simulation\n\n\n", "accept": false, "score": 1}, {"body": "You have to think in hardware.\n\nWhen you write a <= b/c you are saying to the synthesis tool \"I want a divider that can provide a result every clock cycle and has no intermediate pipline registers\".\n\nIf you work out the logic circuit required to create that it's very complex, especially for higher bit counts. Generally FPGAs won't have specialist hardware blocks for division so it would have to be implemented out of generic logic resources. It's likely to be both big (lots of luts) and slow (low fmax).\n\nSome synthesisers may implement it anyway (from a quick search it seems quartus will), others won't bother because they don't think it's very useful in practice.\n\nIf you are dividing by a constant and can live with an approximate result then you can do tricks with multipliers. Take the reciprocal of what you wanted to divide by, multiply it by a power of two and round to the nearest integer.\n\nThen in your verilog you can implement your approximate divide by multiply (which is not too expensive on modern FPGAS) followed by shift (shifting by a fixed number of bits is essentially free in hardware). Make sure you allow enough bits for the intermediate result.\n\nIf you need an exact answer or if you need to divide by something that is not a pre-defined constant you will have to decide what kind of divider you want. IF your throughput is low then you can use a state machine based approach which does one division every n clock cycles. If your throughput is high and you can afford the device area then a pipelined approach which does a division per clock cycle (but requires multiple cycles for the result to flow through) may be more appropriate.\n\nOften tool vendors will provide pre-made blocks (altera calls them megafunctions) for this kind of stuff. The advantage of these is that the tool vendor will likely have carefully optimised them for the device. The downside is they can bring vendor lockin, if you want to move to a different device vendor you will most likely have to swap out the block and the block you swap it with may have different characteristics.\n", "accept": false, "score": 13}, {"body": "Division using '/' is possible in verilog. But it is not a synthesizable operator. Same is the case for multiplication using '*'. There are certain algorithms to perform these operations in verliog, and they are used if the code needs to be synthesizable. ie. if you require an equivalent hardware for it.\n\nI am not aware of any algorithms for division, but for multiplication, i have used Booth's algorithm. \n", "accept": false, "score": 0}, {"body": "if you want the synthesizable code you can use the Divison_IP or you can use the right shifting operator for some divisions like 64/8=8 same 64>>3 = 8.\n", "accept": false, "score": 0}, {"body": "Division isn't simple in hardware as people spent a lot of time in an efficient\nand fast multiplier as an example. However, you can do divid by 2 easily by right shifting one bit in hardware.\n", "accept": false, "score": 0}, {"body": "Actually your point is very valid and I was also confused in my initial days of learning HDLs.\nWhen you synthesise a division operator, it consumes a lot of resources on FPGA or during logic synthesis for ASIC. Try following instead.\nYou can also perform division(and multiplication) by shifting some vector(right = division, left = multiplication). But that will be multiplication(and divion) by 2.\nExample 0100 = 4\nShift right 0010 = 2(which is 4/2)\nShift left  1000 = 8(which is 4*2).\nWe use >> operator for shift right, and << for shift left.\nBut we can also produce variations out of it.\nFor example multiplication by 3.\nSo if we have 0100 (4 dec) then also will be\n  ((0100 << 1)+1)\nSimilarly division by 3\n  ((0100 >> 1) - 1)\nThese methods were made because to be honest, resources in FPGA are limited, and when it comes to ASICs, your manager tries to kill you for any additional logic. :)\n", "accept": false, "score": 0}, {"body": "The division operator `/` is not useless in Verilog/System Verilog. It works in case of simulations as usual mathematical operator.\nSome synthesis tools like Xilinx Vivado synthesize the division operator also because it is having a pre-built algorithm in it (though takes more hardware gates).\nIn simple words, you can do division in Verilog but have to take care of tools and simulators.\n", "accept": false, "score": -1}], "score": [1.3015127777479409e-239, 70.0, 2.92868165336191e-233, 4.952404191070107e-233, -20.0, 2.0, 26.0, 0.0, 0.0, 0.0, 0.0, -8.830551432430778e-238]}
{"question": "I have some self-testing code for my SystemVerilog component and I want to ensure that my tests cover everything, especially the failure cases in my classes. All I need is line/branch coverage, just like what is normally used for other object oriented languages such as Java.\n\nI tried using VCS (version 2012.06) coverage, and I found it only has a limited support for SystemVerilog, and does not support any coverage for SystemVerilog classes. Is there any simulator or tool that has this support?\n", "answer": [{"body": "I'd have thought [Modelsim's](http://www.mentor.com/products/fv/multimedia/using-code-coverage-modelsim-webseminar/) or [Aldec's](http://www.aldec.com/en/solutions/functional_verification/code_coverage/) coverage would do what you need.  To be honest, it looks like [VCS](http://www.synopsys.com/Tools/Verification/FunctionalVerification/Pages/VCS.aspx) does too, so maybe the other tools have the same flaws?\n", "accept": false, "score": 1}, {"body": "The Certitude tool by SpringSoft (just purchased by Synopsys) is a tool which checks the effectiveness of your testbench.  It essentially analyzes coverage of your testbench code and does a whole lot more.\n\n[http://www.springsoft.com/products/functional-qualification/certitude](http://www.springsoft.com/products/functional-qualification/certitude)\n", "accept": false, "score": 2}, {"body": "2012/08/25\n\nUntil further notice, the answer is:\n\nNo, there is no tool/simulator that supports line coverage for SystemVerilog classes.\n", "accept": true, "score": 2}, {"body": "I have tried that new feature in Mentor . They have implemented SV (systemverilog) class code coverage from Modelsim/Questa 10.2 on.\n\nTo activate that feature in a  you need to:\n\nExample :\n\n```\nvlog +cover my_design.sv\n   vsim \u2013voptargs=+acc  \u2013coverage  mydesign\n```\n\n\n[](https://i.stack.imgur.com/HxVa6.png)\n\nvcover may take the following specifications .When no specification is mention , +vcover  is equivalent with \u201c+vcover=bcesft\u201d.\n\nb \u2014 Collect branch statistics.\n\nc \u2014 Collect condition statistics. Collects only FEC statistics, unless -coverudp is specified.\n\ne \u2014 Collect expression statistics, Collects only FEC statistics, unless -coverudp is specified.\n\ns \u2014 Collect statement statistics.\n\nt \u2014 Collect toggle statistics. Overridden if \u2018x\u2019 is specified elsewhere\n\nx \u2014 Collect extended toggle statistics .This takes precedence, if \u2018t\u2019 is specified elsewhere.\n\nf \u2014 Collect Finite State Machine statistics.\n", "accept": false, "score": 1}, {"body": "I've found [covered](http://covered.sourceforge.net/), but didn't use it myself. It's open source, that's a plus, but seems not to be in development since 2010... :-/\n", "accept": false, "score": 0}], "score": [2.636889251680099e-245, 9.920977336266055e-238, 4.0, 9.081798945409359e-156, 0.0]}
{"question": "For instance, say I have a `reg [7:0] myReg`\nI assign it the value `-8'D69`\n\nI know Verilog stores it as 2's complement so it should be stored as\n\n```\n10111011\n```\n\n\nThe question I have now is if I were to perform an operation on it, say myReg/2\n\nWould it evaluate to -34? Or would it take 10111011 and turn it into 187 then perform the division, returning 93?\n", "answer": [{"body": "You need to remember that `-8d69` is just a bit pattern. reg is a type which holds bit patterns. It is the type of variable that instructs `/` to perform signed or unsigned arithmetic.\n\nIf this is for synthesis bare in mind that you want to try and avoid dividers, you really want to try and avoid signed dividers. It will likely synthesis smaller with `>>> 1` \n\n```\nreg [7:0] a;\nreg signed [7:0] b;\nreg [7:0] c;\nreg signed [7:0] d;\n\ninitial begin\n  a =  -8'd69 ;\n  b =  -8'd69 ;\n  c =  -8'd69 ;\n  d =  -8'd69 ;\n  #10ns;\n  a = a/2     ;\n  b = b/2     ;\n  #10ns;\n  $display(\"a      : %8b, %d\", a, a);\n  $display(\"b      : %8b, %d\", b, b);\n  $display(\"c >>>1 : %8b, %d\", c>>>1, c>>>1);\n  $display(\"d >>>1 : %8b, %d\", d>>>1, d>>>1);\nend\n```\n\n\nGives:\n\n```\na      : 01011101,  93\nb      : 11011110,  -34 \nc >>>1 : 01011101,  93\nd >>>1 : 11011101,  -35\n```\n\n\n`>> x` Shifts right by x places, `>>> x` Shifts right x places but sign extends for signed types. \n\nNB: the `/2` is also rounding up in my examples, `>>>` will round down/truncate.\n", "accept": true, "score": 15}, {"body": "> For instance, say I have a reg [7:0] myReg I assign it the value\n  -8'D69\n\nThis actually isn't a signed number but instead an expression consisting of a unary negation applied to a positive constant. If the expression was `-8'd130` the result would overflow. Signed constants are declared as `8'sd69` or just `69`.\n\n> The question I have now is if I were to perform an operation on it,\n  say myReg/2\n\n`myReg` is unsigned so the expression result will also be unsigned*. If you need the result to be signed than  operands must be signed. There are a couple ways to achieve this:\n\n```\n//Declare the reg as signed and divide by a signed value\nreg signed [7:0] myReg;\nassign result = myReg/2;\n\n//Use system functions\nassign result = $signed(myReg)/2;\n```\n\n\n*The complete rules regarding expression evaluation are much more complex but basically the result of any expression is unsigned, unless all operands are signed. \n\n```\nreg signed [7:0] a;\nreg [7:0] b;\n\ninitial\nbegin\nresult = a;            //Signed\nresult = a * a;        //Signed\nresult = a * 10;       //Signed\nresult = $unsigned(a); //Unsigned\nresult = a[0];         //Unsigned\nresult = a[7:0];       //Unsigned\nresult = {a,a};        //Unsigned\nresult = 10{a};        //Unsigned\nresult = a + b;        //Unsigned\nresult = a * b;        //Unsigned\nend\n```\n\n", "accept": false, "score": 6}, {"body": "I'll add that \n1. Data types bit and reg are unsigned, by default.\n2. Data types int, integer, longint, shortint, and byte are signed, by default.\n3. All these data types can take a signed or unsigned qualifier to change the default.\n\nSo, assigning -8'D69 to myReg does an implicit conversion to 187.  Then, myReg/2 = 187/2 = 93, unsigned.  It's important to understand when and how SystemVerilog does implicit type conversions in expressions and assignments.\n", "accept": false, "score": 1}, {"body": "The best place to check is the Language Reference Manual. Predictably, given Verilog's \"eh\" attitude to proper typing, it's a bit of a mess.\n[](https://i.stack.imgur.com/IJIsm.png)\nBasically `signed` doesn't affect the actual data stored in the variable/net, but it  affect what the arithmetic operators do in some case. The obvious case is comparison, but also multiplication and division would behave differently. Addition and subtraction should be the same for both `signed` and `unsigned`.\n[](https://i.stack.imgur.com/2bv6b.png)\nNote especially that when  of the operands is unsigned it is treated as an unsigned comparison, which is different to what you would expect from C. So if we have\n```\nbyte a = -10;        // byte is signed\nlogic [7:0] b = 10;  // this is unsigned\n```\n\nThen `a > b` is .\n[](https://i.stack.imgur.com/MsUkS.png)\nAgain if at least one operator is unsigned then it treats them both as unsigned so if we have:\n```\nbyte a = -1;\nlogic [7:0] b = 255;\n```\n\nThen `a == b` is .\n", "accept": false, "score": 1}], "score": [30.0, 2.3576273620605642e-231, 2.159989622225691e-233, 2.9594412944323422e-232]}
{"question": "Suppose I have a top level file that I pass to my compiler that has:\n\n```\n`include \"my_defines.sv\"\n`include \"my_component.sv\"\n```\n\n\nInside \"my_component.sv\" file, I am using some defines from \"my_defines.sv\", like this:\n\n```\nmy_variable = `CONSTANT_FROM_MY_DEFINES;\n```\n\n\nThe question is the following: do I need to have ``include \"my_defines.sv\"` inside \"my_component.sv\"? Perhaps this requirement is compiler-specific?\n", "answer": [{"body": "It is dependent upon the order in which your source files are compiled.  Because you are referring specifically to`define` macros, which are global, it is required that the macro definitions are compiled before the macro is used.  In your case, you do not need to include \"my_defines.sv\" inside \"my_component.sv\" since \"my_defines.sv\" was already compiled in your top file.\n", "accept": true, "score": 0}, {"body": "`include` directives like that are like copying and pasting that file into the point where the `include` is. The compiler:\n\n\n1. Reads the file you give it.\n2. When it encounters an include, it reads that file.\n3. When it's finished that file it continues the original file.\n\n\n\nThe result is that the compiler sees one big flat file.\n\nIn your example you can use stuff from `my_defines` in `my_component` because it appears earlier.\n\nThe problem with doing a lot of this is that eventually you'll end up with conflicts. Maybe two things reference each other (which include comes first), two things use the same name (clashing definitions), or multiple things have the same include statement (multiple definitions of the same thing). \n\nPackages solve those problems. Once things start getting a little more complex, look into them.\n", "accept": false, "score": 1}, {"body": "Macro definitions only persist across files but only to the end of the translation unit.  Simulators must support two different methods of assigning source files to translation units and it's hard to get `include files full of `defines to compile correctly in both methods.  \n\nIt is better use parameters or const variables for constants.  Since parameters and constants follow normal scoping rules you can safely include them in every file/scope that needs them.  Then it doesn't matter how the code is broken into translation units, it always compiles.  I think it is easier to find the definitions when you're browsing the code because the `include is probably in the same file instead of off in some other unrelated file.\n", "accept": false, "score": 0}, {"body": "you have to include `include \"my_defines.sv in my_component.sv...\n\nbest practice is add all include in one pkg and add that pkg to each of file.\n", "accept": false, "score": 0}, {"body": "If your \"my_defines.sv\" has an \"include\" guard, then it is safe and better to include \"my_defines.sv\" in all your other files. The \"include\" guard at the top of \"my_defines.sv\" will look like this:\n\n```\n`ifndef MY_DEFINES_SV\n`define MY_DEFINES_SV\n// put your own defines here ...\n`endif\n```\n\n", "accept": false, "score": 2}], "score": [2.0, 2.0, 0.0, 0.0, 2.5295785065619195e-156]}
{"question": "Is the construct `do <blah> while (0)` synthesizable in system verilog?\n\nI ask because I have some complex macros that I wish to protect using this syntax.\n\ne.g.\n\n```\n`define my_macro(arg1) \\\n    do \\\n         my_reg <= arg1; \\\n         valid <= 1; \\\n    while (0)\n```\n\n\nOr is there a similar verilog construct that I can use. Verilog would be preferred as it is used by more tools.\n", "answer": [{"body": "The loop construct in SystemVerilog, such as for, while, do...while, repeat, can be synthesized in modern logic synthesizer if and only if the condition expression can be unrolled and calculated during elaboration (or compilation time). It is not a problem to the tool, because the tool just employes loop unrolling techniques from compilers. By this way, the condition expression have to be calculated during the compilation time (means cannot dynamically change in the runtime) to determine what the termination condition of a loop is. \n\nSometimes even if the loop have a termination condition, but the tool may have some restrictions to limit the loop unrolling not exceeds a threshold, such as 1k or 10k, to prevent wasting much time in unrolling and expanding the loop body (tools does not know the limitation, it just keeps trying and testing the termination condition)\n\nIn following example, the loop can be synthesized.\n\n```\nfor (i=0; i < 10; i=i+1)\nfor (i=0; i < WIDTH; i=i+1)  // if WIDTH is a constant, or a parameter\n\nfor (i=0; i < 10; i=i+1) begin\n  ...\n  if (i > 5) break;          // `continue' and `break' are also supported if the loop\n                             // follows the synthesizable rules.\n  ...\nend\n```\n\n", "accept": true, "score": 2}, {"body": "Just wanting to expand on what I said in a comment in reply to this:\n> > What's wrong with begin and end? \u2013 Paul S yesterday@PaulS: because then my_macro(1); expands to begin  end; and that trailing semicolon is a syntax error. And how does the person who called my macro know whether it's a single statement or a multi-statement one? (or it might even change ...) \u2013 dave yesterday\nThe UVM library uses the following idiom extensively:\n```\n`define uvm_info(ID,MSG,VERBOSITY) \\\n   begin \\\n     if (uvm_report_enabled(VERBOSITY,UVM_INFO,ID)) \\\n       uvm_report_info (ID, MSG, VERBOSITY, `uvm_file, `uvm_line); \\\n   end\n```\n\nI've never had IES report a syntax error because I put a trailing semicolon on that macro, and I'm pretty sure I do it a lot. Granted I can't find in the spec if it should be a syntax error or not, but I think it gets interpreted as a null statement.\nRegardless, I think it's probably a good rule to say that if `my_macro` is a single statement it should include its `;`. Then single statement and multi statement macros work in the same way.\n", "accept": false, "score": 0}, {"body": "no its not....better use begin....end\n", "accept": false, "score": 0}, {"body": "@dave, you can try this:\n\n```\n`define my_macro(arg1) \\\n  if (1) \\\n    my_reg <= arg1; \\\n    valid <= 1; \\\n  else\n```\n\n\nIn any language using an 'if...else' wouldn't be more inefficient that using a 'do...while' so the former is preferred. [Here is a link](http://www.parashift.com/c++-faq/macros-with-multi-stmts.html) to the C++ FAQ-lite illustrating a similar construction. Also using 'if...else' makes it a Verilog-1995 as opposed to a SystemVerilog construct.\n\nBTW @Paul S, you can get a syntax error on putting a ';' after the macro, in code like this:\n\n```\nif (foo)\n  `uvm_info (get_type_name(), \"foo\", UVM_DEBUG);\nelse\n  `uvm_info (get_type_name(), \"not foo\", UVM_DEBUG);\n```\n\n\nI am not sure why UVM chose to do this instead of following what has been done for ages in the SW world... use 'do...while()' or 'if...else' to allow macro users to put that semicolon. May be unlike in C/C++, in Verilog/SV macros are visibly different from tasks due to the '`' so UVM expects users of the macros not to have a ';' at the end?\n", "accept": false, "score": 0}], "score": [4.0, 0.0, 0.0, 0.0]}
{"question": "in VHDL, I can easily do this:\n\n```\nconstant    cmdbytes       : bytearray(0 to Total) := (x\"05\", x\"00\", x...};\n```\n\n\nI want synthesizable constants so that when the FPGA starts, this array has the data I supplied.  These registers are wired to VCC or ground to represent 1 or 0.  I can then use them to generate a waveform.  Also I would like to have 2D byte array which is 3D in verilog world.  \n", "answer": [{"body": "Verilog 2005 doesn't allow array initialization. Though your FPGA vendor should have a means to generate a ROM.\n", "accept": false, "score": -1}, {"body": "If you're just using the array to pull out one value at a time, how about using a `case` statement? Granted, it's a long-winded way of doing it, but you could always write a script to write the RTL for you.\n\n```\nreg [7:0] value;\nreg [7:0] i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)\n        i <= 8'd0;\n    else\n        i <= i + 1;\nend\n\nalways @(*) begin\n    case(i) \n        8'h00: value = 8'd0;\n        8'h01: value = 8'd34;\n        ...\n    endcase\nendcase\n```\n\n\nAnother way is to use an `initial` statement. As far as I'm aware, FPGA synthesis tools will allow you to set initial values for arrays in the following manner. Again, a script to write this may be the way to go.\n\n```\nreg [0:35][7:0] my_array;\n\ninitial begin\n    my_array[0] = 8'd45;\n    my_array[1] = 8'd26;\n    ...\nend\n```\n\n\nAnd if your FGPA synthesis tools support some SystemVerilog, you'll be able to initialise the array like so:\n\n```\nreg [0:34][7:0] my_array = '{ 8'd90, 8'd34, ... }; // note the '{\n```\n\n", "accept": true, "score": 12}, {"body": "```\nmodule test (\n\n   input [7:0]   p1_sa,            // i\n   input [7:0]   p1_sb,            // i\n   output [7:0]   p3,            // o\n   output [7:0]   p3b            // o\n);\n\nlogic [7:0] array2d [7:0] = {99,124,119,123,242,107,111,197};\n\n   assign p3    = array2d[p1_sa];\n   assign p3b   = array2d[p1_sb];\n\nendmodule\n```\n\nI tried the above system verilog code and it is working fine in modelsim and Vivado.\n", "accept": false, "score": 1}, {"body": "An alternative to the `case` statement approach is to use a `function` to access values.\nExample for an \"array\" of size 4 containing 8 bit constants:\n```\nfunction [7:0] cmdbytes;\n        input    [1:0] index;\n        reg      [7:0] t[0:3];\n    begin\n        {   \n             t[0],t[1],t[2],t[3]\n        } = {   \n             8'h05, 8'h00, 8'h5b, 8'h45\n        };\n\n        cmdbytes = t[index];\n    end\nendfunction\n```\n\nOne can access the constants like so:\n```\nwire [7:0] value0;\nwire [7:0] value1;\nwire [7:0] value2;\nwire [7:0] value3;\n\nassign value0 = cmdbytes(2'd0);\nassign value1 = cmdbytes(2'd1);\nassign value2 = cmdbytes(2'd2);\nassign value3 = cmdbytes(2'd3);\n```\n\n", "accept": false, "score": 0}], "score": [-1.4584222309150796e-248, 24.0, 1.7924834800936657e-156, 0.0]}
{"question": "I have a program written in Verilog and I want to convert it into a FSM automatically. Is this possible (just to visualize it)?\n\nHere is the code :\n\n```\nmodule pci(reset,clk,frame,irdy,trdy,devsel,idsel,ad,cbe,par,stop,inta,led_out);\n    input reset;\n    input clk;\n    input frame;\n    input irdy;\n    output trdy;\n    output devsel;\n    input idsel;\n    inout [31:0] ad;\n    input [3:0] cbe;\n    inout par;\n    output stop;\n    output inta;\n    output [3:0] led_out;\n\nparameter DEVICE_ID = 16'h9500;\nparameter VENDOR_ID = 16'h106d;     // Sequent!\nparameter DEVICE_CLASS = 24'hFF0000;    // Misc\nparameter DEVICE_REV = 8'h01;\nparameter SUBSYSTEM_ID = 16'h0001;  // Card identifier\nparameter SUBSYSTEM_VENDOR_ID = 16'hBEBE; // Card identifier\nparameter DEVSEL_TIMING = 2'b00;    // Fast!\n\nreg [2:0] state;\nreg [31:0] data;\n\nreg [1:0] enable;\nparameter EN_NONE = 0;\nparameter EN_RD = 1;\nparameter EN_WR = 2;\nparameter EN_TR = 3;\n\nreg memen; // respond to baseaddr?\nreg [7:0] baseaddr;\nreg [5:0] address;\n\nparameter ST_IDLE = 3'b000;\nparameter ST_BUSY = 3'b010;\nparameter ST_MEMREAD = 3'b100;\nparameter ST_MEMWRITE = 3'b101;\nparameter ST_CFGREAD = 3'b110;\nparameter ST_CFGWRITE = 3'b111;\n\nparameter MEMREAD = 4'b0110;\nparameter MEMWRITE = 4'b0111;\nparameter CFGREAD = 4'b1010;\nparameter CFGWRITE = 4'b1011;\n\n`define LED\n`ifdef LED\nreg [3:0] led;\n`endif\n\n`undef STATE_DEBUG_LED\n`ifdef STATE_DEBUG_LED\nassign led_out = ~state;\n`else\n`ifdef LED\nassign led_out = ~led;  // board is wired for active low LEDs\n`endif\n`endif\n\nassign ad = (enable == EN_RD) ? data : 32'bZ;\nassign trdy = (enable == EN_NONE) ? 'bZ : (enable == EN_TR ? 1 : 0);\nassign par = (enable == EN_RD) ? 0 : 'bZ;\nreg devsel;\n\nassign stop = 1'bZ;\nassign inta = 1'bZ;\n\nwire cfg_hit = ((cbe == CFGREAD || cbe == CFGWRITE) && idsel && ad[1:0] == 2'b00);\nwire addr_hit = ((cbe == MEMREAD || cbe == MEMWRITE) && memen && ad[31:12] == {12'b0, baseaddr});\nwire hit = cfg_hit | addr_hit;\n\nalways @(posedge clk)\nbegin\n    if (~reset) begin\n        state <= ST_IDLE;\n        enable <= EN_NONE;\n        baseaddr <= 0;\n        devsel <= 'bZ;\n        memen <= 0;\n`ifdef LED\n        led <= 0;\n`endif\n    end\n    else    begin\n\n    case (state)\n        ST_IDLE: begin\n            enable <= EN_NONE;\n            devsel <= 'bZ;\n            if (~frame) begin\n                address <= ad[7:2];\n                if (hit) begin\n                    state <= {1'b1, cbe[3], cbe[0]};\n                    devsel <= 0;\n                    // pipeline the write enable\n                    if (cbe[0])\n                        enable <= EN_WR;\n                end\n                else begin\n                    state <= ST_BUSY;\n                    enable <= EN_NONE;\n                end\n            end\n        end\n\n        ST_BUSY: begin\n            devsel <= 'bZ;\n            enable <= EN_NONE;\n            if (frame)\n                state <= ST_IDLE;\n        end\n\n        ST_CFGREAD: begin\n            enable <= EN_RD;\n            if (~irdy || trdy) begin\n                case (address)\n                    0: data <= { DEVICE_ID, VENDOR_ID };\n                    1: data <= { 5'b0, DEVSEL_TIMING, 9'b0,  14'b0, memen, 1'b0};\n                    2: data <= { DEVICE_CLASS, DEVICE_REV };\n                    4: data <= { 12'b0, baseaddr, 8'b0, 4'b0010 }; // baseaddr + request mem < 1Mbyte\n                    11: data <= {SUBSYSTEM_ID, SUBSYSTEM_VENDOR_ID };\n                    16: data <= { 24'b0, baseaddr };\n                    default: data <= 'h00000000;\n                endcase\n                address <= address + 1;\n            end\n            if (frame && ~irdy && ~trdy) begin\n                devsel <= 1;\n                state <= ST_IDLE;\n                enable <= EN_TR;\n            end\n        end\n\n        ST_CFGWRITE: begin\n            enable <= EN_WR;\n            if (~irdy) begin\n                case (address)\n                    4: baseaddr <= ad[19:12];  // XXX examine cbe\n                    1: memen <= ad[1];\n                    default: ;\n                endcase\n                address <= address + 1;\n                if (frame) begin\n                    devsel <= 1;\n                    state <= ST_IDLE;\n                    enable <= EN_TR;\n                end\n            end\n        end\n\n        ST_MEMREAD: begin\n            enable <= EN_RD;\n            if (~irdy || trdy) begin\n                case (address)\n`ifdef LED\n                    0: data <= { 28'b0, led };\n`endif\n                    default: data <= 'h00000000;\n                endcase\n                address <= address + 1;\n            end\n            if (frame && ~irdy && ~trdy) begin\n                devsel <= 1;\n                state <= ST_IDLE;\n                enable <= EN_TR;\n            end\n        end\n\n        ST_MEMWRITE: begin\n            enable <= EN_WR;\n            if (~irdy) begin\n                case (address)\n`ifdef LED\n                    0: led <= ad[3:0];\n`endif\n                    default: ;\n                endcase\n                address <= address + 1;\n                if (frame) begin\n                    devsel <= 1;\n                    state <= ST_IDLE;\n                    enable <= EN_TR;\n                end\n            end\n        end\n\n    endcase\n    end\nend\nendmodule\n```\n\n\nIf there is no automatic way, could you explain a way of doing this?\n\nHere is an FSM made with hand but can't test so ...\n\n![fsm](https://i.stack.imgur.com/pJAW6.jpg)\n\nDoes it seem ok?\n", "answer": [{"body": "The better and expensive simulators can detect FSM's in the code and make a visualization of it.  E.g. the Modelsim SE version.  These can be nice to understand code and check the coveage.\nBut making you're own drawing of a 6-state FSM is not that hard.\n", "accept": false, "score": 3}, {"body": "The way to check if it's OK is to write a simulation and check that the behaviour is what you want.  There is no point getting a bubble diagram out and seeing if it matches your hand-drawn one, as you have no way of knowing if your hand-drawn diagram is correct...\n", "accept": false, "score": 1}, {"body": "It is sometimes easier to write the code and have the documentation generated from that.  Sometimes you inherit legacy code without documentation, in these situations especially if new to a language tools to help visualise what is happening can be quite useful.\n\nWith cadence tools you can run your code with 'code coverage' then  can load the coverage data and run .\n\nI have included a simple FSM below and show the generated state diagram.\n\n```\nmodule simple_fsm(); \n  //Inputs to FSM\n  logic clk;\n  logic rst_n;\n\n  logic [1:0] state    ;\n  logic [1:0] nextstate;\n  logic       turn_on  ;\n  logic       turn_off ;\n\n  localparam  S_OFF    = 2'b00;\n  localparam  S_GO_ON  = 2'b01;\n  localparam  S_ON     = 2'b10;\n  localparam  S_GO_OFF = 2'b11;\n\n  // State FlipFlop\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n    end\n    else begin\n      state <= nextstate;\n    end\n  end\n\n  //Nextstate Logic\n  always @* begin\n    case (state)\n      2'd0 : if (turn_on) begin\n        nextstate = S_GO_ON;\n      end\n      2'd1 : nextstate = S_ON;\n      2'd2 : if (turn_off) begin\n        nextstate = S_GO_OFF ;\n      end\n      2'd3 : nextstate = S_OFF;\n    endcase\n  end    \n\n//TB clk\ninitial begin\n #1ns;\n clk = 0;\n forever begin\n  #20ns;\n  clk = ~clk;\n end\nend\n\n//The Test\ninitial begin\n  rst_n    = 1'b0;\n  turn_on  = 1'b0;\n  turn_off = 1'b0;\n  @(posedge clk);\n  @(posedge clk);\n  rst_n = 1'b1 ;\n\n  @(posedge clk);\n  turn_on = 1'b1;\n  @(posedge clk);\n  turn_on = 1'b0;\n\n  @(posedge clk);\n  @(posedge clk);\n  #100ms;\n\n  $finish();\nend\nendmodule\n```\n\n\nExecute with :\n\n```\n$ irun simple_fsm.sv -coverage all -covdut simple_fsm\n$ imc &\n```\n\n\nLoad cov_work (folder created by above simulation) in imc, select simple_fsm and choose FSM Analysis.\n\n![simple_fsm visualisation](https://i.stack.imgur.com/s1I4S.png)\n\nimc also helps to visualise your test coverage as well. Arcs and states that have not been hit are shown in red.\n\nWe have seen that there are some tools which can visualise the FSM, another part of the question is; is the syntax of the purposed FSM suitable for these tools.\n\n@vermaete has reported that Modelsim SE can not see the FSM. From imc I get :\n\n![OPs FSM from Question](https://i.stack.imgur.com/IeALe.png)\n\nWhich does not seem to cover the complexity of the code, and is shown as only having 2 reachable states, IDLE and BUSY. I would recommend if OP is going down the route of using tools to visualise, adopt a simpler (syntax) FSM structure so that the tools can parse it better.\n", "accept": true, "score": 3}, {"body": "```\ncase(segmentRead)\n            //-------------------\n            SEGMENT0: begin\n                READ_Ready_EEPROM <= 1'b0;\n                READ_RDSR_Enable <= 1'b0;\n                Read_Enable <= 1'b0;\n                READ_RDSR_DATA_REG <= 8'b0;\n//              READ_DATA_REG <= 8'b0;\n            end \n            //-------------------\n            SEGMENT2: begin          \n                READ_RDSR_Enable <= 1'b1;\n                READ_RDSR_DATA_REG <= 8'b0;\n            end\n//          //-------------------\n            SEGMENT3: begin          \n                READ_RDSR_Enable <= 1'b0;   \n                READ_RDSR_DATA_REG <= RDSR_Data;\n            end\n            //-------------------\n            SEGMENT4: begin\n                Read_Enable <= 1'b1;\n            end\n            //-------------------\n            SEGMENT5: begin\n                Read_Enable <= 1'b0;\n                READ_DATA_REG <= Read_Data;\n            end\n            //-------------------\n            SEGMENT6: begin\n                READ_Ready_EEPROM <= 1'b1;\n            end\n            //-------------------\n        endcase\n```\n\n", "accept": false, "score": 1}], "score": [1.43573330739833e-243, 7.167808136500982e-245, 6.0, 1.2665905001628234e-232]}
{"question": "How do I read an environment variable in Verilog ? (Running on a VCS simulator)\n\nI am trying to accomplish\n\n```\nFile=$fopen(\"$PATH/FileName\",\"r\");\n```\n\n\n$PATH is an environment variable.\n", "answer": [{"body": "You can use a simple PLI application to read an environment variable. Here's a sample, without any error checks:\n\n```\n#include <stdlib.h>\n#include <string.h>\n\n#include \"vpi_user.h\"\n\nPLI_INT32 pli_getenv (PLI_BYTE8 * arg) {\n\n    vpiHandle tf_obj = vpi_handle (vpiSysTfCall, NULL);\n    vpiHandle arg_iter = vpi_iterate (vpiArgument, tf_obj);\n\n    vpiHandle arg1, arg2;\n    arg1 = vpi_scan (arg_iter);\n    arg2 = vpi_scan (arg_iter);\n\n    s_vpi_value vi, vo;\n    vi.format = vpiStringVal;\n    vpi_get_value (arg2, &vi);\n\n    vo.format = vpiStringVal;\n    vo.value.str = strdup (getenv (vi.value.str));\n    vpi_put_value (arg1, &vo, NULL, vpiNoDelay);\n\n    return 0;\n}\n```\n\n\nThe VCS documentation should explain how to link this into the simulator.\n", "accept": false, "score": 2}, {"body": "You can simply use SystemVerilog DPI for getting environment.\nAnd because `getenv` is a standard C library for every POSIX platform, so you do not need to implement your own `getenv()` equivalent function for the function definition again.\n\nExample code in SV.\n\n```\nimport \"DPI-C\" function string getenv(input string env_name);\n\nmodule top;\n\n  initial begin\n    $write(\"env = %s\\n\", {getenv(\"HOME\"), \"/FileName\"});\n  end\nendmodule\n```\n\n\nRunning\n\n```\nncverilog -sv dpi.v\n```\n\n\nor\n\n```\nvcs -sverilog dpi.v\n```\n\n\nIt will show\n\n```\nenv = /home/user/FileName\n```\n\n\nAnd one more issue in your original question, PATH is a environment for executable search path and concatenate with \":\" character. I think it should be an example here, not really \"PATH\" environment. Otherwise, your fopen file name could be `\"/bin:/usr/bin:/usr/local/bin/FileName\"`, which is wrong.\n", "accept": true, "score": 14}, {"body": "It is often simpler to use the Verilog preprocessor\n\n```\nFile = $fopen(`PATH_FILENAME, \"r\");\n```\n\n\nThen invoke the simulator from your Makefile/shell script the specifying value to be substituted\n\n`$(SIM) -DPATH_FILENAME=\\\"$PATH/FileName\\\" blah.v ...`\n\nI use this with Icarus' `iverilog` often, `vsim` and friends probably support similar.\n\nQuotes are escaped so that they are included in the substituted value, since the preprocessor will not substitute inside a literal value. For instance this combination does :\n\n```\nFile = $fopen(\"`PATH_FILENAME\", \"r\");\n```\n\n\n...\n\n```\n`$(SIM) -DPATH_FILENAME=$PATH/FileName blah.v ...`\n```\n\n", "accept": false, "score": 1}, {"body": "Here I can see all answers, either they are using some DPI Or need some command line arguments. So I am sharing my answer with  syntax.  Answer is . But surely it is for Linux environment; for other OS we need to change  commands.\n> We need to set this \"logPath\" system variable using some pre\nprocessing script or by simulation script before we start our\nsimulation.\n```\nstring myPath;\n\n initial begin\n     //Writing System Variable To A File\n     $system(\"echo ${logPath} > logPath.txt\");\n\n     //Opening that file and reading to a string variable\n     fh = $fopen (\"./logPath.txt\", \"r\");\n     void'($fscanf(fh,\"%s\",myPath));\n\n     //Appending File Name To That Path\n     myPath = {myPath,\"/note.txt\"};\n\n     //Closed and remove this temporary file\n     $fclose(fh);\n     $system(\"rm -rf logPath.txt\");\n      \n     //Open a file at the path that you have extracted from System Variable\n     //Do whatever you want now \n     fh = $fopen (myPath, \"w\");\n     \n     repeat(10) begin\n         $fdisplay (fh, \"%t %M: Write Line Number =|%0d| \", $time, i);\n         i++;\n     end\n\n     $fclose(fh);\n  end\n```\n\n", "accept": false, "score": 0}], "score": [1.7638978249988845e-155, 28.0, 6.164634626971142e-156, 0.0]}
{"question": "I'm trying to create a synthesizable, parametrized priority encoder in Verilog. Specifically, I want to find the least significant 1 in a vector and return a vector containing just that 1. For example:\n\n```\nIN[3:0] | OUT[4:0]\n--------+---------\n1010    | 00010\n1111    | 00001\n0100    | 00100\n0000    | 10000   (special case)\n```\n\n\nSo if the vectors are four bits wide, the code is:\n\n```\nif (in[0]==1'b1) least_one = 1;\nelse if (in[1]==1'b1) least_one = 2;\nelse if (in[2]==1'b1) least_one = 4;\nelse if (in[3]==1'b1) least_one = 8;\nelse out = 16; // special case in==0, set carry bit\n```\n\n\nI need a general, scalable way to do this because the input/output vector length is parametrized. My current code is:\n\n```\nmodule least_one_onehot\n#(parameter ADDR_WIDTH=4)\n(output reg [ADDR_WIDTH:0] least_one,\ninput [ADDR_WIDTH-1:0] in);\n\ngenvar i;\n\nalways @(in) begin\n    if (in[0]==1'b1) least_one = 1;\n    generate for (i=1; i<ADDR_WIDTH; i=i+1) begin : U \n        else if (in[i]==1'b1) least_one = 2**i; \n        end \n        endgenerate\n    else least_one = 2**ADDR_WIDTH;\n    end\n\nendmodule\n```\n\n\nWhen I try to compile this, I receive the following errors:\n\n```\nfile: least_one_onehot.v\n        generate for (i=1; i<ADDR_WIDTH; i=i+1) begin : U\n               |\nncvlog: *E,GIWSCP (least_one_onehot.v,10|8): Generated instantiation can only be valid within a module scope [12.1.3(IEEE 2001)].\n                        else if (in[i]==1'b1) least_one = 2**i; \n                           |\nncvlog: *E,NOTSTT (least_one_onehot.v,11|6): expecting a statement [9(IEEE)].\n                endgenerate\n                          |\nncvlog: *E,GIWSCP (least_one_onehot.v,13|12): Generated instantiation can only be valid within a module scope [12.1.3(IEEE 2001)].\n                else least_one = 2**ADDR_WIDTH;\n                   |\nncvlog: *E,NOTSTT (least_one_onehot.v,14|5): expecting a statement [9(IEEE)]\n```\n\n\nI've tried various arrangements of the generate, if, and always statements, all without success. Anyone know the proper syntax for this? Case-statement implementation or other alternatives would also be fine. Thanks.\n", "answer": [{"body": "I think you misunderstand how generate works.  It isn't a text pre-processor that emits the code in between the generate/endgenerate pair with appropriate substitutions.  You have to have complete syntactic entities withing the pair.  I don't have access to a simulator right this minute but this might do the trick for you (totally untested)\n\n```\ngenvar i;\ngenerate\n    for (i = 1; i < ADDR_WIDTH; i = i + 1) begin : U\n        least_one[i] = in[i] & ~|in[i - 1:0];\n    end\nendgenerate\nleast_one[0] = in[0];\nleast_one[ADDR_WIDTH] = ~|in;\n```\n\n\nOrdinarily Verilog would complain about the non-constant bit slice width but since it's within a generate loop it might work.\n\nFailing something like the above you just test for the first set bit in a for-loop and then decode that result.\n", "accept": true, "score": 2}, {"body": "You do  need a generate block. You could use:\n\n```\ninteger i;\nreg found;\nalways @(in) begin\n  least_one = {(ADDR_WIDTH+1){1'b0}};\n  found = 1'b0;\n  for (i=0; i<ADDR_WIDTH; i=i+1) begin\n    if (in[i]==1'b1 && found==1'b0) begin\n      least_one[i] = 1'b1;\n      found = 1'b1;\n    end\n  end\n  least_one[ADDR_WIDTH] = (found==1'b0);\nend\n```\n\n\nIf you really want to use a generate block, then you need to assign each bit.\n\n```\nassign least_one[0] = in[0];\nassign least_one[ADDR_WIDTH] = (in == {ADDR_WIDTH{1'b0}});\ngenvar i;\ngenerate\n  for (i=1; i<ADDR_WIDTH; i=i+1) begin : U\n    assign least_one[i] = in[i] && (in[i - 1:0] == {i{1'b0}});\n  end\nendgenerate\n```\n\n", "accept": false, "score": 1}, {"body": "This simulates the way you want it to, but it is not synthesizable (you didn't specify if that was a requirement):\n\n```\nmodule least_one_onehot #(parameter ADDR_WIDTH=4) (\n    output reg [ADDR_WIDTH-1:0] least_one,\n    input      [ADDR_WIDTH-1:0] in\n);\n\nalways @* begin\n    least_one = '0;\n    for (int i=ADDR_WIDTH-1; i>=0; i--) begin\n        if (in[i]) least_one = 2**i;\n    end\nend\n\nendmodule\n```\n\n\nNote that it uses SystemVerilog constructs.\n", "accept": false, "score": 1}, {"body": "Personally, I like the following block of code for what you need:\nassign out = {1'b1,in} & ((~{1'b1,in})+1);\n\nYou could try this (dropping the extra high bit for legibility), but I like to explicitly do the twos compliment to avoid any potential compatibility problems.\n\nassign out = in & (-1*in);\n", "accept": false, "score": 1}], "score": [4.0, 5.306332692460954e-156, 0.020727742570544324, 1.4199952756451334e-236]}
{"question": "I have a preprocessor macro that represents a hierarchical path into my design.\n\nExample:\n\n```\n`define HPATH top.chip.block\n```\n\n\nI need to construct a string which holds the value of ``HPATH`, so in my example the string should equal `top.chip.block`.\n\nIs there a way to construct such a string? \n\nNone of the following attempts worked:\n\n```\nstring hpath;\nhpath = \"`HPATH\";     // Results in hpath = \"`HPATH\"\nhpath = \\\"``HPATH\\\";  // Doesn't compile\nhpath = `HPATH;       // Doesn't compile\n```\n\n\nI want `hpath` to be equivalent to doing this assignment `hpath = \"top.chip.block\"`, but by using ``HPATH` instead of specifying the path again.\n\nI cannot use `%m` because I need the string within my top-level UVM environment, not within a module.\n\nA little more background: the reason I want to do this is because I am using backdoor register access in the UVM class library. The backdoor API requires setting the hdl_path to the blocks within the design, as a string. I already have `defines for the hierarchical paths and am trying to reuse those when specifying the hdl_paths so I don't have the same path defined twice. My testbench will use both the hierarchical path and the string path.\n", "answer": [{"body": "I think this is what you're looking for.\n\n```\n`define HPATH `\"top.chip.block`\"\nstring hpath = `HPATH;\n```\n\n\nAs toolic pointed out, the escape sequence %m will give you the current hierarchy when used in a $display statement so that may be a better option.\n", "accept": false, "score": 1}, {"body": "It's not possible to use a `define macro within a string literal. According to the SystemVerilog LRM:\n\n> Macro substitution and argument substitution shall not occur within string literals.\n\nHowever a string literal can be constructed by using a macro that takes an argument and including the quotes in the macro by using ``\"`.\n\nAgain, from the LRM:\n\n> An `\" overrides the usual lexical meaning of \" and indicates that the expansion shall include the quotation\n  mark, substitution of actual arguments, and expansions of embedded macros. This allows string literals to be\n  constructed from macro arguments.\n\nSo this works:\n\n```\n`define STRINGIFY(x) `\"x`\"\n`define HPATH top.chip.block\nstring hpath = `STRINGIFY(`HPATH);\n$display(hpath);                       // Output: \"top.chip.block\"\n```\n\n\nThe example code can be run here: [http://www.edaplayground.com/s/4/879](http://www.edaplayground.com/s/4/879)\n", "accept": true, "score": 25}, {"body": "The use of `$sformatf` allows additional information to be added if needed.\n```\n`define STRINGIFY(DEFINE) $sformatf(\"%0s\", `\"DEFINE`\")\n```\n\n", "accept": false, "score": 2}, {"body": "`define   HPATH  top.chip.block\nstring    hpath = `\"`HPATH`\";\nHope it helps.\n", "accept": false, "score": 0}], "score": [1.401426439262683e-157, 50.0, 4.834421297450319e-159, 0.0]}
{"question": "As in the title, what are the main differences between structural and behavioural Verilog?\n", "answer": [{"body": "There is no strict definition of these terms, according to the IEEE Std.  However, customarily,  refers to describing a design using module instances (especially for the lower-level building blocks such as AND gates and flip-flops), whereas  refers to describing a design using `always` blocks.\n\nGate netlists are always , and RTL code is typically .  It is common for RTL to have instances of clock gates and synchronizer cells.\n", "accept": true, "score": 12}, {"body": "\n\n> Here functions are defined using basic components such as an invertor,\n  a MUX, a adder, a decoder, basic digital logic gates etc..  It is just\n  like connecting and arranging different parts of circuits available to\n  implement a function.\n\n\n\n> The Behavioral description in Verilog is used to describe the function\n  of a design in an algorithmic manner. Behavioral modeling in Verilog\n  uses constructs similar to C language constructs. Further , this is\n  divided into 2 sub categories .\n\n- \n\n> assignment of data to outputs are continuous.  This will be\n  implemented using explicit \"assign\" statements   or   by assigning a\n  value to a  wire during its declaration  . \n  In case of assign any change in input will\n  immediately effect the output . Hence output is to be declared as\n  `wire`\n\n- \n\n> Here the data assignments are not carried out continuously instead it\n  happens on specific events specified in sensitivity list. This type of\n  modelling scheme is implemented using procedural blocks such as\n  \"always\"or \"initial\" .Here, output variables must be defined as `reg` because they need to\n  keep hold of previous value until new assignment occurs after any change in specified sensitivity list.\n\nHope this helps  :)\n", "accept": false, "score": 9}, {"body": "Structural Verilog is usually referred to a Verilog code which is synthesizable (has an accurate and meaningful hardware realization) and is usually written in Register Transfer Level (RTL).\nOn the other hand Behavioral Verilog is usually a behavioral description of a hardware or functionality on a higher level. behavioral code does not have to be synthesizable for example when you define a delay in your verilog code scaled by the timescale, the synthesizer does not consider it when it is translating your code into logic and hardware, but rather it has simulation purposes.\nThe same goes for structural and behavioral VHDL.\n", "accept": false, "score": 0}, {"body": "Behavioral doesn't use logic gates description you can use And,Or,Not gates that are already defined in verilog\nwhile structural uses logic gates description where you describe that you want a module called (And/Or/Not) and describe what it does & / | / ~.\n", "accept": false, "score": 0}, {"body": "Structural verilog deals with the primitives in simple word like and, or, not etc..\nThe primitives are called/inferred from libraries and connected with input output ports.\nExample\n\n```\nmodule structural(y,a,b);\n    input a,b;\n    output y;\n    and a1 (y,a,b); // and is the primitive inferred and a1 is the instance name.\n endmodule\n```\n\n\nBehavioral verilog deals with the logic or behavior of a system. It handles complex logic implementation and which is why in industry all implement the behavioral models of the system called as RTL. Once the behavioral RTL is validated by front end engineers using SV/UVM then this RTL is converted into Gate Level i.e Structural which go for synthesis.\n\nPlease refer the book of verilog written by Samir Palnitkar for more details.\n", "accept": false, "score": 0}, {"body": " is both a behavioral and a structural language. Internals of each module can be defined at four levels of abstraction, depending on the needs of the design.\nStructural Verilog describes how a module is composed of simpler modules or of basic primitives such as gates or transistors. Behavioral Verilog describes how the outputs are computed as functions of the inputs.\n\n->This is the highest level of abstraction provided by Verilog HDL. mainly construct using\n\"always\" and \"initial\" block.\n\n-> At this level, the module is designed by specifying the data flow. condition describe using \"assign\" keyword.\n\n->The module is implemented in terms of logic gates and interconnections between\nthese gates.\n\n->This is the lowest level of abstraction provided by Verilog. A module can be\nimplemented in terms of switches, storage nodes, and the interconnections\nbetween them.\n", "accept": false, "score": 0}], "score": [24.0, 9.0, 0.0, 0.0, 0.0, 0.0]}
{"question": "Say the following code section (same block):\n\n```\nA <= 1\nA <= 2\n```\n\n\nWill variable A always be assigned 2? or will there be a race condition and 1 or 2 will be assigned ?\n\nMy understanding of non blocking assignment is that it is up to the hardware to assign the variable A at a future time so it could be a random result. However, this is non intuitive. Simulations show that 2 always get assigned, but I would like to know if this is  the case for hardware synthesis.\n", "answer": [{"body": "According to the \"Determinism\" section in the IEEE Std (1800-2009, for example), if those statements are in a begin-end block, A will always be assigned the value 2 in simulation.\n\nHowever, the Std does not guarantee how the code will be synthesized.  The resultig gates probably depend on the synthesis tool.  But, a good RTL linting tool will identify such bad coding.  Cadence's Hal lint tool issues a warning.\n", "accept": false, "score": 1}, {"body": "from RTL point of view.\n\"A\" will be assigned 1 and 2 ,it can be first 1 and then 2 or vice versa, but you can't really know which value will be assigned in the end of begin-end block it can be 1 or 2 (as the second value which was assigned).\n", "accept": false, "score": -5}, {"body": "A would be 2 in simulation, the last defined value takes effect. If they are not in the same block then there could be a race condition depending on the simulator scheduler as to which was defined last in simulation.\n\nI have seen this technique used quite a lot and never seen any unexpected results after synthesis.\n\nFrom Verilog IEEE 1364-2005 Section 11.4.1 Determinism\n\n> Statements within a begin-end block shall be executed in the order in which they appear in that begin-end block. Execution of statements in a particular begin-end block can be suspended in favor of other processes in the model; however, in no case shall the statements in a begin-end block be executed in any order other than that in which they appear in the source.\n\nThis is also in SystemVerilog-IEEE1800 2012 as section 4.6 Determinism\n\nUsage of this might be a FSM which sparsely defines its outputs:\n\n```\nalways @(posedge clk) begin\n  out_one <= 1'b0;\n  out_two <= 1'b0;\n  out_thr <= 1'b0;\n  case (state)\n    2'd1 : out_one <= 1'b1;\n    2'd2 : out_two <= 1'b1;\n    2'd3 : out_thr <= 1'b1;\n  endcase\nend\n```\n\n", "accept": true, "score": 14}, {"body": "There is nothing nondeterministic about the final value of `A` in your code, not for simulation, not for synthesis.\n\nHowever, to be absolutely exact, there is a possible simulation-synthesis-mismatch if the design contains a trigger on `A`. Consider the following example:\n\n```\nmodule test(input clk, output reg a, b);\n  always @(posedge clk) begin\n    a <= 0;\n    a <= 1;\n  end\n\n  initial b = 0;\n  always @(posedge a) begin\n    b <= !b;\n  end\nendmodule\n```\n\n\nAnd a test bench:\n\n```\nmodule tb;\n  reg clk = 0;\n  always #5 clk = ~clk;\n\n  wire a, b;\n  test uut (clk, a, b);\n\n  initial begin\n    $monitor(\"clk=%b a=%b b=%b\", clk, a, b);\n    repeat (100) @(posedge clk);\n    $finish;\n  end\nendmodule\n```\n\n\nDuring simulation both updates `a <= 0` and `a <= 1` are pushed to the NBA events region and are executed in-order, so `a` always ends up being set. However, as the `a <= 0` is executed as well, there is a negative pulse with zero width on `a` for every clock cycle. This pulse triggers the 2nd always block. This is the simulation output (tested with Icarus Verilog and Modelsim):\n\n```\nclk=0 a=x b=0\nclk=1 a=1 b=1\nclk=0 a=1 b=1\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=1\nclk=0 a=1 b=1\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=1\nclk=0 a=1 b=1\nclk=1 a=1 b=0\nclk=0 a=1 b=0\n...\n```\n\n\nHowever, in synthesis this will simply assign `a` the constant value 1 and `b` the constant value zero. (Tested with Yosys and Xilinx Vivado.) So the post-synthesis simulation output looks like this:\n\n```\nclk=0 a=1 b=0\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=0\nclk=0 a=1 b=0\nclk=1 a=1 b=0\n```\n\n\n(Theoretically the first line could still say `a=x`, but every decent synthesis tool would optimize the `a`-flip-flop away, as both tools in the test did.)\n\nOther than that there is no potential issue with that code, and as @Morgan pointed out correctly in his answer, this is a very usual coding technique for defining the \"default values\" of output signals before encoding the special cases using conditional assignments (using `if` and/or `case`).\n", "accept": false, "score": 9}], "score": [6.98488814306257e-235, -5.604991089404664e-237, 28.0, 18.0]}
{"question": "I'm trying to build a StateMachine for a 1-hot-encoded simple LED switch button.\n\nEspecially I'm trying to understand blocking and nonblocking assignments with my example.\n\nWould you thing the following could be done better, or is completely wrong in any block?\n\n```\nmodule example (\n  input clk,\n  input rst,\n  input push,\n\n  output reg led_on\n);\n\n\nreg on;\nreg off;\n\nreg t_on_off;\nreg t_off_on;\n\n\nalways @* begin\n  t_on_off = on & (push);\nend\n\nalways @* begin\n  t_off_on = off & (push);\nend\n\n\nalways @(posedge clk or posedge rst) begin\n  if (rst)              on <= 1'b0;\n  else if (t_off_on)    on <= 1'b1;\n  else if (t_on_off)    on <= 1'b0;\nend\n\nalways @(posedge clk or posedge rst) begin\n  if (rst)              off <= 1'b1;\n  else if (t_off_on)    off <= 1'b0;\n  else if (t_on_off)    off <= 1'b1;\nend\n\n\nalways @* begin\n  led_on = on;\nend\n\n\nendmodule\n```\n\n\nEspecially I'd like to know: could I combine the assignments of the transitions into one single block, like:\n\n```\nalways @* begin\n  t_on_off = on & (push);\n  t_off_on = off & (push);\nend\n```\n\n\n?\n", "answer": [{"body": "> Especially I'd like to know: could I combine the assignments of the transitions into one single block, like...\n\nYes, you can do that exactly as you have described.\n\nYou can also combine the sequential blocks as well if you want:\n\n```\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n     on  <= 1'b0;\n     off <= 1'b1;\n  end else if (t_off_on) begin\n     on  <= 1'b1;\n     off <= 1'b0;\n  end \n  (etc....)\nend\n```\n\n", "accept": false, "score": 1}, {"body": "Yes, you may combine multiple  blocks into one.\n\nYou just need to separate out your synchronous (clocked ones) and asynchronous blocks into separate  blocks.\n\nHowever, a good style is to have an  block for each individual output. This is easier to read and more real-world like as each  block is concurrent with each other.\n", "accept": false, "score": 1}, {"body": "If it does not need to be one-hot, then simplify it to:\n\n```\nmodule example (\n  input clk,\n  input rst,\n  input push,\n\n  output reg led_on\n);\n\nalways @(posedge clk or posedge rst) begin\n  if (rst)        led_on  <= 1'b0;\n  else if (push)  led_on  <= !led_on;\nend\n\nendmodule\n```\n\n\nIt is functional equivalent to what you have and more readable.\n", "accept": true, "score": 4}, {"body": "Refactoring Suggestion:\n\n```\noutput reg led_on;\n\nalways @* begin\n  led_on = on;\nend\n```\n\n\nto:\n\n```\noutput led_on; //wire by default (not declared reg)\n\nassign led_on = on;\n```\n\n\nYou could also do the same with your `t_on_off` and `t_off_on`\n\n```\nwire t_on_off;\nwire t_off_on;\n\nassign t_on_off = on  & (push);\nassign t_off_on = off & (push);\n```\n\n\nOr if you prefer roll the declare and assign in one line.\n\n```\nwire t_on_off = on  & (push);\nwire t_off_on = off & (push);\n```\n\n\nBut if you are rolling the two clocked always blocks into one there is no need for the separate logic, combining @Tim's answer with the t_on_off check:\n\n```\nmodule example (\n  input clk,\n  input rst,\n  input push,\n\n  output reg led_on\n);\n\nreg on;\nreg off;\n\nassign  led_on = on;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    on  <= 1'b0;\n    off <= 1'b1;\n  end\n  else if (off & push) begin\n    on  <= 1'b1;\n    off <= 1'b0;\n  end\n  else if (on  & push) begin\n    on  <= 1'b0;\n    off <= 1'b1;\n  end\nend\n\nendmodule\n```\n\n", "accept": false, "score": 1}, {"body": "This has been far in the past already, but the solutions presented are perhaps not exactly what you were expecting. From what I could infer the solutions all consider that the LED will keep toggling as long as the pushbutton is being pressed (i.e. it will toggle at the clock's frequency), making it visually imperceptible if the clock frequency is high. However, I assume you would want something which toggles the LED only once each time the pushbutton is pressed, with the LED state being preserved during this period.\n\nThe example below toggles the states of 3 LEDs based on the activity of 3 pushbuttons.\n\n\n1. led0 is activated whenever pbutton0 is pressed.\n2. led1 keeps toggling periodically (based on the size of clk_div) and is reset whenever pbutton1 is pressed.\n3. led2 is toggled whenever pbutton2 is pressed.\n\n\n\nNote that  is combinational, while the other two LEDs are sequential. For toggling , the previous state of  must be stored; whenever ==0 and ==1, that means the button has just gone from low to high and, thus, the state of  must change.\n\nLastly, please ignore the clock source, since this was only used to demo the code on the Xilinx SP605 development kit.\n\n```\n////////////////////////////////////////////////////\n// This project uses 3 pushbuttons and 3 LEDs.\n//  pbutton0 activates led0\n//  pbutton1 serves as reset for led1 periodic toggling\n//  pbutton2 toggles led2\n//\n// The clock source (divider+buffer) was created using the clocking IP wizard.\n//\n\nmodule xilinx_sp605_board_leds\n(\n    input CLK_IN1_P,\n    input CLK_IN1_N,\n\n    input pbutton0,\n    input pbutton1,\n    input pbutton2,\n\n    output led0,\n    output reg led1,\n    output reg led2\n);\n\n// declarations\nwire clk;\nwire reset = pbutton1;\nreg [19:0] clk_div;\nreg pbutton2_reg;\n\n// led0 = state of pbutton0\nassign led0 = pbutton0;\n\n// differential clock divider+buffer\nclk_source CLK_SOURCE (\n    .CLK_IN1_P(CLK_IN1_P),\n    .CLK_IN1_N(CLK_IN1_N),\n    .CLK_OUT1(clk),\n    .RESET(reset));\n\n// led1, led2 toggling\nalways @(posedge reset or posedge clk)\nbegin\n    if(reset)begin\n        clk_div <= 0;\n        led1 <= 0;\n\n        pbutton2_reg <= 0;\n        led2 <= 0;\n    end else begin\n        clk_div <= clk_div + 1;\n        if(clk_div==0) \n            led1 <= ~led1;\n\n        pbutton2_reg <= pbutton2;\n        if(~pbutton2_reg && pbutton2)\n            led2 <= ~led2;\n    end\nend\n\nendmodule\n```\n\n", "accept": false, "score": 0}], "score": [6.223879390663412e-157, 1.240588459745144e-237, 8.0, 2.0, 0.0]}
{"question": "I am trying to use Quartus II 13.0 (Free Web Package) on Linux (Kubuntu 12.04 LTS) from the command line to generate Verilog technology netlists from Verilog RTL. I need this for a project where I compare the synthesis results produced by different tools for thousands of generated Verilog files. So using the GUI is not really an option..\n\nFor example with Xilinx Vivado I can do that using the following TCL commands:\n\n```\nread_verilog input.v\nsynth_design -part xc7k70t -top top_module\nwrite_verilog output.v\n```\n\n\nMost ASIC tools I have worked with provide similar interfaces.\n\nWith Xilinx XST it is a bit more complicated:\n\n1.) generation of a work.xst file:\n\n```\nrun -ifn work.prj ..some..more..options..\n```\n\n\n2.) generation of a work.prj file:\n\n```\nverilog work \"input.v\"\n```\n\n\n3.) running synthesis:\n\n```\nxst -ifn work.xst\n```\n\n\n4.) generating verilog netlist from verilog binary:\n\n```\nnetgen -w -ofmt verilog work.ngc output\n```\n\n\nBut with Quartus II I can't find any documentation at all on how to use the command line tools. All I can find is documentation to the graphical IDE interface. Maybe I'm just looking in the wrong places?\n\nSo before I start poking the Quartus II IDE with strace and similar tools: Is anyone using Quartus II from the command line and can point me in the right direction?\n", "answer": [{"body": "It's very well hidden - Quartus-II Handbook Version 13.0, page 2-10 (or search ASSIGNMENT_FILES) - produces one example Makefile. It seems to have bit-rot - I've removed the ASSIGNMENT_FILES stuff, and the stamps are redundant (you can check for logfiles), but it's a start, and the basic structure works.\n", "accept": true, "score": 5}, {"body": "For example the following shell script synthesizes the module `binary_ops_00000000` from the design file `binary_ops_00000000.v`:\n\n```\nPATH=$PATH:/opt/altera/13.0/quartus/bin\nquartus_map binary_ops_00000000 --source=binary_ops_00000000.v --family=\"Cyclone III\" \nquartus_fit binary_ops_00000000\nquartus_eda binary_ops_00000000 --formal_verification --tool=conformal\ncp -v fv/conformal/binary_ops_00000000.vo output.v\n```\n\n\n`quartus_eda` supports a wide range of differend modes (see `quartus_eda --help=tool` for a table). The Verilog generated for Conformal LEC looks fine for my purpose.\n\nI'd recommend running this commands in an otherwise empty directory, as they generate a bunch of files and in some cases print error messages if files from previous runs (with different setting) are found.\n", "accept": false, "score": 4}, {"body": "You can find helpful Quartus II Tcl Examples page on [intel.com](https://www.intel.com/content/altera-www/global/en_us/index/support/support-resources/design-examples/design-software/tcl.html).\n", "accept": false, "score": 3}, {"body": "You can also use the following to get help on both all command-line arguments and Tcl functions\n\n```\nquartus_sh --qhelp\n```\n\n", "accept": false, "score": 2}], "score": [10.0, 4.0, 3.0, 2.0]}
{"question": "Let's take the example code below:\n\n```\nalways @(posedge clock)\n   begin\n   if (reset == 1)\n     begin\n        something <= 0\n     end\n   end\n```\n\n\nNow let's say reset changes from 0 to 1 at the same time there's a posedge for the clock. Will something <= 0 at that point? Or will that happen the next time there's a posedge for the clock (assuming reset stays at 1)?\n", "answer": [{"body": "It depends on exactly how `reset` is driven.\n\nIf `reset` and `something` are both triggered off the same clock, then something will go to 0 one clock cycle after reset goes to 1.  For example:\n\n```\nalways @(posedge clock)\n   begin\n   if (somethingelse)\n     begin\n        reset <= 1;\n     end\n   end\n```\n\n", "accept": true, "score": 3}, {"body": "If `reset` is synchronous and based on `clock`, The simulatore will defiantly see reset on the next clock and not the current. Physical design has clock-to-Q, therefor a rise in reset will not be observed in the same clock that caused it. You may see reset at the same time as clock in waveform. `reset <= 1'b1;` make the assignment happen near the end of the scheduler (after all code has executed). \n\nTo not have to worry about this when looking at a waveform, some logic designers like to put a delay on the assignment creating an artificial clock-to-Q delay (ex `reset <= #1 1'b1;` and `something <=#1 0;`). Synthesis tools will ignore the delay, but some will give warnings. That warning can be avoided by using a macro.\n\n```\n`ifdef SYNTHESIS\n`define Q   /* blank */\n`else\n`define Q #1\n`endif\n...\nreset <= `Q 1'b1;\n...\nsomething <=`Q 1'b1;\n...\n```\n\n\nIf `reset` is asynchronous and being use with synchronous reset, setup time requirements need to be respected. In simulation if clock and reset rise at the same time, it is up to your verilog scheduler to decide if reset will be the new value or old value. Usually it will take the left-hand side value (old value), which means the reset will be missed on the current clock. Physical design uncertainly as well with a meta-stability risk.\n", "accept": false, "score": 3}, {"body": "The short answer is that either of your two outcomes (immediately, or next cycle) could happen. This is a standard race condition, and simulators are free to handle this any way they want; some will give one answer, and others will give the other one.\n\nFor the long answer, look up any introductory text on how VHDL delta cycles work. Verilog doesn't specify 'delta cycles', but any Verilog simulator will work in exactly the same way, with some (irrelevant) changes in the overall scheduling algorithm. In this case, the scheduler finds that it has two events on the queue in a specific delta - reset rising, and clock rising. This is what \"at the same time\" means. It chooses one in an unspecified way (it might be earlier in the text source, or later, for example), works through all changes associated with that edge, and then goes back and works through all changes associated with the other edge.\n", "accept": false, "score": -1}, {"body": "The code you have written infers a flip-flop with synchronous reset. This means it is assumed that the \"reset\" signal is synchronised to the \"clock\" domain before being used in this way. If the \"reset\" signal is not synchronised then you should modify the code to infer a flip-flop with asynchronous reset as below:\n\n```\nalways@(posedge clock or posedge reset)\nbegin\n  if (reset)\n    something <= 0\n  else \n    something <= something_else\nend\n```\n\n\nComing back to your question and assuming the code you have written is what you want, the outcome depends on how the reset is driven. If it is synchronous then the simulator will see it in the next clock edge. If it is asynchronous then the simulator can assume anything, it can vary from simulator to simulator. Please note that in simulator everything is a sequence of events and there is no such thing as happening at the same time.\n\nIn the physical world, what you have coded will result in a flip-flop with reset signal being one of the inputs to the combo driving the input of this flop. Now if the reset is synchronous, you are guaranteed that there will be no setup or hold violation at this flop. Whether the flop will 'see' the reset in this clock or the next depends on the various delays of the synthesised circuit (Usually this is the main reason that the reset is always held for few clock cycles to make sure all the flops in your design sees the reset). If reset is asynchronous then the flop will go into a metastable state. You will never want this in your design.\nHope this clarifies.\n", "accept": false, "score": 1}], "score": [6.0, 1.0558165931315866e-231, -2.0, 1.4087348145552593e-155]}
{"question": "I'm coming from a Verilog-95 background, and I'm trying to figure out what Verilog-95 hoops I don't have to jump through anymore.\n\nThe obvious way to write a flip flop with async set and reset in Verilog-95 is:\n\n```\nalways @(posedge clk or negedge resetb or negedge setb) begin\n  if (!resetb)      q <= 0;\n  else if (!setb)   q <= 1;\n  else              q <= d;\nend\n```\n\n\nThis works in synthesis. But, this doesn't work in simulation if we ever assert both resetb and setb, and then de-assert resetb before de-asserting setb, since there's no posedge trigger for either of those signals. We need to add the following (which varies depending on your synthesis tool), to get simulation to match synthesis:\n\n```\n// synopsys translate_off\nalways @(resetb or setb)\n  if (resetb && !setb) force q = 1;\n  else               release q;\n// synopsys translate_on\n```\n\n\nIs there a SystemVerilog construct that will let you do this without this extra junk? Better yet, is there a straightforward way to do it in Verilog-95?\n", "answer": [{"body": "Try this:\n @(posedge clk or negedge resetb or negedge setb)\n\nsystemverilog uses always_ff for clock triggered logic and always_comb for combo logic\n", "accept": false, "score": -2}, {"body": "This is something I wish SystemVerilog had improved. If you want to allow both being low at the same time, then stick with the current method.\n\nThe other option is to create a design rule stating the asynchronous signals can not be active at the same time and enforce the rule with an assertion. Assertions are suppose to be ignored by synthesizers, so translate_off/on  be be necessary.\n\nHere is an example using an inline assertion:\n\n```\nalways_ff @(posedge clk, negedge resetb, negedge setb) begin : dff_asyncRbSb\n  if (!resetb)      q <= 0;\n  else if (!setb)   q <= 1;\n  else              q <= d;\n  asrt_setrst : assert(resetb||setb)\n     else $error(\"resetb and setb can not be low at the same time.\");\nend : dff_asyncRbSb\n```\n\n", "accept": false, "score": 3}, {"body": "Flip-flops with multiple asynchronous controls are best avoided. The timing checks necessary to ensure they function properly are complex and easy to mess up. If you really need to use them, then it's probably best to instantiate them by hand where needed. If you let your synthesis tool infer them, it may use them in places you don't intend, which increases the risk that the timing checks don't get done properly.\n\nOne final aside, there is a similar simulation-synthesis mismatch issue with all asynchronous flops, if the active edge of reset is at time zero and is simulated before the flop is initialized to x, and the clock isn't running in reset. I believe some simulators have special cases to ensure the logic is not initialized in this order.\n\nThat said, I had luck moving the priority logic outside the sequential `always` block. Note I'm using active-high signals for simplicity.\n\n```\nassign s_int = s && !c;\n\nalways @(posedge clk or posedge s_int or posedge c) begin\n        if (c)\n                q <= 1'b0;\n        else if (s_int)\n                q <= 1'b1;\n        else\n                q <= d;\nend\n```\n\n", "accept": true, "score": 4}, {"body": "I don't know any SV, so this isn't an answer, but the issue here is that\nVerilog (and, I think, SV) event expressions are basically broken. The problem\nis that, when you have multiple conditions in an event expression:\n\n```\nevent_expression ::=\n  expression \n  | hierarchical_identifier\n  | posedge expression\n  | negedge expression\n  | event_expression or event_expression\n  | event_expression , event_expression\n```\n\n\nthen there's no bullet-proof way to determine which expression caused the\nevent, since the only thing you can do is to check the current state of the\nexpression. So, if you've got `@(posedge clk, posedge rst)`, for example, you\nlook at the current levels of clk and rst and hope this is sufficient to do\nthe job. In general, it isn't, but your example is the only practical case (I\nthink) that causes a problem.\n\nVHDL handles this by having signal attributes, which let you determine whether\na signal has caused an event. In VHDL, you get an event when any signal in\nyour sensitivity list changes, and you then check their `'event` attribute to\ndetermine whether they fired the process. No confusion, no posedge or negedge,\nand it all works.\n\nI've just had a quick look at the SV LRM, and SV attributes appear to be the\nsame as Verilog attributes, so I think you're out of luck.\n", "accept": false, "score": 2}, {"body": "with no edge defined, the assertion and de-assertion of reset and set signals should be able to trigger this code in simulation.\n\n```\nalways_ff should be able to create a flop at synthesis.\n```\n\n\nBelow code is compilation clean using synopsys VCS tool.\n\n```\nalways_ff @(posedge clk, resetb,  setb) begin \n  if (!resetb)      q <= 0;\n  else if (!setb)   q <= 1;\n  else              q <= d;\nend\n```\n\n", "accept": false, "score": -1}], "score": [-1.0816905901010726e-234, 1.0333182062617245e-78, 8.0, 4.0, -0.020345196709700968]}
{"question": "I am trying to create a module which switches x input data packets to a single output packet according to a one hot input.\n\nIf x was a fixed value of 4, I would just create a case statement,\n\n```\ncase (onehot)\n  4'b0001  : o_data = i_data[0];\n  4'b0010  : o_data = i_data[1];\n  4'b0100  : o_data = i_data[2];\n  4'b1000  : o_data = i_data[3];\n  default  : o_data = 'z;\nendcase\n```\n\n\nBut with variable x, how do I define all cases?\n\nThanks.\n", "answer": [{"body": "```\nparameter X = 4;  \n\ninput [X-1:0] onehot;\ninput i_data [X];\noutput reg o_data;\n\nalways_comb \nbegin\n   o_data = 'z;\n   for(int i = 0; i < X; i++) begin\n      if (onehot == (1 << i))\n         o_data = i_data[i];\n   end\nend\n```\n\n", "accept": true, "score": 13}, {"body": "If you can assert that `onehot` is truly one-hot or 0, then you could use a generate\n\n```\npackage mytypes;\ntypedef logic [7:0] packet_t;\nendpackage \n\nmodule mux #(int X) (\n      input logic [X-1:0] onehot,\n      input mytypes::packet_t i_data[X],\n      output wire mytypes::packet_t o_data\n      );\nfor(genvar i=0;i<X;i++) begin\n   assign o_data = onehot[i] ? i_data[i] : 'z;\nend\nendmodule\n```\n\n", "accept": false, "score": 11}, {"body": "Here's a fully parameterized synthesizable mux optimized for a one-hot input (i.e. no priority encoding) using an OR tree. Note that the output is driven to 0 instead of 'z' if no input is enabled:\n\n```\nmodule mux\n #( parameter int unsigned inputs = 4,\n    parameter int unsigned width = 8 )\n  ( output logic [width-1:0] out,\n    input logic sel[inputs],\n    input logic [width-1:0] in[inputs] );\n\n    always_comb\n    begin\n        out = {width{1'b0}};\n        for (int unsigned index = 0; index < inputs; index++)\n        begin\n            out |= {width{sel[index]}} & in[index];\n        end\n    end\nendmodule\n```\n\n", "accept": false, "score": 4}, {"body": "I think 'wor' datatype is the real savior here.\nPlease find an example code:\n```\nmodule cnt64_shared\n   #(\n   parameter INSTANCES          = 6 // Number of shared istances\n   )\n(\n    input        [INSTANCES-1:0][31:0]  in_L_f      , // i - input\n    input        [INSTANCES-1:0]        in_sel_1hot , // i - input selection        \n\n        // clk and reset - add new signals before   \n   input                        clk                     , // i - clock\n   input                        rst_n                     // i - reset\n\n);\n\n    wor [31:0]  in_L_mux; \n\n    genvar i;\n        \ngenerate\n    for (i=0;i<INSTANCES;i=i+1) begin\n        assign in_L_mux = in_sel_1hot[i]    ?   in_L_f[i]   :   32'h0   ;  \n    end\nendgenerate\n\nendmodule\n```\n\n", "accept": false, "score": 0}], "score": [26.0, 1.3666592270553078e-78, 0.07292448029419388, 0.0]}
{"question": "I'm reaching my wits end trying to figure out why the simulated output is all X's. From looking up verilog issues all over the web it appears to me that most issues stem from reg vs wire mishaps however if feel it may still be the root of my woes. \n\nIf anyone could please tell what I'm doing wrong writing my module and the module's test bench it would be VERY appreciated. \n\nThe module is of piggy bank that increments it's credits in terms of coins or removes credits in terms of items purchased. I'm using an 8 bit accumulator. \n\nThe test bench is far from complete but I was just trying to get something besides \"x\"'s to no avail. Thanks again for you help.\n\n```\nmodule piggyBank(clk, reset, penny, nickel, dime, quarter, apple, banana, carrot, date,         credit);\n  input clk, reset, penny, nickel, dime, quarter;\n  input apple, banana, carrot, date;\n  output [7:0] credit;\n  reg [7:0] tmp;\n\n always @(posedge clk or posedge reset)\n begin\n   if (reset) \n     tmp = 8'b00000000; \n   if (penny || nickel || dime || quarter) \n     tmp = tmp + penny + (5 * nickel) + (10 * dime) + (25 * quarter); \n   if (apple || banana || carrot || date) \n     tmp = tmp - (apple * 75) - (20 * banana) - (30 * carrot) - (40 * date); \n end\n\n assign credit = tmp;\n\nendmodule\n\nmodule testPiggyB();\n  reg clk;\n  reg reset, penny, nickel, dime, quarter;\n  reg apple, banana, carrot, date;\n  wire [7:0] credit;\n\n  initial begin\n   clk <= 0;\n   forever #5 clk <= ~clk;\n   reset <= 0;\n   penny <= 0; nickel <= 0; dime <= 0; quarter <= 0;\n   apple <= 0; banana <= 0; carrot <= 0; date <= 0;\n\n\n   #5quarter <= 1;\n   #40 quarter <= 0;\nend\npiggyBank pb(.clk(clk), .reset(reset), .penny(penny) ,.nickel(nickel), .dime(dime),  .quarter(quarter), .apple(apple), .banana(banana), .carrot(carrot), .date(date), .credit(credit));\n\nendmodule\n```\n\n", "answer": [{"body": "Have you looked at the inputs to your simulation to make sure they are being toggled as you expect?\n\nYour piggyBank module seems ok, but I guess that your testbench may not be advancing beyond the forever clock statement, as it will keep executing this line forever and not advance beyond to the below statements. Therefore the quarter is never entered, and the module stays in it's unreset/unmodified state forever. \n\nTry putting the clock into a separate initial block.\n\n```\ninitial begin \n  clk = 0; \n  forever #5 clk = ~clk;\nend\n```\n\n\nAlso you never seem to assert the reset.\n\nFinally, you seem to be mixing up the blocking and nonblocking statements, though it shouldn't be fatal to the simulation in your case. Generally you would want your flip-flop to be using nonblocking assignments (<=), and your testbench sequential code to use blocking assignments (=). \n", "accept": true, "score": 3}, {"body": "I agree with Tim, \nas a guideline I recommend that when you describe clock triggered logic use non blocking assignment\n\n```\nalways @(posedge clk or posedge reset)\n begin\n   if (reset) \n     tmp <= 8'b00000000; \n   if (penny || nickel || dime || quarter) \n     tmp <= tmp + penny + (5 * nickel) + (10 * dime) + (25 * quarter); \n   if (apple || banana || carrot || date) \n     tmp <= tmp - (apple * 75) - (20 * banana) - (30 * carrot) - (40 * date); \n end\n```\n\n\nAlso in your Testbench what works for me is to have an initial block to set default values.\n", "accept": false, "score": 0}, {"body": "I agree with Tim and DOS. As Tim has said id you split the `initial` block and issue a `reset` then the TB should work fine at the current state. See the below code for reference. This works at my place.\n\n```\nmodule piggyBank(clk, reset, penny, nickel, dime, quarter, apple, banana, carrot, date,         credit);\n  input clk, reset, penny, nickel, dime, quarter;\n  input apple, banana, carrot, date;\n  output [7:0] credit;\n  reg [7:0] tmp;\n\n always @(posedge clk or posedge reset)\n begin\n   if (reset) \n     tmp <= 8'b00000000; \n   if (penny || nickel || dime || quarter) \n     tmp <= tmp + penny + (5 * nickel) + (10 * dime) + (25 * quarter); \n   if (apple || banana || carrot || date) \n     tmp <= tmp - (apple * 75) - (20 * banana) - (30 * carrot) - (40 * date); \n end\n\n assign credit = tmp;\n\nendmodule\n\nmodule testPiggyB();\n  reg clk;\n  reg reset, penny, nickel, dime, quarter;\n  reg apple, banana, carrot, date;\n  wire [7:0] credit;\n\n  initial begin              // Put the clock generation in a separate block.\n    clk <= 0;               // Otherwise it will block your rest of the code.\n    forever #5 clk <= ~clk; \n  end\n  initial begin\n    reset     <= 0;   // Issue a reset and then \n    #2  reset <= 1;  //  pull it down. this initializes temp.\n    #10 reset <= 0; \n    penny <= 0; nickel <= 0; dime <= 0; quarter <= 0;\n    apple <= 0; banana <= 0; carrot <= 0; date <= 0;\n    #5  quarter <= 1;\n    #40 quarter <= 0;\n    #100 $finish;\n  end\n\npiggyBank pb(.clk(clk), .reset(reset), .penny(penny) ,.nickel(nickel), .dime(dime),  .quarter(quarter), .apple(apple), .banana(banana), .carrot(carrot), .date(date), .credit(credit));\n\nendmodule\n```\n\n", "accept": false, "score": 1}, {"body": "There are several problems with your code.  \n\nFirst, the reset that you have will not work correctly.  You need to add an else and surround everything with begin/end statements so that when the reset signal is high, the only thing that gets assigned to tmp is the inital value.  Also, you can write 8'd0 if the number is in decimal.  \n\nSecond, the testbench never progresses beyond clock generation.  You need at least 2 separate initial statements.  One generates the clock, the other generates the actual testbench signals.  If they aren't separated, they can't run in parallel and you can have a clock OR you can run the testbench, but not both.  \n\nThird, the reset signal is never asserted.  You need to actually set the reset line high, wait a clock cycle or two, and deassert it.  Otherwise tmp will never be initialized, and in verilog all uninitialized variables are 'x' and many (all?) operations on x result in x.  \n\nAfter fixing all of this, your code runs fine in iverilog and the output counts 0, 25, 50, 75, 100.  \n", "accept": false, "score": 0}], "score": [6.0, 0.0, 0.10741930818037644, 0.0]}
{"question": "I am trying to generate random single bits and this is simple as long as you want a normal randomization:\n\n```\nwire R;\nassign R = $random % 2;\n```\n\n\nWhat I am looking for is a sort of weighted probability like:\n\n```\nwire R;\nassign R = 60%(0) || 40%(1);\n```\n\n\nForgive me if it is not conform to standard Verilog code, it is just to give an idea of what I want.\nCan anyone help me out?\nThank you\n", "answer": [{"body": "Something like:\n\n```\nwire R;\nif ($random[7:0]>(40*255/100))\n  assign R = 1'b0;\nelse\n  assign R = 1'b1;\n```\n\n\nI'm assuming that the algorithm that `$random` uses produces numbers that are equally random whatever bits you take from it.\n", "accept": false, "score": 0}, {"body": "Create a random integer then based on Value return 1 or 0; NB you may want to seed your random number, for repeatability use the same seed. This way when a test fails it can be debugged.\n\n`$urandom` works a little different to `$random` it doe not update the seed value so should only be seeded the first time it is called in a thread (always block). It is also thread safe, each always block works independently.\n\n```\ninitial begin\n  $urandom(seed);\n  $urandom;\n  $urandom;\nend\n\ninteger temp;\nreg     r   ;\n\nalways @ ... begin\n  temp = $urandom; //Range: +2_147_483_647 -2_147_483_648\n  // weighting; 0 would be 50:50\n  // real weighting is (0.1 + 0.5), 0.5 inherent from positive number.\n  r =  (temp > (2_147_483_647*0.1);  \nend\n```\n\n\nNB: the random functions are not synthesizable and should only be used for testbenches. if you want a random number for synthesis check out [this Question](https://stackoverflow.com/q/14497877/97073)\n", "accept": false, "score": 3}, {"body": "The SystemVerilog solution has a distribution method within `randomize` called `dist`. Weights are assigned by `value_or_range := weight` or `value_or_range :/ distributed_weight`. This exert from the [IEEE Std 1800-2012](https://standards.ieee.org/findstds/standard/1800-2012.html) \u00a7 18.5.4 page 476 gives a clear example:\n\n> When weights are applied to ranges, they can be applied to each value in the range, or they can be applied to the range as a whole. For example: \n  `x dist { [100:102] := 1, 200 := 2, 300 := 5}`\n  means x is equal to 100, 101, 102, 200, or 300 with a weighted ratio of 1-1-1-2-5, and\n  `x dist { [100:102] :/ 1, 200 := 2, 300 := 5}`\n  means x is equal to one of 100, 101, 102, 200, or 300 with a weighted ratio of\n  1/3-1/3-1/3-2-5.\n\n`dist` is used in randomization so it needs to be mare of a `randomize() with` (or a class `constraint`). `randomize` returns a success bit, therefore it should be in called within an `assert`, `void'()`, or the RHS of an assignment.\n\nIn your we can set the weight of 0 to 6 and the weight of 1 to 4, creating a total weight of 10 with a 60/40 distribution. Example:\n\n```\nreg R;\ninitial begin\n  assert( randomize(R) with { R dist { 0 := 6, 1 := 4 }; } );\nend\n```\n\n\nFrom more about `dist` see [IEEE Std 1800-2012](https://standards.ieee.org/findstds/standard/1800-2012.html) \u00a7 18.5.4 \"Distribution\". \n", "accept": true, "score": 9}, {"body": "For Verilog you can always so something like:\n\n```\ninteger R;\n\nR = ($dist_uniform(0,100) < 60) : $dist_uniform(0,5) : $dist_uniform(6,10)\n```\n\n\nand this in SystemVerilog would be the same as:\n\n```\nstd::randomize(R) with {R dist {[0:5] :/60, [6:10] :/ 40} ;};\n```\n\n\nYou could also do this procedural code:\n    randcase\n    60: R = 1;\n    40: R = 0;\n    endcase\n", "accept": false, "score": 1}, {"body": "Following Code Will Generate Random Variable as Per Your Requirement :\n\n```\nprogram top;\n    class Packet;\n        rand reg R;\n        constraint percentage {R dist {1:=60,0:=40};};\n        function void display;\n            $display(\"Random Reg : %0d\",this.R);\n        endfunction\n    endclass\n    Packet P;\n\n    initial \n    begin\n        P = new;\n        repeat(10)\n            begin\n                P.randomize();\n                P.display;\n            end\n    end\nendprogram\n```\n\n", "accept": false, "score": 0}, {"body": "It seems not so hard at verilog.\n\n```\nreg [7:0] R;\nreg rand_bit;\nR = $random();\nif (R < 76)\n   rand_bit = 1'b0;\nelse\n   rand_bit = 1'b1;\n```\n\n\nHere I assume that $random is pretty uniform. I think it should work :)\n", "accept": false, "score": 0}], "score": [0.0, 4.061179528126517e-155, 18.0, 8.70109940532403e-156, 0.0, 0.0]}
{"question": "I'm fairly new to HD description languages. I'm finding it a bit hard to change my C-ish programming skills, and I'm looking for a little guaidance to help my throw the following problem.\n\nI want to implement a full tree, that its inner nodes are different than its leaves.\nThe number of the leaves is  (asuming there is 2^k leaves so the tree can be full)\n\nEach inner node is a component made out of a simple combinational circuit. \n\nThe leaves are synchronized with a clock, and are connected to the next leaf (breaking the tree structures - and forming something like a shift register)\n\nThis means that my design has to have a .\n\nWhile this could be solved recursivly in no time in C-based languages. I can't grasp the idea of solving it in HDL, since this generic form is different than n-bit input signals...\n\nMy implementation must be , so SystemVerilog can't shine in this area :(\n\nIs it possible to implement the described problem while keeping my code synthesizable?\ncan anyone guide me throw this or point me to a good reference regarding this topic?\n", "answer": [{"body": "You probably want to look at how to use a `generate` statement in VHDL.  Use of a generate statement with a `for` statement will generate as many components as you need.\n\nIt is a requirement though that the total  number of leaves be known when the FPGA is built.  You cannot dynamically create leaves.\n", "accept": false, "score": 1}, {"body": "Verilog (or VHDL) `generate` statements can be used to create a scalable system, but the amount of hardware implied is fixed at compile time. You can not on the fly change how much hardware there is. Links for Verilog generate [one](http://www.fpgadeveloper.com/2011/07/code-templates-generate-for-loop.html), [two](http://www.asic-world.com/verilog/verilog2k2.html).\n\nShort example, wiring up multiple wires to an inverter\n\n```\nparameter DATA_W = 4;\nparameter DEPTH  = 8;\n\nwire [DATA_W-1:0] data   [0:DEPTH-1];\nwire [DATA_W-1:0] data_n [0:DEPTH-1];\n\ngenvar index;  \ngenerate  \n  for (index=0; index < DEPTH; index=index+1) begin: gen_code_label  \n    inv #(\n      .WIDTH  ( DATA_W        ) \n    ) inv_i0 (  \n      .rx     ( data[index]   ), // input  \n      .tx     ( data_n[index] ), // output   \n    );  \n  end  \nendgenerate\n```\n\n\nI find generates little hard to follow sometimes, especially if using to wire up a lot of hardware, they also introduce another level of hierarchy, which is often undesired.\n\nFor scalable template code I use erb (ruby), using the gem [ruby-it](http://morganp.github.io/RubyIt/).\n I wrote the gem to make doing this easier.\n\nAnother [question showing use of erb](https://stackoverflow.com/a/12532997/97073).\n", "accept": false, "score": 0}, {"body": "You can write a recursive algorithm in VHDL that is executed during elaboration, and which then defines the hardware structure to be synthesised, via the `generate` statement. You can almost do this in Verilog, which has had automatic functions since 2001, but they're not fully automatic, and I don't think I've seen any usable synthesisable examples of this sort of thing in Verilog.\n\nPost some pseudo-C so that we can see what you want.\n\n\nSee [this paper](http://www.eda.org/VIUF_proc/Spring94/ASHENDEN94A.PDF): it describes the recursive generation of a fat tree structure in VHDL. This is handled entirely by recursive component instantiation, rather than by using a recursive algorithm to pre-define the structure.\n", "accept": false, "score": 2}, {"body": "There's no reason why recursion doesn't work in HDLs. VHDL's generate statement can be used to recursively instantiate entities quite happily.  Bear in mind that you need to know how deep the recursion is at compile-time, as the hardware is created up-front.  But that's not actually so different to making sure you have enough stack-space in a software context - it's just enforced, rather than implied (with the option of exciting stack-smashing bugs if you get it wrong :)\n", "accept": false, "score": 0}, {"body": "I'll try to provide an answer that allows you to build a generic tree, without recursion, based only on the tree height provided as a generic at compile time. The code itself looks a bit tricky for my taste; however, the principles behind the solution are straigthforward. Here's an outline of the solution:\n\n- - - `for-generate`- - - \n\nHere's a poor rendition of the \"grid\" for HEIGHT=2:\n\n```\nj = 1           j = 2           j = 3           j = 4      \n       +---------------+---------------+---------------+---------------+\ni = 1  | Root Node     |    (empty)    |    (empty)    |    (empty)    |\n       +---------------+---------------+---------------+---------------+\ni = 2  | Internal Node | Internal Node |    (empty)    |    (empty)    |\n       +---------------+---------------+---------------+---------------+\ni = 3  | Internal Node | Internal Node | Internal Node | Internal Node |\n       +---------------+---------------+---------------+---------------+\n```\n\n\nHere's the code example:\n\n```\n/*  1 */  package tree_types_pkg is\n/*  2 */      -- define a data type for the input and output values at each node\n/*  3 */      subtype tree_data_type is integer range 0 to 255;\n/*  4 */      -- define a vector type to propagate the output of a tree level to the next\n/*  5 */      type layer_to_layer_channel_type is array (natural range <>) of tree_data_type;\n/*  6 */  end;\n/*  7 */  --------------------------------------------------------------------------------\n/*  8 */  use work.tree_types_pkg.all;\n/*  9 */\n/* 10 */  entity internal_node is\n/* 11 */      generic (\n/* 12 */          TREE_HEIGHT: integer := 3\n/* 13 */      );\n/* 14 */      port (\n/* 15 */          x: in integer range 1 to 2**TREE_HEIGHT;\n/* 16 */          y: in integer range 1 to TREE_HEIGHT;\n/* 17 */          input: in tree_data_type;\n/* 18 */          output_left: out tree_data_type;\n/* 19 */          output_right: out tree_data_type\n/* 20 */      );\n/* 21 */  end;\n/* 22 */\n/* 23 */  architecture rtl of internal_node is begin\n/* 24 */      -- perform some calculation at the node\n/* 25 */      output_left <= input + x * y;\n/* 26 */      output_right <= input - x * y;\n/* 27 */  end;\n/* 28 */  --------------------------------------------------------------------------------\n/* 29 */  use work.tree_types_pkg.all;\n/* 20 */\n/* 31 */  entity leaf_node is\n/* 32 */      generic (\n/* 33 */          TREE_HEIGHT: integer := 3\n/* 34 */      );\n/* 35 */      port (\n/* 36 */          x: in integer range 1 to 2**TREE_HEIGHT;\n/* 37 */          y: in integer range 1 to TREE_HEIGHT;\n/* 38 */          input: in tree_data_type;\n/* 39 */          output: out tree_data_type\n/* 30 */      );\n/* 41 */  end;\n/* 42 */\n/* 43 */  architecture rtl of leaf_node is begin\n/* 44 */      -- perform some calculation at the node\n/* 45 */      output <= input + x * y;\n/* 46 */  end;\n/* 47 */  --------------------------------------------------------------------------------\n/* 48 */  use work.tree_types_pkg.all;\n/* 49 */\n/* 50 */  entity dirtybit_binary_tree is\n/* 51 */      generic (\n/* 52 */          TREE_HEIGHT: integer := 4\n/* 53 */      );\n/* 54 */      port (\n/* 55 */          tree_input: in tree_data_type;\n/* 56 */          tree_outputs: out layer_to_layer_channel_type(1 to 2**TREE_HEIGHT)\n/* 57 */      );\n/* 58 */  end;\n/* 59 */\n/* 60 */  architecture behavior of dirtybit_binary_tree is\n/* 61 */      constant LEAF_NODES_COUNT: integer := 2**TREE_HEIGHT;\n/* 62 */      type channel_array_type is array (natural range <>) of layer_to_layer_channel_type;\n/* 63 */      signal connections: channel_array_type(1 to TREE_HEIGHT)(1 to LEAF_NODES_COUNT);\n/* 64 */  begin\n/* 65 */\n/* 66 */      connections(1)(1) <= tree_input;\n/* 67 */\n/* 68 */      grid_y: for i in 1 to TREE_HEIGHT generate\n/* 69 */          grid_x: for j in 1 to LEAF_NODES_COUNT generate\n/* 70 */\n/* 71 */              instantiate_nodes: if j <= 2**(i-1) generate\n/* 72 */\n/* 73 */                  internal_nodes: if (i /= TREE_HEIGHT) generate\n/* 74 */                      internal_node: entity work.internal_node \n/* 75 */                          generic map (TREE_HEIGHT => TREE_HEIGHT)\n/* 76 */                          port map (\n/* 77 */                              x => j,\n/* 78 */                              y => i,\n/* 79 */                              input        => connections(i)(j),\n/* 80 */                              output_left  => connections(i+1)((j-1)*i+1),\n/* 81 */                              output_right => connections(i+1)((j-1)*i+2)\n/* 82 */                          );\n/* 83 */                  end generate;\n/* 84 */\n/* 85 */                  leaf_nodes: if (i = TREE_HEIGHT) generate\n/* 86 */                      leaf_node: entity work.leaf_node \n/* 87 */                          generic map (TREE_HEIGHT => TREE_HEIGHT)\n/* 88 */                          port map (\n/* 89 */                              x => j,\n/* 90 */                              y => i,\n/* 91 */                              input  => connections(i)(j),\n/* 92 */                              output => tree_outputs(j)\n/* 93 */                          );\n/* 94 */                  end generate;\n/* 95 */\n/* 96 */              end generate;\n/* 97 */\n/* 98 */          end generate;\n/* 99 */      end generate;\n/* 100 */\n/* 101 */ end;\n```\n\n\nFinally, here's what the synthesized circuit looks like on Quartus 12.1 (RTL Viewer):\n\n![Tree circuit on Quartus RTL Viewer](https://i.stack.imgur.com/TMtfV.png)\n", "accept": true, "score": 0}], "score": [4.347495397725522e-245, 0.0, 5.684608370061221e-239, 0.0, 2.0]}
{"question": "the question is simple, I heared that `assign out = (a>b)?a:b` is wrong. is it wrong? if it is, is there another way to find MAX?\n", "answer": [{"body": "What you have there looks correct to me. There isn't really any other way to do it.\n", "accept": false, "score": 2}, {"body": "It's right if and only if `out` is a `wire`. If it's a register, then you have to do something like this:\n\n```\nalways @* begin\n  if (a>b)\n    out = a;\n  else\n    out = b;\nend\n```\n\n\nTake into account that in Verilog, a variable of type `reg` can infer either a wire or a latch, or a true register. It depends on how you specify the behaviour of the module that uses that reg:\n\nCombinational (`out` is implemented as a `wire` although it's a `reg`)\n\n```\nmodule max (input [7:0] a, \n            input [7:0] b, \n            output reg [7:0] out);\n  always @* begin\n    if (a>b)\n      out = a;\n    else\n      out = b;\n  end\nendmodule\n```\n\n\nCombinational (`out` is implemented as a `wire` and it's defined as a `wire`)\n\n```\nmodule max (input [7:0] a, \n            input [7:0] b, \n            output [7:0] out);\n  assign out = (a>b)? a : b;\nendmodule\n```\n\n\nLatch (`out` is a `reg`, and it's implemented as a latch which stores the last produced result if conditions don't make it change, i.e. if `a==b`, which btw, may not provide a correct output in that case)\n\n```\nmodule max (input [7:0] a, \n            input [7:0] b, \n            output reg [7:0] out);\n  always @* begin\n    if (a>b)\n      out = a;\n    else if (a<b)\n      out = b;\n  end\nendmodule\n```\n\n\nRegister (`out` is implemented as a true register, clock edge triggered)\n\n```\nmodule max (input clk,\n            input [7:0] a, \n            input [7:0] b, \n            output reg [7:0] out);\n  always @(posedge clk) begin\n    if (a>b)\n      out <= a;\n    else if (a<=b)\n      out <= b;\n  end\nendmodule\n```\n\n", "accept": true, "score": 4}, {"body": "You can do this by using subtractor. Using a subtractor is less area cost expensive and faster - if fpga have sub/add components or arithmetic sub/add operation support and do not have comperator components.\n\n[https://polandthoughts.blogspot.com/2020/04/the-4-bit-signed-comparator.html](https://polandthoughts.blogspot.com/2020/04/the-4-bit-signed-comparator.html)\n\nCheck boolean function at the end.  You check only 3 bits.\n\nSorry for my English.\n", "accept": false, "score": -1}, {"body": "this works with 3 input values\n\n```\nmodule max(\n    input [7:0] v1,\n    input [71:0] v2,\n    input [7:0] v3,\n    output [7:0] max\n    );\n\nwire [7:0] v12;\nwire [7:0] v23;\n\nassign v12 = v1>=v2 ? v1 : v2;\nassign v23 = v2>=v3 ? v2 : v3;\n\nassign m = v12>=v23 ? v12 : v23;\n\nendmodule\n```\n\n\n[](https://i.stack.imgur.com/IqcL9.png)\n", "accept": false, "score": 0}], "score": [3.157629614847523e-240, 8.0, -1.4029522870181895e-233, 0.0]}
{"question": "My task is to write a 16 bit ALU in verilog.  I found difficulties when I do the part that needs to rotate the operand and doing the 2's complement addition and subtraction.  I know how to work that out by paper and pencil but i cant figure out ways to do it in Verilog.\nfor example:\nA is denoted as a15 a14 a13 a12 a11 a10 a9 a8 a7 a6 a5 a4 a3 a2 a1 a0\nif i am going to rotate 4 bits,\nthe answer would be \na11 a10 a9 a8 a7 a6 a5 a4 a3 a2 a1 a0 a15 a14 a13 a12\n\ni tried concatenation but it turns out to be incorrect.\nneed you all help...\n", "answer": [{"body": "Why is concatenation incorrect? This should do what you ask.\n\n```\nassign A_out[15:0] = {A_in[11:0], A_in[15:12]};\n```\n\n", "accept": true, "score": 2}, {"body": "```\nassign A_out = A_in << bits_to_rotate;\n```\n\n\nWhere `bits_to_rotate` can be a variable value (either a signal or a reg).\nThis will infer a generic shifter using multiplexers, or a barrel shifter, whatever suits better the target hardware. The synthetizer will take care about that.\n\n\n---\n\n\n\nOh, well. If you want to rotate instead of shift, the thing is just a bit trickier:\n\n```\nassign A_out = (A_in << bits_to_rotate) | (A_in >> ~bits_to_rotate);\n```\n\n", "accept": false, "score": 3}, {"body": "The following will work using one shifter:\n\n```\nassign A_out = {A_in,A_in} >> (16-shift[3:0]);\n```\n\n\nWhen `shift` is 0 the left `A_in` is selected. As `shift` increase the left `A_in` shifts to the left and the MSBs of the right `A_in` fills in.\n\nIf synthesizing, then you may want to use muxes, as dynamic shift logic tends require more gates. A 16-bit [barrel shifter](http://en.wikipedia.org/wiki/Barrel_shifter) will require 4 levels of 2-to-1 muxes.\n\n```\nwire [15:0] tmp [3:1];\nassign tmp[3] = shift[3] ? {  A_in[ 7:0],  A_in[15: 8]} : A_in;\nassign tmp[2] = shift[2] ? {tmp[3][11:0],tmp[3][15:12]} : tmp[3];\nassign tmp[1] = shift[1] ? {tmp[2][13:0],tmp[2][15:14]} : tmp[2];\nassign A_out  = shift[0] ? {tmp[1][14:0],tmp[1][15   ]} : tmp[1];\n```\n\n", "accept": false, "score": 5}, {"body": "The best way I found to do this is finding a pattern. When you want to rotate left an 8 bit signal 1 position (`8'b00001111 << 1`) the result is `8'b00011110`) also when you want to rotate left 9 positions (`8'b00001111 << 9`) the result is the same, `8'b00011110`, and also rotating 17 positions, this reduces your possibilities to next table:\n\n![PATTERN_TABLE](https://i.stack.imgur.com/jUZAh.png)\n\nSo if you look, the three first bits of all numbers on tale equivalent to rotate 1 position (1,9,17,25...249) are equal to 001 (1).\n\nThe three first bits of all numbers on table equivalent to rotate 6 positions (6,14,22,30...254) are equal to 110 (6).\n\nSo you can apply a mask (`8'b00000111`) to determine the correct shifting by making zero all other bits:\n\n```\nreg_out_temp <= reg_in_1 << (reg_in_2 & 8'h07);\n```\n\n\n`reg_out_temp`  be the double of `reg_in_1`, in this case `reg_out_temp`  be 16 bit and `reg_in_1` 8 bit, so you can get the carried bits to the other byte when you shift the data so you can combine them using an OR expression:\n\n```\nreg_out <= reg_out_temp[15:8] | reg_out_temp[7:0];\n```\n\n\nSo by two clock cycles you have the result. For a 16 bit rotation, your mask shall be `8'b00011111` (`8'h1F`) because your shifts goes from 0 to 16, and your temporary register shall be of 32 bits.\n", "accept": false, "score": 0}], "score": [4.0, 1.3839771598582672e-156, 3.1946936278382106e-157, 0.0]}
{"question": "I am trying to reduce a vector to a sum of all it elements. Is there an easy way to do this in verilog?\n\nSimilar to the systemverilog .sum method.\n\nThanks\n", "answer": [{"body": "Verilog doesn't have any built-in array methods like SV. Therefore, a for-loop can be used to perform the desired functionality. Example:\n\n```\nparameter N = 64;\ninteger i;\nreg [7:0] array [0:N-1]\nreg [N+6:0] sum; // enough bits to handle overflow\n\nalways @*\nbegin\n  sum = {(N+7){1'b0}}; // all zero\n  for(i = 0; i < N; i=i+1)\n    sum = sum + array[i];\nend\n```\n\n", "accept": true, "score": 4}, {"body": "My combinational solution for this problem:\n\n```\n//example array\nparameter cells = 8;\nreg [7:0]array[cells-1:0] = {1,2,3,4,5,1,1,1};\n\n//###############################################\n\ngenvar i;\nwire [7:0] summation_steps [cells-2 : 0];//container for all sumation steps\ngenerate\n    assign summation_steps[0] = array[0] + array[1];//for less cost starts witch first sum (not array[0])\n    for(i=0; i<cells-2; i=i+1) begin\n        assign summation_steps[i+1] = summation_steps[i] + array[i+2];\n    end\nendgenerate\nwire [7:0] result;\nassign result = summation_steps[cells-2];\n```\n\n", "accept": false, "score": 5}, {"body": "In critiquing the other answers delivered here, there are some comments to make. \n\nThe first important thing is to provide space for the sum to be accumulated. statements such as the following, in RTL, won't do that:\n\n`sum = sum + array[i]`\n\nbecause each of the unique nets created on the Right Hand Side (RHS) of the expression are all being assigned back to the same signal called \"sum\", leading to ambiguity in which of the unique nets is actually the driver (called a multiple driver hazard). To compound the problem, this statement also creates a combinational loop issue because sum is used combinationally to drive itself - not good. What would be good would be if something different could be used as the load and as the driver on each successive iteration of the loop....\n\nBack to the argument though, in the above situation, the signal will be driven to an unknown value by most simulator tools (because: which driver should it pick? so assume none of them are right, or all of them are right - unknown!!). That is if it manages to get through the compiler at all (which is unlikely, and it doesn't at least in Cadence IEV).\n\nThe right way to do it would be to set up the following. Say you were summing bytes:\n\n```\nparameter NUM_BYTES = 4;\nreg [7:0] array_of_bytes [NUM_BYTES-1:0];\nreg [8+$clog2(NUM_BYTES):0] sum [NUM_BYTES-1:1];\n\nalways @* begin\n    for (int i=1; i<NUM_BYTES; i+=1) begin\n         if (i == 1) begin\n             sum[i] = array_of_bytes[i] + array_of_bytes[i-1];\n         end\n         else begin\n             sum[i] = sum[i-1] + array_of_bytes[i];\n         end\n    end\nend\n\n// The accumulated value is indexed at sum[NUM_BYTES-1]\n```\n\n", "accept": false, "score": 2}, {"body": "Here is a module that works for arbitrarily sized arrays and does not require extra storage:\n```\nmodule arrsum(input            clk,\n              input            rst,\n              input            go,\n              output reg [7:0] cnt,\n              input wire [7:0] buf_,\n              input wire [7:0] n,\n              output reg [7:0] sum);\n   always @(posedge clk, posedge rst) begin\n      if (rst) begin\n         cnt <= 0;\n         sum <= 0;\n      end else begin\n         if (cnt == 0) begin\n           if (go == 1) begin\n              cnt <= n;\n              sum <= 0;\n           end\n         end else begin\n            cnt <= cnt - 1;\n            sum <= sum + buf_;\n         end\n      end\n   end\nendmodule\nmodule arrsum_tb();\n   localparam N = 6;\n   reg        clk = 0, rst = 0, go = 0;\n   wire [7:0] cnt;\n   reg [7:0] buf_, n;\n   wire [7:0] sum;\n   reg [7:0]  arr[9:0];\n   integer    i;\n\n   arrsum dut(clk, rst, go, cnt, buf_, n, sum);\n   initial begin\n      $display(\"time clk rst sum cnt\");\n      $monitor(\"%4g   %b   %b %d    %d\",\n               $time, clk, rst, sum, cnt);\n\n      arr[0] = 5;\n      arr[1] = 6;\n      arr[2] = 7;\n      arr[3] = 10;\n      arr[4] = 2;\n      arr[5] = 2;\n\n      #5 clk = !clk;\n      #5 rst = 1;\n      #5 rst = 0;\n      #5 clk = !clk;\n\n      go = 1;\n      n = N;\n      #5 clk = !clk;\n      #5 clk = !clk;\n      for (i = 0; i < N; i++) begin\n         buf_ = arr[i];\n         #5 clk = !clk;\n         #5 clk = !clk;\n         go = 0;\n      end\n      #5 clk = !clk;\n      $finish;\n   end\nendmodule\n```\n\nI designed it for 8-bit numbers but it can easily be adapted for other kinds of numbers too.\n", "accept": false, "score": 0}], "score": [8.0, 1.8307762229530956e-155, 4.0, 0.0]}
{"question": "I like to avoid resetting data registers that don't need to be reset. For example, when streaming data through pipeline stages, if each stage has a valid bit, there is no need to reset the data registers. (I believe this eases routing and timing on the data registers.)\n\nThis can easily be accomplished by using separate always blocks (or processes in vhdl), but I find this verbose, and doing the following is problematic because the data register is essentially being enabled by the reset.\n\n```\nalways @(posedge clk)\nif (rst)\n  out_valid <= 0;\n  // NOTE: out_data is not reset\nelse begin\n  out_valid <= in_valid;\n  if (in_valid)\n    out_data <= in_data + 1;\nend\n```\n\n\nInstead, I've been putting the reset clause at the end of the always block and taking advantage of the \"last assignment wins\" rule.\n\n```\nalways @(posedge clk)\nbegin\n  out_valid <= in_valid;\n  if (in_valid)\n    out_data <= in_data + 1;\n\n  if (rst)\n    out_valid <= 0\nend\n```\n\n\nI haven't seen a lot of people using this style. Are there any drawbacks or issues that I'm missing? Is there a better way of doing this?\n\n: What if the reset is asynchronous? As in:\n\n```\nalways @(posedge clk, posedge rst)\nbegin\n  out_valid <= in_valid;\n  if (in_valid)\n    out_data <= in_data + 1;\n\n  if (rst)\n    out_valid <= 0\nend\n```\n\n\nIn this case I think the synthesizer will connect the reset signal to the data register, which defeats the purpose. Is there an elegant way of decoupling the data register from the reset signal without resorting to separate always block?\n", "answer": [{"body": "As you have shown in the question for synchronous resets the basic pattern is: \n\n```\nalways @(posedge clk) begin\n  if (rst) begin\n    out_valid <= 'b0;\n  end\n  else begin\n    out_valid <= in_valid;\n  end\nend\n```\n\n\nWith asynchronous reset:\n\n```\nalways @(posedge clk or posedge reset) begin\n  if (rst) begin\n    out_valid <= 'b0;\n  end\n  else begin\n    out_valid <= in_valid;\n  end\nend\n```\n\n\nI would not recommend mixing implying asyn reset flip-flops with non reset flip-flops as it easily looks like a typo that you forgot to add the resets. separating these two block seems like a good design separation. You are clearly separating control and data.\n\nFor the synchronous reset you should be ok to put the reset last as it is just a mux flop. \n\nI would not recommend it though. The following apply a little stronger to the async case but the softer reasons apply to both.\n\nSynthesis tools look for this pattern, when using your suggested method you may find that synthesis tools struggle or give incorrect results. Simulators and synthesis tools are often very different tools, using different code parsing engines under the hood. Just because it simulates ok does not mean it will synthesize ok.\n\nLarge designs may have many people working on them for months before it hits synthesis. If you have a dedicated Synthesis team they may be restricted to the version of tools that they can use based on internal quality control. Therefore even if you have proven to yourself that this works with the latest, or a particular version of the tools it may still end up causing a lot of extra work and extra design and synthesis cycles.\n\nYou may find that if company wide enforced linting tools and rules are put in place that this style would no longer pass a code quality review.\n\n: \nAn engineers role is to build something weighing up all the decision effecting cost, timescale and suitability for the required task. Using known working technology and methodologies where appropriate helps reduce risk and adds reliability to time scales.\n\nHaving industry standard coding practises, allows code to be handed over to anyone within the team or to external contractors. Using familiar coding patterns speeds up reading and understanding of code, which lead to a lower overall cost of design.\n", "accept": false, "score": 2}, {"body": "I think you can mix registers with sync reset with the ones without sync reset. How about the following:\n\n```\nalways @(posedge clk)\nbegin\n//Sync reset for out_valid\nif (rst) out_valid <= 0;\nelse     out_valid <= in_valid;\n\n//no sync reset for out_data\nif (in_valid) out_data <= in_data + 1;\nend\n```\n\n\nHowever, in case of async reset, if you write:\n\n```\nalways @(posedge clk, posedge rst)\nbegin\n  if (rst)      out_valid <= 0\n  else          out_valid <= in_valid;\n\n  if (in_valid) out_data <= in_data + 1;\nend\n```\n\n\nyou are implicitly tying rst and out_data together: the assignment to out_data would be incorrect when there is a posedge on rst, but no posedge on clk.\n\nSo as Morgan mentions, I think it is a good practice to clearly separate the registers with async reset from the ones without async reset.\n", "accept": false, "score": 0}, {"body": "\n### Synchronous Resets\n\n\n\nI've been using the \"\" for resets for >5 years.  Personally I find it easier to read and it saves having to needlessly indent the entire process one level.  I've never seen any problems using this coding style with the FPGA synthesis tools I use (ISE, Quartus, Synplify).\n\n\n### Asynchronous Resets\n\n\n\nTo answer your bonus question regarding asynchronous resets - this is a little trickier.  Consider the following:\n\n```\ntypedef struct packed {\n    logic               a;\n    logic               b;\n} state_t;\n\nstate_t                 state;\n\nalways_ff @(posedge clk or negedge areset_n) begin\n    if (~areset_n) begin\n        state.a         <= 1'b0;\n    end else begin\n        state.a         <= data_a;\n        state.b         <= data_b;\n    end\nend\n```\n\n\nWe have a bit of a problem.  We don't want `state.b` to have a reset, but it's part of the same structure as `state.a` which is reset.  Being good engineers we use `always_ff` processes but this actually means we can't split the code into separate processes.  Besides, it would become very messy and error prone keeping track of which members are assigned in which process for a large state structure.\n\nThe above code actually synthesises to the following:\n\n![example of gated input](https://i.stack.imgur.com/3Ga4Z.png)\n\nWe can see that the `areset_n` signal acts as an enable to the `state.b` register.  Typically this isn't what we want, and since most FPGAs don't support this architecture natively the synthesis tool is forced to insert additional logic to emulate the enable:\n\n![enter image description here](https://i.stack.imgur.com/uoQSH.png)\n\nThis extra logic reduces timing margin and uses up precious resource.  Thankfully, there is a workaround:\n\n```\nalways_ff @(posedge clk or negedge areset_n) begin\n    if (~areset_n) begin\n        state.a         <= 1'b0;\n        state.b         <= 1'bx;\n    end else begin\n        state.a         <= data_a;\n        state.b         <= data_b;\n    end\nend\n```\n\n\nNote that we have assigned `x` to `state.b` during the reset. As we can see, Quartus now synthesises our intended circuit:\n\n![enter image description here](https://i.stack.imgur.com/zi0ty.png)\n\n\n### Bonus Rant\n\n\n\nAs an aside, I'm not a big fan of being constrained to \"standard practice\" because the possibility that tools  get is wrong.  \"Conventional wisdom\" is often [incorrect or outdated](https://stackoverflow.com/a/4774450/579887).\n\nBe adventurous and push the tools to their limits. If you hit a bug in the tool or a limitation then raise a bug with the vendor and adjust your style to compensate.  Sure sometimes you'll spend time looking into a strange bug that turns out to be the fault of the toolchain but you should be looking at the output of your tools anyway.  The time spent will be more than saved by the improved levels of abstraction and re-use made available with some of the newer language features.\n\nIf more of us pushed to get new features supported or [participated in improving the languages](http://www.eda.org/twiki/bin/view.cgi/P1076/WebHome) then vendors wouldn't be able to get away with fobbing us all off with tools that are already 5-years out of date!  The level of conservatism in RTL development hampers innovation - we love complaining about the tools but we don't participate enough in making them better.\n", "accept": true, "score": 9}, {"body": "I am sorry but I don't think it is wise to drive 'X in reset.  Though it will disconnect reset from the S/R or PRE/CLR, it will also lead to something you don't intend.  Often times we don't fully see all data dependencies in the design.  This leads to lack of determinism and likely big problems trying to close out timing in a high speed design.\n\nsimple case:\n\n```\n1\n  2   `define NC\n  3 \n  4   //`define SYNC_CLOCKING 1\n  5 \n  6   `define ALWAYS_FF( clk, rst ) \\\n  7     `ifdef SYNC_CLOCKING \\\n  8       always_ff @(posedge clk) \\\n  9     `else \\\n 10       `ifdef rst \\\n 11         always_ff @(posedge clk) \\\n 12       `else \\\n 13         always_ff @(posedge clk, posedge rst) \\\n 14       `endif \\\n 15     `endif\n 16 \n 17 module test (\n 18   input  logic clk,\n 19   input  logic rst,\n 20   input  logic din,\n 21   output logic [7:0] dout\n 22 );\n 23 \n 24   typedef struct packed {\n 25     logic         valid;\n 26     logic [127:0] data;\n 27   } intf;\n 28 \n 29   intf my_intf;\n 30 \n 31   logic [7:0] cnt;\n 32 \n 33   `ALWAYS_FF( clk, rst ) begin\n 34     if( rst ) begin\n 35       my_intf <= 'X;\n 36       my_intf.valid <= 0;\n 37       cnt  <= '0;\n 38       dout <= '0;\n 39     end else begin\n 40       my_intf.valid <= din;\n 41       if( my_intf.valid ) begin\n 42         my_intf.data = my_intf.data + cnt;\n 43       end\n 44       if( din ) begin\n 45         cnt  <= cnt + 2;\n 46       end\n 47       dout <= dout + my_intf.data;\n 48     end\n 49   end\n 50 \n 51 endmodule\n```\n\n\nThere is an implicit dependency of data on rst through the valid.  Vivado will create this:\n\n[Reset in Data Path](http://i.stack.imgur.com/UXHLF.png)\n", "accept": false, "score": 0}], "score": [2.0, 0.0, 18.0, 0.0]}
{"question": "Is it possible to write a function that can detect the input data width automatically? For example, consider the parity function below:\n\n\n```\nfunction parity;\n  input [31:0] data;\n  parity = ^ data;\nendfunction\n```\n\n\nWhen `parity(data)` is called, the input data should be limited to 32 bits.\n\nAlternatively, one could write a macro, such as  ``PARITY(data)` in which the system function `$bits` can detect the width of data and make the macro width-independent. Is it possible to have the same flexibility for functions?\n\nEdit: I need my code to be synthesizable.\n", "answer": [{"body": "You can create a parameterized function. See section 13.8 in the [LRM](http://standards.ieee.org/getieee/1800/download/1800-2012.pdf).  It looks like the function must be declared inside a class like this:\n\n```\nvirtual class C #(parameter WIDTH=32);\n   static function parity (input [WIDTH-1:0] data);\n      parity=^data;\n   endfunction\nendclass\n```\n\n\nThen when you call the function parameterized it with the `bits` task:\n\n```\nassign parity_bit = C#($bits(data))::parity(data);\n```\n\n\nWorking example on [EDA Playground](http://www.edaplayground.com/x/3RJ).\n", "accept": true, "score": 7}, {"body": "It is possible using unbounded arrays.\nUnfortunately SystemVerilog doesn't have decent support for unbounded arrays. The LRM seems to equate unbounded with dynamic, which suggests it's going to be almost impossible to create something synthesisable.  VHDL has unbounded arrays which are supported by tools and incredibly useful so it's a pity that SystemVerilog didn't include this feature properly.\nHere is an example:\n```\nfunction automatic logic parity(input logic data[]);\n    logic p = 0;\n    for (int i=0; i<data.size(); i++)\n        p ^= data[i];\n    return p;\n    //return = ^data;   <--- not allowd on unpacked arrays?\nendfunction\n\nlogic [7:0]     data_in;\nlogic           result;\nlogic           data_in_unpacked [] = new[$bits(data_in)];\n  \nalways_comb begin\n    // Convert to unpacked array (better way to do this?)\n    for (int i=0; i<$bits(data_in); i++)\n        data_in_unpacked[i] = data_in[i];\n    result = parity(data_in_unpacked);\nend\n```\n\nThis is running on Modelsim on EDAPlayground here: [http://www.edaplayground.com/x/3tS](http://www.edaplayground.com/x/3tS)\nEDIT 1: Updated the code - I just realised it's possible to call `new[]` at initialisation and thus statically, so in theory synthesis tools could support this.  It would be interesting to synthesise this and see...\nEDIT 2: Thought I'd try synthesising and unsurprisingly Quartus doesn't like this:\n> Error (10170): Verilog HDL syntax error at testing.sv(10) near text \"]\";  expecting an operandError (10170): Verilog HDL syntax error at testing.sv(18) near text \"]\";  expecting an operandError (10112): Ignored design unit \"my_parity\" at testing.sv(2) due to previous errors\n", "accept": false, "score": 2}, {"body": "You can use macros. The function can be declared like:\n\n```\n`define PARITY(FUNC_name, WIDTH)             \\\nfunction FUNC_name (input [WIDTH-1:0] data); \\\nbegin                                        \\\n  FUNC_name = ^ data;                        \\\nend                                          \\\nendfunction\n```\n\n\nand you can call it with:\n\n```\n`PARITY(parity, 32);\nassign parity_bit = parity(data);\n```\n\n\nThis code is synthesizable in xilinx, altera and synopsys tools\n", "accept": false, "score": 6}, {"body": "Interesting question. According to my knowledge, I don't think that's possible. I would also stay away from macros (even more problems). I can propose a synthesizable workaround:\n\n\n1. When calling your function parity on widths lesser than your defined width pad your data with 0's like this: assign my_parity_bits = parity({16'd0, my_data}); Hopefully, synthesis tool would ignore those 0's but you will have to check it yourself.\n2. If you want to perform such operation on large data buses in a convenient way you will have to write some more Verilog. E.g. a module that would accept a WIDTH parameter and actual data as an input vector. To do this, I would advise you to write a generic module that does exactly what your function parity does. Then, write a module which will be a parity wrapper. Inside this wrapper I would perform math operations on input WIDTH parameter to determine number of parity modules needed for input data and instantiate those modules in a generate loop.\n\n\n\nRemember that Verilog is a hardware description language, thus such limitations. Think about what your code will synthesize into when writing RTL.\n", "accept": false, "score": 0}, {"body": "Quick update on using the paramaterized virtual class idea posted above. Stack overflow won't let me leave comments so I had to post a new answer. I just wanted to add that I tried this in Vivado, and it appears to work correctly in synthesis. Using nguthrie's solution above, I can do\n```\nlogic [7:0] data;\nassign data = {sw, btn};\nassign led[0] = C#($bits(data))::parity(data);\n```\n\nThis is in Vivado 2021\n", "accept": false, "score": 0}], "score": [14.0, 2.0, 4.1165157227990213e-78, 0.0, 0.0]}
{"question": "- In verilog, I can assign a string to a vector like: ```\nwire [39:0] hello;\nassign hello = \"hello\";\n```\n- In VHDL, I'm having difficulty finding a method like this:```\nSIGNAL hello : OUT std_logic_vector (39 DOWNTO 0);\n...\nhello <= \"hello\";\n```\n\n\nI've been using:\n\n```\nhello <= X\"65_68_6c_6c_6f\";\n```\n\n\nwhich is unclear and time consuming for large strings.\n\nI've looked at the [textio package](http://paws.kettering.edu/~mcdonald/class/ce422/qhdl/8_TxtIO.pdf) and the[txt_util package](http://www.stefanvhdl.com/vhdl/vhdl/txt_util.vhd), but neither seem to be very clear on how to interpret a string and convert it to std_logic.\n\nIs there a simple method of assigning ascii codes to std_logic in VHDL?\n\nHere's a minimal example:\n\n```\nLIBRARY ieee;\nUSE ieee.std_logic_1164.ALL;\n\nENTITY test IS\nPORT(\n   ctrl : IN std_logic;\n   stdout : OUT std_logic_vector (39 DOWNTO 0)\n);\nEND ENTITY;\n\nARCHITECTURE rtl OF test IS\n   SIGNAL temp : std_logic_vector (39 DOWNTO 0);\nBEGIN\n   stdout <= temp;\n   PROCESS(ctrl)\n   BEGIN\n      IF (ctrl = '0') THEN\n         temp <= \"hello\"; -- X\"68_65_6C_6C_6F\";\n      ELSE\n         temp <= \"world\";\n      END IF;\n   END PROCESS;\n\nEND rtl;\n```\n\n", "answer": [{"body": "A small general function is one way to do it, with a suggestion below:\n\n```\nlibrary ieee;\nuse ieee.numeric_std.all;\n...\n-- String to std_logic_vector convert in 8-bit format using character'pos(c)\n--\n-- Argument(s):\n-- - str: String to convert\n--\n-- Result: std_logic_vector(8 * str'length - 1 downto 0) with left-most\n-- character at MSBs.\nfunction to_slv(str : string) return std_logic_vector is\n  alias str_norm : string(str'length downto 1) is str;\n  variable res_v : std_logic_vector(8 * str'length - 1 downto 0);\nbegin\n  for idx in str_norm'range loop\n    res_v(8 * idx - 1 downto 8 * idx - 8) := \n      std_logic_vector(to_unsigned(character'pos(str_norm(idx)), 8));\n  end loop;\n  return res_v;\nend function;\n```\n\n", "accept": false, "score": 5}, {"body": "This one varies little for Morten's answer - it only uses one multiply, it copies the string instead of creating an alias, it uses an additional variable and it returns a standard logic vector with an ascending index range.\n\nFrom a package called string_utils:\n\n```\nlibrary ieee; \nuse ieee.numeric_std.all;\n-- ...\n    function to_slv(s: string) return std_logic_vector is \n        constant ss: string(1 to s'length) := s; \n        variable answer: std_logic_vector(1 to 8 * s'length); \n        variable p: integer; \n        variable c: integer; \n    begin \n        for i in ss'range loop\n            p := 8 * i;\n            c := character'pos(ss(i));\n            answer(p - 7 to p) := std_logic_vector(to_unsigned(c,8)); \n        end loop; \n        return answer; \n    end function;\n```\n\n\nYou could add an argument with a default specifying ascending/descending index range for the return value.  You'd only need to provided the argument for the non default. \n", "accept": true, "score": 7}, {"body": "In your example you are trying to assign a string type to a std_logic_vector type.\nThat is simply not allowed. VHDL is strongly typed.\n\nSIGNAL hello : OUT std_logic_vector (39 DOWNTO 0);\n...\nhello <= \"hello\";\n\nIf your goal is to convert from hexa to ascii for printing simulation result \nyou can simply do that:\n\n> character'val(to_integer(unsigned(my_std_logic_vector)))\n", "accept": false, "score": 1}, {"body": "To return an ascii value of a character, use this code:\n```\nsome_variable <= character'pos('a'); --returns the 'a' ascii value\n```\n\n", "accept": false, "score": 3}], "score": [1.3839810851212877e-155, 14.0, 2.2029505230733554e-234, 1.6902902248475742e-163]}
{"question": "I am writing a systemverilog module and I need to make sure that a certain macro is set to allow compilation to proceed.\n\nI have tried the below, but it simply gives the syntax error \"unexpected SYSTEM_IDENTIFIER\" $fatal.\n\nI know that does technically stop the compilation, but does anyone know of a more graceful solution?\n\n Correction, if the syntax in the `else branch is not correct, none of the branches will compile successfully.\n\n```\n`ifdef MACRO_0\n// Some code\n`elsif MACRO_1\n// Some other code\n`else\n$fatal(\"MACRO_0 or MACRO_1 must be set for compilation\");\n`endif\n```\n\n\nAs per recommendation, adding the below information to the question:\n\nThe code is in a module but not inside an initial or always statement. I am hoping to find a solution that will allow me to terminate the compilation i.e. elaboration of hdl. I am designing for FPGA implementation and I need to make sure that no other user of this code can reach the synthesis phase of a design flow without setting one of these macros.\n", "answer": [{"body": "Using an `initial` terminates the  at time 0.  It does not terminate the .\n\n```\nmodule tb;\n\n`ifdef MACRO_0\n// Some code\n`elsif MACRO_1\n// Some other code\n`else\ninitial $fatal(1, \"MACRO_0 or MACRO_1 must be set for compilation\");\n`endif\n\nendmodule\n```\n\n", "accept": false, "score": 0}, {"body": "`$fatal` is a run-time system call, not a compile-time fatal as mentioned by toolic. I don't think you can stop the compile unless you have a compile error. In your sample code you are getting close to what you want by hiding part of the code, but the compile does not terminate and you don't print the right message. \n\nI am not aware of any standard Verilog/SystemVerilog construct for printing a customized message during the compile time. GCC for example, [has #error for this purpose](https://stackoverflow.com/questions/2124968/gcc-pragma-to-stop-compilation). However, some synthesis tools, like Synopsis Design Compiler do print the output of `$display` messages during  time. The `$display` still needs to be inside an `always` block. If you also deliberately place an elaboration error when MACRO0 and MACRO1 are not defined, you may be able to terminate the synthesis.\n\nFor example, in the following, a dummy module is instantiated without defining its body:\n\n```\n`ifdef MACRO_0\n// Some code\n`elsif MACRO_1\n// Some other code\n`else\n logic a;\n always $display(\"MACRO_0 or MACRO_1 must be set for compilation\");\n DEFINE_MACRO0_OR_MACRO1 dummy (.in(a));\n`endif\n```\n\n\nthis will generate the following elaboration message:\n\n```\n$display output: MACRO_0 or MACRO_1 must be set for compilation\n...\nInformation: Building the design 'DEFINE_MACRO0_OR_MACRO1'. (HDL-193)\nWarning: Cannot find the design 'DEFINE_MACRO0_OR_MACRO1' in the library 'WORK'. (LBR-1)\nWarning: Unable to resolve reference 'DEFINE_MACRO0_OR_MACRO1' in 'TEST'. (LINK-5)\n0\n```\n\n", "accept": true, "score": 6}, {"body": "at least in VCS $fatal is a system task for runtime,not elab/compile\n\nError-[SE] Syntax error\n  Following verilog source has syntax error :\n        Using elaboration system tasks requires option -assert svaext\n  \"bla.sv\", 10: token is ';'\n   $fatal(\"MACRO_0 or MACRO_1 must be set for compilation\");\n                                                            ^\n\nadding the proper switch allows it to go through in compilation time. i don't know the FGPA compiled you are using, but maybe it has similar switch \n", "accept": false, "score": 0}, {"body": "`$fatal` is also an elaboration task added in IEEE Std 1800-2009 in section 20.10. See [IEEE Std 1800-2012](https://standards.ieee.org/findstds/standard/1800-2012.html) \u00a7 20.11 . It can be used inside an generate block. The follow should work if the simulator is *09+ complaint.\n\n```\n...\n`else\n//inferred generate block\nif (0) $fatal(1,\"MACRO_0 or MACRO_1 must be set for compilation\");\n`endif\n```\n\n\nI tried it out on [edaplaygrond](http://www.edaplayground.com/x/2f6) but it looks like ModelSim10.1d does not support it. In the mean time, like others have suggested, you can do the following:\n\n```\n...\n`else\nCAUSE_ELAB_ERR fatal(\"MACRO_0 or MACRO_1 must be set for compilation\");\n`endif\n```\n\n", "accept": false, "score": 4}, {"body": "I know this is an old thread, but since the question was asked, the support for elaboration system tasks has improved quite a bit. The original code should now work as intended on most tools (e.g. Cadence Xcelium, Synopsys VCS and Mentor Questasim). \n\nIt can also be noted that the problem probably can be better solved by module parameters:\n\n```\nif (!(PARAM_0 || PARAM_1))\n  $fatal(1,\"your error message\");\n```\n\n", "accept": false, "score": 0}], "score": [0.0, 12.0, 0.0, 3.2029705538325573e-78, 0.0]}
{"question": "What does the `<=` do in Verilog?\n\nFor example:\n\n```\nalways @(posedge Clock) begin\n   if (Clear) begin\n      BCD1 <= 0;\n      BCD0 <= 0;\n   end\nend\n```\n\n", "answer": [{"body": "This is called a 'non-blocking' assignment. The non-blocking assignment allows designers to describe a state-machine update without needing to declare and use temporary storage variables.\n\nFor example, in this code, when you're using a non-blocking assignment, its action won't be registered until the next clock cycle. This means that the order of the assignments is irrelevant and will produce the same result.\n\nThe other assignment operator, '=', is referred to as a blocking assignment. When '=' assignment is used, for the purposes of logic, the target variable is updated immediately.\n\nThe understand this more deeply, please look at this example (from Wikipedia):\n\n```\nmodule toplevel(clock,reset);\n    input clock;\n    input reset;\n\n    reg flop1;\n    reg flop2;\n\n    always @ (posedge reset or posedge clock)\n        if (reset)\n        begin\n            flop1 <= 0;\n            flop2 <= 1;\n        end\n        else\n        begin\n            flop1 <= flop2;\n            flop2 <= flop1;\n        end\nendmodule\n```\n\n\nIn this example, `flop1 <= flop2` and `flop2 <= flop1` would swap the values of these two `reg`s. But if we used blocking assignment, `=`, this wouldn't happen and the behavior would be wrong.\n", "accept": false, "score": 4}, {"body": "\"<=\" in Verilog is called non-blocking assignment which brings a whole lot of difference than \"=\" which is called as blocking assignment because of scheduling events in any vendor based simulators. \n\nIt is Recommended to use non-blocking assignment for sequential logic and blocking assignment for combinational logic, only then it infers correct hardware logic during synthesis.\n\nNon-blocking statements in sequential block will infer flip flop in actual hardware.\n\nAlways remember do not mix blocking and non-blocking in any sequential or combinational block.\n\nDuring scheduling process of simulator:\n\nThere are four regions and order of execution of commands as follows\n\n```\n1) Active region\n     --Blocking assignments\n     --Evaluation of RHS of non-blocking assignments(NBA)\n     --Continuous assignment\n     --$display command\n     --Evaluate input and output of primitives\n2) Inactive region\n     --#0 blocking assignments\n3) NBA(non-blocking assignment update)\n     --update LHS of non-blocking assignments (NBA)\n4) Postponed\n     --$monitor command\n     --$strobe command\n```\n\n\nUsing of blocking assignment \"=\" for two variable at the same time slot causes race condition \n\neg: Verilog code with race condition, \n\n```\nalways @(posedge Clock) \n   BCD0 = 0; // Usage of blocking statements should be avoided\nalways @(posedge Clock) \n   BCD1 = BCD0;\n```\n\n\nIn order to avoid race condition use non-blocking statement \"<=\"\n\neg: \n\n```\nalways @(posedge Clock) \n       BCD0 <= 0; // Recommended to use NBA\n    always @(posedge Clock) \n       BCD1 <= BCD0;\n```\n\n\nWhen this block is executed, there will be two events added to the non blocking assign update queue.\nHence, it does the updation of BCD1 from BCD0 at the end of the time step.\n\nUsing Non-blocking \"<=\" assignment in continuous assignment statement is not allowed according to verilog LRM and will result in compilation error.\n\neg: \n\n```\nassign BCD0 <= BCD1; //Results in compilation error\n```\n\n\nOnly use NBA in procedural assignment statements, \n\n```\n- initial and\n - always blocks\n```\n\n", "accept": true, "score": 25}, {"body": "As most told, it is a \"Non Blocking <=\" assignment widely used for Sequential logic design because it can emulate it best.\n\n :\n\nMostly involving a delay(here posedge clock) it is something like it schedules the evaluation of the RHS to LHS after the mentioned delay and moves on to the next statement(emulating sequential) in flow unlike \"Blocking = \" which will actually delay the execution of the next statement in line with the mentioned delay (emulating combinational)\n", "accept": false, "score": 0}, {"body": "\"<=\" is a non-blocking assignment operator in verilog.\"=\" is a blocking assignment operator.\n\nConsider the following code..\n\n```\nalways@(clk)\nbegin\na=b;\nend\n\nalways@(clk)\nbegin\nb=a;\nend\n```\n\n\nThe values of a and b are being exchanged using two different always blocks.. Using \"=\" here caused a race-around condition. ie. both the variables a and b are being changes at the same time.. \nUsing \"<=\" will avoid the race-around.\n\n```\nalways@(clk)\nbegin\na<=b;\nend\n\nalways@(clk)\nbegin\nb<=a;\nend\n```\n\n\nHope i helped too..\n", "accept": false, "score": 1}, {"body": "`<=` is a non blocking assignment. The `<=` statements execute parallely. Think of a pipelined architecture, where we come across using such assignments.\n\nA small exammple:\n\n// initialise a, b, c with 1, 2 and 3 respectively.\n`initial begin a <= 1 b <= 2 c <= 3 end`\n\n`always@(clock.posedge) begin a <= b b <= c c <= a end`\n\nAfter the first posedge clock:\n`a = 2, b = 3, c = 1`\n\nAfter the second posedge clock:\n`a = 3, b = 1, c = 2`\n\nAfter third posedge clock:\n`a = 1, b = 2, c = 3`\n", "accept": false, "score": 0}, {"body": "Since people have already explained the blocking/non blocking situation, I'll just add this here to help with understanding.\n\" <= \" replaces the word \"gets\" as you read code\n\nFor example : \n\n.... //Verilog code here\n\n\n\nWhen does A get B? In the given time slot, think of everything in hardware happening in time slots, like a specific sampled event, driven by clock. If the  \"<=\" operator is used in a module with a clock that operates every 5ns, imagine A getting B at the end of that time slot, after every other \"blocking\" assignments have resolved and at the same time as other non blocking assignments. \n\nI know its confusing, it gets better as you use and mess up bunch of designs and learn how it works that way.\n", "accept": false, "score": 2}], "score": [2.3792914658267945e-231, 50.0, 0.0, 1.0, 0.0, 4.0]}
{"question": "I'm trying to find a plugin that will highlight the matching begin/end statements with Verilog. VIM has it working with curly braces /brackets but it does not work with its begin/end. I want VIM to highlight the correct begin to the correct end. \n", "answer": [{"body": "Answering to your question. Have a look on a syntax file [systemverilog.vim](https://github.com/nachumk/systemverilog.vim/blob/master/syntax/systemverilog.vim) 25 line:\n\n```\nsyntax region svCase matchgroup=svConditional start=\"\\<case\\|casex\\|casez\\>\" end=\"\\<endcase\\>\" contains=ALL\n```\n\n\n- `syntax``:he syntax`- `region`- `svCase`- `matchgroup`- `start``end`- `contains=ALL`\n\nHope that's you looking for.\n", "accept": false, "score": 1}, {"body": "I'm not aware of any plugin that does this, but you can probably derive that functionality from the related [html_MatchTag plugin](https://github.com/gregsexton/MatchTag), which implements this for HTML tags, by adapting to the Verilog filetype and replacing the corresponding regular expressions.\n", "accept": false, "score": 1}, {"body": "In my opinion, your best bet is using matchit. This script is part of vim runtime and can easily be loaded by adding the following line to your .vimrc:\n\n```\nruntime macros/matchit.vim\n```\n\n\nThe standard Verilog filetype plugin already includes the matchit configuration you require:\n\n```\n\" Let the matchit plugin know what items can be matched.\nif exists(\"loaded_matchit\")\n  let b:match_ignorecase=0\n  let b:match_words=\n    \\ '\\<begin\\>:\\<end\\>,' .\n    \\ '\\<case\\>\\|\\<casex\\>\\|\\<casez\\>:\\<endcase\\>,' .\n    \\ '\\<module\\>:\\<endmodule\\>,' .\n    \\ '\\<if\\>:\\<else\\>,' .\n    \\ '\\<function\\>:\\<endfunction\\>,' .\n    \\ '`ifdef\\>:`else\\>:`endif\\>,' .\n    \\ '\\<task\\>:\\<endtask\\>,' .\n    \\ '\\<specify\\>:\\<endspecify\\>'\nendif\n```\n\n\nThis way you can match the begin/end using `%` key, as you probably already do for parentheses and such.\n\nThis is not exactly what you were looking for, in the sense that although it allows you to find the matching end of a begin it does not highlight it for you. I did some research and apparently there's a [code snippet around for that](http://objectmix.com/editors/377087-matchit-plugin-highlighting.html); and there's someone who already transformed that code into a plugin, which is named [hl_matchit](https://github.com/vimtaku/hl_matchit.vim). Don't forget to check this plugin's help page:\n\n```\n:help hl_matchit.txt\n```\n\n\nPlease note that the Verilog filetype plugin included in vim installation does not support the `ifndef` and `elsif` clauses introduced in Verilog 2001. If you require this then I suggest that you also install the verilog_systemverilog.vim plugin already mentioned before, but use the [fork](https://github.com/vhda/verilog_systemverilog.vim) I am improving which includes the afore mentioned updates, as well as other fixes/improvements.\n", "accept": true, "score": 8}, {"body": "Install the system verilog plugin: [https://github.com/vhda/verilog_systemverilog.vim](https://github.com/vhda/verilog_systemverilog.vim)\n\nInstall matchit `:he matchit`\nand you are good to go!\n", "accept": false, "score": 0}], "score": [2.0, 6.452255261603574e-243, 16.0, 0.0]}
{"question": "I am trying to make serializer from 32bits to 8 bits. Because I am just starting verilog I am facing problem. I would like to get 32 bits (on every 4th clock cycles) and then to send 8 bits on every clock cycle. How can I take just part of my dataIn, I wrote code below but assignment expression is not working. Sorry if question is basic. Thank you in advance on answer.\n\n```\nmodule ser32to8(clk, dataIn, dataOut);\n  input clk;\n  input [32:0] dataIn;\n  output [7:0] dataOut;\n\n  always @(posedge clk) \n  begin\n    dataOut <= dataIn << 8;\n    end\n    endmodule\n```\n\n", "answer": [{"body": "The idea behind the question is not so clear but my guess would be that you want to wait for 4 clock cycles before you send the data, if that is the case below snippet could help, A counter to wait before 4 clock cycles will do the trick\n\n```\nmodule top (input         clk,rst,\n            input  [31:0] dataIn,\n            output [7:0]  dataOut\n            ); \nreg    [31:0] tmp; \nreg    [31:0] inter; \ninteger       count;\n\nalways @(posedge clk) \nbegin \n  if (rst) begin\n    count <= 0;\n    tmp   <= '0;\n  end\n  else\n  begin\n    if (count < 3) begin\n      tmp <= dataIn << 4;\n      count <= count +1; end\n    else if (count == 3) \n      begin\n      inter <= tmp;\n      count <= 0;\n      end\n    else\n      begin\n        tmp <= dataIn;\n      end\n    end\nend\n\nassign dataOut  = inter[7:0]; \nendmodule\n```\n\n\nBut there are some limitations tested with tb [http://www.edaplayground.com/x/4Cg](http://www.edaplayground.com/x/4Cg)\n\n> Note: Please ignore the previous code it won't work(I was not clear so\n  tried it differently)\n\n\n\nIf I understand your question correctly a simple way to do it is\n\na)\n\n```\nmodule top ( input         rst,clk,\n             input  [31:0] dataIn,\n             output [7:0]  dataOut);\nreg [1:0] cnt;\nalways @(posedge clk) begin\n  if (rst) cnt <= 'b0;\n  else     cnt <= cnt + 1;\nend\n\nassign dataOut = (cnt == 0) ? dataIn [7:0]   :\n                 (cnt == 1) ? dataIn [15:8]  :\n                 (cnt == 2) ? dataIn [23:16] :\n                 (cnt == 3) ? dataIn [31:24] :\n                  '0;\n\nendmodule\n```\n\n\nIncase if you don't want to write it seperately for loop will come in handy to make it more simple \n\nb)\n\n```\nmodule top ( input             rst,clk,\n             input      [31:0] dataIn,\n             output reg [7:0]  dataOut);\nreg [1:0] cnt;\ninteger i;\nalways @(posedge clk) begin\n  if (rst) cnt <= 'b0;\n  else     cnt <= cnt + 1;\nend\n\nalways @ * begin\n  for ( i =0;i < cnt ; i=i+1) begin \n    dataOut <= dataIn[(i*8)+:8]; end\nend\n\nendmodule\n```\n\n\nI have tried both with test cases and found to be working, tc's present @\n\na) [http://www.edaplayground.com/x/VCF](http://www.edaplayground.com/x/VCF)\nb) [http://www.edaplayground.com/x/4Cg](http://www.edaplayground.com/x/4Cg)\n\nYou may want to give it a try\n", "accept": false, "score": 1}, {"body": "The reason why the assignment failed (besides your code not doing any serialization) is because you didn't declare `dataOut` as a `reg`, and so you cannot assign to it inside an `always` block.\n\nHere's how you do it correctly. (Since you didn't say in which order you wanted to serialize, I chose to go for lowest byte first, highest byte last. To reverse the order, exchange `>>` by `<<` and `tmp[7:0]` by `tmp[31:24]`.)\n\n```\nmodule ser32to8(\n    input clk,\n    input [31:0] dataIn,\n    output [7:0] dataOut\n);\n\n// count: 0, 1, 2, 3, 0, ... (wraps automatically)\nreg [1:0] count;\nalways @(posedge clk) begin\n    count <= count + 2'd1;\nend\n\nreg [31:0] tmp;\nalways @(posedge clk) begin\n    if (count == 2'd0)\n        tmp <= dataIn;\n    else\n        tmp <= (tmp >> 8);\nend\n\nassign dataOut = tmp[7:0];\n\nendmodule\n```\n\n", "accept": false, "score": 3}, {"body": "How can you just take part of your dataIn data? By using the [] notation. dataIn[7:0] takes the 8 least significant bits, dataIn[15:8] takes the next 8 bits, and so on up to dataIn[31:24] which would take the 8 most significant bits.\n\nTo apply this to your problem, you can do like this (take into account that this is not an optimal solution, as outputs are not registered and hence, glitches may occur)\n\n```\nmodule ser32to8(\n    input wire clk,\n    input wire [31:0] dataIn,\n    output reg [7:0] dataOut\n    );\n\n    reg [1:0] cnt = 2'b00;\n    always @(posedge clk)\n      cnt <= cnt + 1;\n\n    always @* begin\n      case (cnt)\n        2'd0: dataOut = dataIn[7:0];\n        2'd1: dataOut = dataIn[15:8];\n        2'd2: dataOut = dataIn[23:16];\n        2'd3: dataOut = dataIn[31:24];\n        default: dataOut = 8'h00;\n      endcase\n    end\nendmodule\n```\n\n", "accept": true, "score": 1}, {"body": "You must declare `dataOut` as a reg, since you are using it in always block.Also, you are trying to assign 32 bit `datain` to 8 bit `dataout` , it is not logically correct.\n", "accept": false, "score": 1}, {"body": "You can follow the figure below to design your circuit. Hope it can be useful with you. If you need the code, feel free to contact me.\n\n[SER 112 bits with 8 outputs in parallel](https://i.stack.imgur.com/6FWeR.png)\n", "accept": false, "score": 0}], "score": [1.0, 0.095059895427982, 2.0, 2.8917001884960012e-242, 0.0]}
{"question": "I have floating point number in `verilog` , I wanna shift it to right to make IEEE standard, but I don't know where the point is, to understand if it is standard or not(to stop shifting) .\n\nwhat can I do?\n\nsecond question:\nif i shift floating point like this: 10001.11 to right what does happen in verilog? 0100.111 or 0100.11 ?\n\n[IEEE standard](http://pages.cs.wisc.edu/~markhill/cs354/Fall2008/notes/flpt.apprec.html)\n", "answer": [{"body": "[IEEE 1800-2012](http://standards.ieee.org/getieee/1800/download/1800-2012.pdf) the latest SystemVerilog specification states:\n\n> The real literal constant numbers shall be represented as described by IEEE Std 754, an IEEE standard for\n  double-precision floating-point numbers.... \n  The real* data type is the same as a C double. The shortreal data type is the same as a C float. The realtime declarations shall be treated synonymously with real declarations and can be used interchangeably. Variables of these three types are collectively referred to as real variables* The real and shortreal types are represented as described by IEEE Std 754.\n\n[Wikipedia IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point)\n", "accept": true, "score": 0}, {"body": "One thing to make sure is whether you're dealing with a [floating point](https://en.wikipedia.org/wiki/Floating_point) number, or a [fixed-point](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) number. They are stored very differently in practice, with fixed-point numbers being much easier to process. \n\n- Fixed point numbers are stored the same as any other integer. The difference is when they are interpreted a decimal point is added at a bit position. For example, you could store a 16-but number, but say the last 4 bits are after the decimal point. This is sometimes referred to as 12.4, make sure you comment your code to make this clear. You also need to track whether the number is a positive-only value, or a 2's complement value.- \n\nFor your second question I'm going to assume you're using fixed-point arithmetic. The decimal point is fixed and doesn't move. So for your example:\n\n10001.11 >> 1 = 11000.11 \n\nNote that if your number is signed 2's complement, then MSBs will be copied from the MSB of the number before the shift (this maintains the sign before and after the shift).\n", "accept": false, "score": 0}, {"body": "You tell about fix point operation. Shift operation don't work with float numbers.\n\nVerilog has float type - real, but this type is not for synthesis and don't support oparation >> (shift)\n\nFor float numbers shift is undefined in all languages.\n\nBut if you want to multiply number, you must work with exponent and mantissa parts\n", "accept": false, "score": 0}, {"body": "To make it IEEE standard. you need to follow IEEE-754 format for representing floating point numbers. There are different types of floating point representations in the standard.\n\n\n1. half precision(or FP16), where you can have 1 bit for sign, 5-bits for exponent and 10 bits for mantissa.\n2. full precision(or FP32), where you can have 1 bit for sign, 8-bits for exponent and 23-bits for mantissa and so on.\n\n\n\nYou can perform any kind of operations with FP16 and FP32 representations, like addition, subtraction, multiplication etc.\n", "accept": false, "score": 0}], "score": [2.0, 0.0, 0.0, 0.0]}
{"question": "```\nreg a[4:0];\nreg inv_a[4:0];\n\nassign inv_a = ~a; //This doesn't work.\n```\n\n\nWhen I tried modelsim with above statement, it throw: \"Illegal operation on unpacked types\"\n\nCan someone please point out how to correctly negate an array in Verilog?\n\n\n---\n\n\n\n\n\n```\nmodule router_main(\n    input bustorouter_ready[4:0],\n);\n\n  wire inv_bustorouter_ready[4:0];\n\n  assign inv_bustorouter_ready = ~bustorouter_ready; //Still doesn't work.\n```\n\n", "answer": [{"body": "Change your `reg` for a `wire`, as `assign` needs that:\n\n```\nreg [4:0] a;\nwire [4:0] inv_a;\n\nassign inv_a = ~a; //This should work.\n```\n\n\nAlternatively, you can keep `inv_a` as `reg` if you use an `always` block:\n\n```\nreg [4:0] a;\nreg [4:0] inv_a;\n\nalways @*\n  inv_a = ~a; //This should work.\n```\n\n\n`reg a[4:0]` seems to no be the same as `reg [4:0] a`;\n\n`reg a[4:0]` is the same as `reg [0:0] a[4:0]` : an array of 5 registers of 1 bit each.\n\n`reg [4:0] a` is a 5 bit register.\n\nReduction operators, as well as the unary inverter operator (this is bit-wise) operate only on a single vector (register). Your first declaration declared 5 vectors.\n", "accept": false, "score": 3}, {"body": "Try using a `for` loop in a combinatorial process:\n\n```\nalways_comb\n  for (int i = 0; i <= 4; i++)\n    inv_a[i] = ~a[i];\n```\n\n\nSince I guess you're doing design, you'll need to check if your synthesis tool supports this construct.\n\nAlternatively you could use a `generate`:\n\n```\ngenvar i;\nfor (i = 0; i <= 4; i++)\n  always_comb\n    inv_a[i] = ~a[i];\n```\n\n", "accept": false, "score": 4}, {"body": "You can only perform logical operations on packed arrays(bit-vectors). The only operations allowed on unpacked arrays as a whole are copy and compare.\n\nIf you must do this in one line, you can cast the unpacked array to a packed array and back.\n\n```\ntypedef logic  ua5[5];\ntypedef logic bit [4:0] pa5;\nua5 a; // same as reg a[4:0]\nua5 inv_a;\n\nassign inv_a = ua5'(pa'(~a));\n```\n\n\nOtherwise, I would recommend a foreach loop\n\n```\nalways_comb foreach (a[i]) inv_a[i] = ~a;\n```\n\n", "accept": true, "score": 2}, {"body": "A one-line solution to invert an unpacked array achievable via bit streaming (refer to [IEEE Std 1800-2012](https://standards.ieee.org/findstds/standard/1800-2012.html) & sect; 11.4.14  for full details)\n\n```\nlogic a[4:0];\nlogic inv_a[4:0];\n\nassign {<<{inv_a}} = ~{<<{a}}; // bit streaming\n```\n\n\nBit streaming only works in SystemVerilog. If you are limited to only Verilog, then you must use a for-loop or generate-for-loop (see Tudor's [answer](https://stackoverflow.com/a/29460648/1959732)).\n\nAnother thing to consider is if unpacked arrays are necessary. Packed arrays allow access the array as a whole. Verilog does not allow passing unpacked arrays through port connections, packed arrays are allowed. SystemVerilog supports both packed in unpacked arrays as ports. \n\n```\nreg [4:0] a;\nreg [4:0] inv_a;\n\nassign inv_a = ~a; // pack array\n```\n\n\nGeneral it comes down to how you want to access the array. Use packed arrays if you want to be treated as one number; individual elements access is still allowed. Use unpacked if you only intend to access individual elements in the array. For more on packed vs unpacked, refer to these earlier answered questions:\n\n- [SystemVerilog packed array vs unpacked array memory footprint](https://stackoverflow.com/questions/17930807/systemverilog-packed-array-vs-unpacked-array-memory-footprint)- [packed vs unpacked vectors in system verilog](https://stackoverflow.com/questions/477646/packed-vs-unpacked-vectors-in-system-verilog)\n", "accept": false, "score": 5}, {"body": "You can xor it with an array of ones:\n\n```\nassign inv_a = a ^ {WIDTH{1'b1}};\n```\n\n", "accept": false, "score": 0}, {"body": "You can do inversion by using logical operations on packed array.\n\n```\nassign inverted_a = ((a)^(4'b1111));\nX (XOR) 1 = ~X\n```\n\n\nThen you can edit the binary number into the width of your input or register\nlike `7'b11111111` or `3'b111`.\n", "accept": false, "score": -1}], "score": [5.724899575620372e-155, 5.2505050082512235e-155, 4.0, 10.0, 0.0, -1.7945204657297904e-156]}
{"question": "I am trying to code a controller/data-path implementation in Verilog, and I am confused on what will cause an unwanted latch. Essentially, I have a state machine updating on the negedge clock. This state machine sends 5 control signals (loadSquare, loadDelta, addDelta, etc.) to the data-path based on what state the machine is in. The code for the data-path and controller is shown below.\n\n\n\n```\n//Control lines\nreg addSquare, addDelta, decDelta;\nreg loadSquare, loadDelta;\n\n//Input lines\nreg [8:0] square, delta;\n\n//Output register\nreg [7:0] outReg;\n\nalways @(posedge clk) begin\n  if (loadSquare)\n     square = 9'h1;  //used on initialization\n\n  if (loadDelta)\n     delta = 9'h3;   //used on initialization\n\n  if (addSquare)\n     square = square + delta; \n\n  if (addDelta)\n     delta = delta + 2'h2;\n\n  if (decDelta)\n     outReg = (delta>>1) - 1;  //used for output\n  else\n     outReg = Input;\nend\n```\n\n\n\n\n```\n//Output of module\nassign Output = outReg;\n\n//Finite State Machine\nalways @(currentState) begin\n    case(currentState)\n        2'h0:   begin       //initialize values, wait for start\n        {loadSquare, loadDelta} = 2'b11;\n        {addSquare, addDelta, decDelta} = 3'h0;\n     end\n        2'h1: begin\n        {loadSquare, loadDelta} = 2'b00;\n        {addSquare, addDelta, decDelta} = 3'b110;  //add square and delta\n     end\n        2'h2: begin\n        {loadSquare, loadDelta} = 2'b00;\n        {addSquare, addDelta, decDelta} = 3'b001;  //decrement delta, wait for reset\n     end\n        default: ; // unused\n    endcase\n\n//Next state logic implemented on negedge clk (not shown)\n```\n\n\nThis code generates the following warnings in Xilinx:\n\n```\nWARNING:Xst:737 - Found 1-bit latch for signal <addDelta>. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.\nWARNING:Xst:737 - Found 1-bit latch for signal <decDelta>. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.\nWARNING:Xst:737 - Found 1-bit latch for signal <loadDelta>. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.\nWARNING:Xst:1294 - Latch <loadDelta> is equivalent to a wire in block <ModuleName>.\nWARNING:Xst:1294 - Latch <decDelta> is equivalent to a wire in block <ModuleName>.\nWARNING:Xst:1294 - Latch <addDelta> is equivalent to a wire in block <ModuleName>.\n```\n\n\nI understand that incomplete if statements cause latches. In order to try to account for this, I have tried 2 different implementations but they do not remove the warnings. I am especially confused for the \"decDelta\" case because I don't understand what I am not accounting for in this conditional statement.\n\n\n\n```\nalways @(posedge clk) begin\n  if (loadSquare)\n     square = 9'h1;\n  else\n     square = square;\n\n  if (loadDelta)\n     delta = 9'h3;\n  else\n     delta = delta;\n\n  //... and so on\n```\n\n\n\n\n```\nalways @(posedge clk) begin\n  square = square;\n  delta = delta;\n\n  if (loadSquare)\n     square = 9'h1;\n\n  if (loadDelta)\n     delta = 9'h3;\n\n  //... and so on\n```\n\n\nThe code works as expected when I run a simulation, but I wanted to learn a little more about what causes these warnings. \n", "answer": [{"body": "Latches are inferred when a variable will have to  its previous value, if it is  a value in an always block. A latch must be created to  this present value.\n\n can cause various . Unwanted latches create a  feedback in a , i.e. it routes the output back to the input - which can be unpredictable causing unstable circuit behavior.\n\nAn  `if-else` statement will generate unwanted latches. An if-else statement is considered \"incomplete\" if the one of the condition is not defined for all possible input conditions. Similarly, an incomplete `case` statement, that does not have a `default` statement can also infer to latch.\n\nA  `if-else` statement refers to the following Mux:\n\n[](https://i.stack.imgur.com/rUHN7.gif)\n\nWhile and  `if-else` refers to a  from output to input, in order to  the previous value. Similar applies to `case` statement.\n\n[](https://i.stack.imgur.com/D18Rb.gif)\n\nAs a rule, combinational loops must be avoided: \n\n> A general intention of a combinational circuit is that the output is a function of input only and the circuit should not contain any internal\n  state (i.e., memory).\n\nAs a , verilog standard specifies that a variable must retain/hold its  if it is not assigned a value in an always block. This is the root cause of latch creation.\n\nTo  the latches, following points must be kept in mind:\n\n- `if``case`- \n\nHere, to avoid latch creation, either you can else branch and explicitly\nassign all output variables, such that other input is .\n\n```\nif (loadSquare)\n     square <= 9'h1;  //used on initialization\nelse\n     square <= 9'h0;  // similar for all the variables\n```\n\n\nAnother  is to assign a  value at every clock tick.\n\n```\nalways @ (posedge clk)\nbegin\nsquare <= 9'h0;    // similar for all the variables\nif (loadSquare)\n     square <= 9'h1;  //used on initialization\nend\n```\n\n\n : I've used  assignments statements here, for proper flip-flop synthesis.\n\nFor detailed synthesis information, refer to [FPGA prototyping by Verilog examples by Pong P. Chu](https://www.google.co.in/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0CBwQFjAAahUKEwjmnrzhz4zJAhXPG44KHfzDAAY&url=https%3A%2F%2Ffpga.googlecode.com%2Ffiles%2FFPGA%2520Prototyping%2520By%2520Verilog%2520Examples.pdf&usg=AFQjCNHWKu14n0aUrRsZUmcA3iajniogqA&sig2=C1jHt1_Qk2KUvFCQeTkmIQ&bvm=bv.107467506,d.d24) pdf. Also, [this](https://electronics.stackexchange.com/questions/38645/why-are-inferred-latches-bad) and [this](https://stackoverflow.com/questions/22459413/what-is-inferred-latch-and-how-it-is-created-when-it-is-missing-else-statement-i) links about latch creation may be useful. \n\nImage courtesy [doulous.com](https://www.doulos.com/knowhow/verilog_designers_guide/synthesizing_latches/).\n", "accept": false, "score": 1}, {"body": "The latches are cause by the state machine logic. The following always block is sensitive to `currentState` and not to a clock. This is not , but needs some extra precautions to hinder latch creation:\n\n\n1. use a default case OR\n2. use default assignments OR\n3. use a different FSM pattern\n\n\n\nHere is your code with my additions using default assignments:\n\n```\n//Finite State Machine\nalways @(currentState) begin\n    // default assignments\n    {loadSquare, loadDelta} = 2'b0;\n    {addSquare, addDelta, decDelta} = 3'h0;        \n\n    case(currentState)\n      2'h0:   begin       //initialize values, wait for start\n        {loadSquare, loadDelta} = 2'b11;\n        {addSquare, addDelta, decDelta} = 3'h0;\n      end\n      2'h1: begin\n        {loadSquare, loadDelta} = 2'b00;\n        {addSquare, addDelta, decDelta} = 3'b110;  //add square and delta\n      end\n      2'h2: begin\n        {loadSquare, loadDelta} = 2'b00;\n        {addSquare, addDelta, decDelta} = 3'b001;  //decrement delta, wait for reset\n      end\n      default: ; // unused\n    endcase\n\n//Next state logic implemented on negedge clk (not shown)\n```\n\n\nFor further information on latch creation have a look at @sharvil111's answer. He addresses this topic in a more general way.\n", "accept": false, "score": 0}, {"body": "A latch is a basic memory element, it is open or closed ie it is level sensitive. A flip-flop is basically two latches with one operating on the invert of the enable signal, this makes it edge sensitive.\n\nWhen using `always @(posedge clk)` you have implied a flip-flop that loads data values on the rising edge of `clk`. Latches do not get implied inside this process (`always @(posedge clk)`).\n\nAs Sharvil111 has described latches are implied when you have left undefined states in combinatorial sections ie `always @*` processes. If some thing is undefined in part of a conditional then it retains its value. Value retention is state, and since combinatorial sections are not edge sensitive you have forced the tool to insert a latch.\n\nTo avoid this fully define the conditional output:\n\n```\nalways @(currentState) begin\ncase(currentState)\n    2'h0:   begin       //initialize values, wait for start\n    {loadSquare, loadDelta} = 2'b11;\n    {addSquare, addDelta, decDelta} = 3'h0;\n end\n    2'h1: begin\n    {loadSquare, loadDelta} = 2'b00;\n    {addSquare, addDelta, decDelta} = 3'b110;  //add square and delta\n end\n    2'h2: begin\n    {loadSquare, loadDelta} = 2'b00;\n    {addSquare, addDelta, decDelta} = 3'b001;  //decrement delta, wait for reset\n end\n    default: begin\n    {loadSquare, loadDelta} = 2'b00;\n    {addSquare, addDelta, decDelta} = 3'b000;\n    end\nendcase\n```\n\n", "accept": true, "score": 1}, {"body": "A latch is inferred when a variable within a combinational block is not assigned a value within all possible permutation of the blocks functionality.\n\n```\ncase(currentState)\n2'h0:   begin       //initialize values, wait for start\n  {loadSquare, loadDelta} = 2'b11;\n  {addSquare, addDelta, decDelta} = 3'h0;\nend\n2'h1: begin\n  {loadSquare, loadDelta} = 2'b00;\n  {addSquare, addDelta, decDelta} = 3'b110;  //add square and delta\nend\n2'h2: begin\n  {loadSquare, loadDelta} = 2'b00;\n  {addSquare, addDelta, decDelta} = 3'b001;  //decrement delta, wait for reset\nend\ndefault:  ; // unused // <-- not assigned so assumed keep; inferred latches\nendcase\n...\n```\n\n\nDoing something like `addSquare = addSquare;` is still an inferred latch. `addSquare` (and all the other variables) needs to be assigned to a constant, a flop (edge sensitive flip-flop), or combinational function terms of constants and flop values.\n\nIf you truly do not need `addSquare` (and all the other variables), then just assign them to a constant in the `default` condition.\n\nIf you do need to keep the value, then you need to add a flop that is synchrously assigned to the variable. In the `default` condition, the variable needs to be assigned to the flop. Example:\n\n```\nalways @(posedge clk) begin\n  ...\n  addSquare_keep <= addSquare;\n  ...\nend\nalways @* begin\n  ...\n  case(currentState)\n  ...\n  default : begin\n    ...\n    addSquare = addSquare_keep;\n    ...\n  end\n  endcase\n  ...\nend\n```\n\n", "accept": false, "score": 0}], "score": [1.0, 0.0, 2.0, 0.0]}
{"question": "Is the following code is supported in SystemVerilog?\n\n```\nint cnt = 0;\nwait( cnt == (cnt+1) )\n```\n\n\nCould any one point me the section in LRM?\n", "answer": [{"body": "I guess the answer depends on what you mean by ? You are certainly allowed to write expressions that make no sense and would always result in false (1'b0). That would cause the  statement to hang and suspend whatever process executed it. \n", "accept": false, "score": 3}, {"body": "This is supported. But the main question is, what will you get by such wait statement, as .\n\nMay be I can help you, if you provide more details on, what you exactly want to do through this wait statement.\n\nMeanwhile, here is the code, as per your wait statement, with it's output. This will help you to understand, what this wait statement will do: \n\n```\n// Sample code, as per your wait statement\nmodule top();\n  int cnt;\n  bit clk;\n\n  always #5 clk = ~clk;\n\n  always @ (posedge clk)\n    cnt <= cnt + 1;\n\n  initial\n    begin\n      $display(\"***** Before wait *****\");\n      wait(cnt == (cnt + 1))\n      $display(\"***** After wait *****\");\n    end\n\n  initial #100 $finish;\n  initial $monitor(\"cnt - %0d\", cnt);    \nendmodule\n\n// Output of this sample code\n***** Before wait *****\ncnt - 0\ncnt - 1\ncnt - 2\ncnt - 3\ncnt - 4\ncnt - 5\ncnt - 6\ncnt - 7\ncnt - 8\ncnt - 9\ncnt - 10\n$finish called from file \"testbench.sv\", line 20.\n$finish at simulation time                  100\n```\n\n", "accept": true, "score": 5}, {"body": "Yes it is supported. You would not get any compilation error even if logically you know it is going to hang. (If that was your intention while asking)\n\n\"wait\" statement is level sensitive and will wait infinitely till the expression is evaluated to be true. It is usually used to wait for an event before executing another event or to delay the execution of the code till some event has occurred.\n\nSince in systemverilog the threads are created dynamically, synchronization between events is necessary and that is where wait statements can be used.\n\nLRM section where you can read more about wait statement: 9.4.3 (Level sensitive event control)\n", "accept": false, "score": 1}, {"body": "Instead of the `uvm_event` you could use SystemVerilog's own event type. This removes the dependency to the `uvm_pkg`.\n\n```\nclass container;\n  event from_a;\n\n  task a();\n    ...\n    -> from_a;\n    ...\n  endtask\n\n  task b();\n    ...\n    @ from_a;\n    ...\n  endtask\nendclass\n```\n\n\nYou can find a lot about interprocess communication (mailbox, semaphore, mutex, events) @ LRM Chapter 15.\n", "accept": false, "score": 0}], "score": [6.0, 10.0, 9.148398098099071e-233, 0.0]}
{"question": "I would like to write a module with a variable number of inputs, i.e. depending on some parameter, the result would be:\n\n```\nmodule my_module #(LENGTH)(\n    input clk,\n    input rst_n,\n    input [LENGTH-1:0] data_1\n);\n//...\nendmodule\n```\n\n\nor\n\n```\nmodule my_module #(LENGTH)(\n    input clk,\n    input rst_n,\n    input [LENGTH-1:0] data_1,\n    input [LENGTH-1:0] data_2,\n    input [LENGTH-1:0] data_3\n);\n//...\nendmodule\n```\n\n\nWould it be possible to do this in Verilog or Systemverilog or would I have to write a script, let's say in Python, in order to generate the code for a specific module with fixed number of inputs? (it might be more than 1000 inputs)\n", "answer": [{"body": "There are no variable number of ports in SystemVerilog, but you could use a port that is a parameterized array.\n\n```\nmodule my_module #(int LENGTH, DEPTH)(\n    input clk,\n    input rst_n,\n    input [LENGTH-1:0] data[DEPTH]\n);\n//...\nendmodule\n```\n\n\nOtherwise, you would need to use a script to generate the code.\n", "accept": true, "score": 4}, {"body": "Use a two dimensional input with a parameterized size. Added a  that can be used to set signals individually. Although many operations can be done with smart array operations.\n\n```\nmodule my_module #(SIZE, LENGTH)(\n    input clk,\n    input rst_n, \n    input [SIZE-1:0][LENGTH-1:0] data_in_array,\n    output [SIZE-1:0][LENGTH-1:0] data_out_array\n);\ngenvar N;\ngenerate for (N=0; N<SIZE; N++) begin :la_coolOps\n    //Do cool operations here. For example instantiate a module for every data_in\nend\n//...\nendmodule\n```\n\n\nEdit:\nAs Mehran Torki points out: The syntax above will work for SystemVerilog only. Verilog does not allow for multiple packed arrays. Use `input [LENGTH*SIZE-1:0] data_in_array`.\n", "accept": false, "score": 3}, {"body": "As others said, there is no direct way to do this, but another workaround is to use SystemVerilog interfaces, where you define all the inputs that you want in the interface definition and inside the module only use the ones that correspond to the parameter. Below is a sample:\n\n```\nmodule my_module #(LENGTH)(\n       input clk;\n       input rst_n;\n       output o;\n       interface i_data;\n    );\n    logic outValue;\n\n    generate\n        case (LENGTH) //Based on the value of LENGTH, use corresponding data\n            1: outValue = i_data.data_1;\n            2: outValue = i_data.data_1 + i_data.data_2;\n            3: outValue = i_data.data_1 + i_data.data_2 + i_data.data_3;\n        endcase \n    endgenerate\n\n    always @(posedge clk) begin\n    if (~rst_n)\n        o <= '0;\n    else\n    begin\n        o <= outValue;\n    end\n\nendmodule\n```\n\n\nYou can still use a parameterized array for data and a for-generate loop if your outputs are similar.\n", "accept": false, "score": 1}, {"body": "I would add to these other answers that ports are just groupings of wires. While having 3, 1-bit wires named a, b, and c might be easier to read and understand, there is no physical/logical difference between a single, 3-bit wire `abc`, where `abc[0]` corresponds to `a`, `abc[1]` corresponds to `b`, and `abc[2]` corresponds to `c`.\n\nSo, you can always just expand or shrink a single (or multiple) signal(s) to get however many bits you need. It may not be as neat, but it will work. In the receiving module, you can then part-select the bus in whatever manner you like. So, you could have one really long wire the shrinks or expands (`wire [(SOME_PARAM*8)-1:0] my_input_wire`), or with SystemVerilog an array (`wire [7:0] my_input_wire[0:SOME_PARAM-1]`)\n\nIf this is just testbench/verification code, the other thing you could do in SystemVerilog is use a dynamic array\n", "accept": false, "score": 2}, {"body": "With System verilog we can import a package instead of having parameterization and define types in the package to be used in the portlist.\n```\nmodule mymodule\n  import mymodule_pkg::*;\n(\n    input portlist_t portlist\n);\nendmodule\n```\n\nAnd define multiple copies of the package with different variants of the port list and compile whichever version is required. eg\n```\npackage mymodule_pkg;\n\n   localparam LENGTH=5;\n\n   typedef struct packed {\n      logic [LENGTH-1:0] data_1,\n      logic [LENGTH-1:0] data_2,\n      logic [LENGTH-1:0] data_3\n   } portlist_t;\n\nendpackage\n```\n\nAs with the interface solution there will be situations where you run into issues, like having different iterations of the module instantiated together.\n", "accept": false, "score": 0}], "score": [8.0, 1.723134809402494e-79, 4.109745422612205e-79, 4.0, 0.0]}
{"question": "I'm trying to bit shift a value in verilog such that the replaced bits are 1's instead of 0's. i.e. I want to do `0001 << 1` such that it gives `0011` instead of `0010`\n", "answer": [{"body": "Would you be able to do something like:\n\n`(x << 1) + 1`\n\nor\n\n`(x << 1) | 1` \n", "accept": false, "score": 0}, {"body": "the command '<<' you use, puts zeros for remaining bits.\nyou can do like the following code:\n\nimagine you have 4 bit variable (like your example) called A.\n\n```\nA = 4'b0000; \nA = {A[2:0], 1'b1};\n```\n\n\nwith concatenation you can put one's instead of zeros.\n\nor you can use 'or' function for this issue:\n\n```\nA = (A << 1) | 4'b0001;\n```\n\n", "accept": true, "score": 7}, {"body": "To have the shift work with up to the number of bits the following example pre pads the input with 1's shifts then selects the MSBs:\n\n```\nlocalparam WIDTH = 4;\n// Create temp with 1's as padding\nwire [WIDTH*2 -1 :0] pad   = {A, {4{1'b1}}};\nwire [WIDTH*2 -1 :0] shift = pad << 1;\n\n// Select MSB with 1's shifted in\nwire [WIDTH-1 : 0] result = shift[WIDTH*2 -1 : WIDTH];\n```\n\n", "accept": false, "score": 0}, {"body": "You could do this:\n\n```\nmodule ones_shift #(log2_width=2) (input [(2**log2_width)-1:0] A,  input [log2_width:0] SHIFT, output [(2**log2_width)-1:0] As);\n\n  wire [(2**log2_width)-1:0] Ai, Ais;\n\n  assign Ai = ~A;\n  assign Ais = Ai << SHIFT;\n  assign As = ~Ais;\n\nendmodule\n```\n\n\nie BITWISE INVERT -> LOGICAL SHIFT LEFT -> BITWISE INVERT\n\nThis will work for any valid shift value.\n\n[http://www.edaplayground.com/x/YWK](http://www.edaplayground.com/x/YWK)\n", "accept": false, "score": 1}, {"body": "We can use this,\n\na = (1'b1 << count) - 1;\n\nAssign count to a value equal to the no.of 1's to be filled from LSB.\n", "accept": false, "score": 0}, {"body": "```\nfunction bit[31:0] cal_mask_value (int size);\n    bit [31:0] mask_value;\n\n    mask_value = 32'hFFFFFFFF << size;\n    mask_value = ~mask_value;\n    return mask_value;\nendfunction\n```\n\n", "accept": false, "score": 0}, {"body": "x |= x<<1; // assumes x starts as 1\n", "accept": false, "score": 0}], "score": [0.0, 14.0, 0.0, 3.516989410990218e-79, 0.0, 0.0, 0.0]}
{"question": "I am having trouble initializing the contents of an inferred ram in Verilog. The code for the ram is as below:\n\n```\nmodule ram(\n        input clock, // System clock\n        input we, // When high RAM sets data in input lines to given address\n        input [13:0] data_in, // Data lines to write to memory\n        input [10:0] addr_in, // Address lines for saving data to memory\n        input [10:0] addr_out, // Address for reading from ram\n        output reg data_out // Data out\n);\n\nreg [13:0] ram[2047:0];\n\n// Initialize RAM from file\n// WHAT SHOULD GO HERE?\n\nalways @(posedge clock) begin\n    // Save data to RAM\n    if (we) begin\n        ram[addr_in] <= data_in;\n    end\n\n    // Place data from RAM\n    data_out <= ram[addr_out];\nend        \nendmodule\n```\n\n\nI have run into the command $readmemh. However, documentation for it seems sparse. How should I format the file that contains the data? Also, how can I pass the file as argument when instantiating this module so that I can have different instances of this module load from different files?\n\nI want the initialized content to be available for both simulation and actual implementation. So that the FPGA already boots with this content in RAM.\n\nI am using Vivado 2015.4 to program a Kintex xc7k70 FPGA.\n", "answer": [{"body": "You are correct that you should use `$readmemh` inside an initial block. In order to make it so different instances of the module can have different initialization files, you should use a parameter like so:\n\n```\nparameter MEM_INIT_FILE = \"\";\n...\ninitial begin\n  if (MEM_INIT_FILE != \"\") begin\n    $readmemh(MEM_INIT_FILE, ram);\n  end\nend\n```\n\n\nThe format is described in Section 21.4 of the IEEE1800-2012 specification; typically the file is just a bunch of lines containing hex numbers of the correct bit-length, like so:\n\n```\n0001\n1234\n3FFF\n1B34\n...\n```\n\n\nNote that there is no \"0x\" prefix and each line represents an adjacent address (or any separating whitespace). In the example above, `$readmemh` would put `14'h0001` into `ram[0]`, `14'h1234` into `ram[1]`, `14'h3FFF` into `ram[2]` and so on. You can also include comments in the hex file using `//` or `/* */`. Finally, you can use the `@` symbol to designate an address for the following numbers to be located at, like so:\n\n```\n@0002\n0101\n0A0A\n...\n```\n\n\nIn the above file, `ram[0]` and `ram[1]` would be uninitialized and `ram[2]` would get `14'h0101`. Those are all the major constructs of the hex file format, though you can also use `_`, `x` and `z` as you would in other Verilog numbers and theres a few more rules you can read in the section sited above.\n", "accept": true, "score": 13}, {"body": "Apart from @Unn's excellent ans, I want to add that, If you just want to initialize your memory with either all bits to `1'b1` or `1'b0`, then you can just put following code,\n\n```\ninteger j;\ninitial \n  for(j = 0; j < DEPTH; j = j+1) \n    ram[j] = {WIDTH{MEM_INIT_VAL}};\n```\n\n\nFor your case, WIDTH=14, and MEM_INIT_VAL may be `1'b1` or `1'b0`.\n", "accept": false, "score": 5}, {"body": "```\ninteger j;\ninitial \n  for(j = 0; j < DEPTH; j = j+1) \n    ram[j] = j;\n```\n\n\nThis might be easy in case of debug, where the value of a location is its location number.\n\nAlso, I would suggest you to not initialize the RAMs. It will help you in catching bugs, if any, in simulation as the data driven will be 'x if RAM is un-intialized and can be caught easily.  \n", "accept": false, "score": -3}, {"body": "Since your question cited the #xilinx and #vivado tags, I wanted to suggest that you can also use the `xpm_memory` family of primitives to instantiate a parameterized memory.  The advantages of this approach:\n\n1. Exports exactly the hardware capabilities of the memory resources on the FPGA (ie, makes you think clearly about limitations such as memory ports).\n2. Guarantees correct identical behavior in simulation and benchtop for memory primitives.\n3. You can allow Vivado to choose the most efficient memory implementation (BRAM, UltraRAM, distributed RAM, flops) at synthesis time, according to your design constraints.\n4. Easy to fine tune (enable or disable internal pipeline stages, etc.).\n\n\nWith that said, purely inferred memories are often easier to code.  But, it's still worth getting familiar with the Xilinx-provided memory primitives so that you'll have a clearer idea of what Vivado can easily synthesize, and what it can't.\nFor more information, see UG573, the Vivado Memory Resources User Guide:\n[https://www.xilinx.com/support/documentation/user_guides/ug573-ultrascale-memory-resources.pdf](https://www.xilinx.com/support/documentation/user_guides/ug573-ultrascale-memory-resources.pdf)\n", "accept": false, "score": 0}], "score": [26.0, 2.3096566538628903e-158, -3.0, 0.0]}
{"question": "I need to load a memory with some data originally in binary. I read that $readmemb can be use for this, and there is even a method to make synthesizable.\n\nSo, I created another module named RAM_IN (which is not the testbench module) and \"connected\" to the top module.\n\nBefore knowing about $readmemb, I was using this code:\n\n```\ninitial\nbegin\nin_ram [0] <= 32'b11111111_000000000000000000000000; \nin_ram [1] <= 32'b10010111_000000000000000000000000;\nin_ram [2] <= 32'b00110110_000000000000000000000000;\nin_ram [3] <= 32'b00111110_000000000000000000000000;\nin_ram [4] <= 32'b00111111_000000000000000000000000;\nin_ram [5] <= 32'b00111110_000000000000000000000000;\nend\n```\n\n\nBut its too tiring for me to write 100 numbers like this, so implemented $readmemb like this:\n\n```\nmodule RAM_IN (pix_val, indx);\n\n\ninput [0:5] indx;\noutput [31:0] pix_val;\n\n\nreg [31:0] pix_val;\nreg [31:0] in_ram [0:4];\n\nalways @ (indx)\npix_val = in_ram [indx];\n\ninitial\nbegin\n$readmemb(\"in_ram.txt\", in_ram);\nend\n```\n\n\nThe purpose of reading this file, is to initially load 100 binary values (wich simulate the pixel intensity of a 10x10 image) one by one into the top module (which is going to process and spit a result later...) \n\nI created a .txt file which looks content exactly like this\n\n```\n11111111000000000000000000000000\n10010111000000000000000000000000\n00110110000000000000000000000000\n00111110000000000000000000000000\n00111111000000000000000000000000\n```\n\n\nWhen I simulate, modelsim show me memory filled with xxxxxxxxxxxxxxxxx (dont care), it looks like isn't loading anything to the memory.\n\nI don't know what I'm doing wrong. Likely isnt the dispossition of the numbers in the .txt file. Maybe is because I'm intending to load file with $readmemb in another module which is not testbench?\n\nPD: The simulation of this process of filling the memory I'm doing only for practical purpose, the final intention is to put the Top module design into a full SoC which I think I will do using QSYS. But I'm very new at this so I'm still studying. Any help will be much appreciated!!!\n", "answer": [{"body": "Are you sure you run simulation?\n\nYour code with TB:\n\n```\nmodule RAM_IN (pix_val, indx);\n\ninput [0:5] indx;\noutput [31:0] pix_val;\n\nreg [31:0] pix_val;\nreg [31:0] in_ram [0:4];\n\nalways @ (indx)\n  pix_val = in_ram [indx];\n\ninitial\nbegin\n  $readmemb(\"in_ram.txt\", in_ram);\nend\n\nendmodule\n\nmodule tb;\nreg [0:5] indx; \nwire [31:0] pix_val;\n\nRAM_IN ram_in(pix_val, indx);\n\ninitial\nbegin\n  indx = 'b0;\n  $monitor ($realtime, \" Read Data = %0b\" ,pix_val);\n  repeat(4)\n  begin\n    #10;\n    indx = indx + 1'd1;\n  end\n  $finish;\nend\nendmodule\n```\n\n\nWith same in_ram.txt.\n\nQuestasim:\n\n```\nQuestaSim-64 qverilog 10.4 Compiler 2014.12 Dec  2 2014\nStart time: 18:27:01 on May 10,2016\nqverilog me.v \n-- Compiling module RAM_IN\n-- Compiling module tb\n\nTop level modules:\n    tb\nReading pref.tcl\n\n# 10.4\n\n# vsim -lib work tb -c -do \"run -all; quit -f\" -appendlog -l qverilog.log -vopt \n# ** Note: (vsim-3812) Design is being optimized...\n# //  Questa Sim-64\n# //  Version 10.4 linux_x86_64 Dec  2 2014\n# //\n# //  Copyright 1991-2014 Mentor Graphics Corporation\n# //  All Rights Reserved.\n# //\n# //  THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION\n# //  WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS\n# //  LICENSORS AND IS SUBJECT TO LICENSE TERMS.\n# //  THIS DOCUMENT CONTAINS TRADE SECRETS AND COMMERCIAL OR FINANCIAL\n# //  INFORMATION THAT ARE PRIVILEGED, CONFIDENTIAL, AND EXEMPT FROM\n# //  DISCLOSURE UNDER THE FREEDOM OF INFORMATION ACT, 5 U.S.C. SECTION 552.\n# //  FURTHERMORE, THIS INFORMATION IS PROHIBITED FROM DISCLOSURE UNDER\n# //  THE TRADE SECRETS ACT, 18 U.S.C. SECTION 1905.\n# //\n# Loading work.tb(fast)\n# run -all\n# 0 Read Data = 11111111000000000000000000000000\n# 10 Read Data = 10010111000000000000000000000000\n# 20 Read Data = 110110000000000000000000000000\n# 30 Read Data = 111110000000000000000000000000\n# ** Note: $finish    : me.v(34)\n#    Time: 40 ns  Iteration: 0  Instance: /tb\n# End time: 18:27:02 on May 10,2016, Elapsed time: 0:00:01\n# Errors: 0, Warnings: 0\n```\n\n\nAnd Simulation:\n\n[](https://i.stack.imgur.com/BEsAP.png)\n", "accept": false, "score": 4}, {"body": "I already fixed this. The problem is that modelsim couldn't find the .txt file, I don't know where could be the predetermined location for such of files, but looking in internet, I found that I can declare in the Ram module, the exact path like this\n\n```\ninitial\nbegin\n$readmemb(\"C:/altera/15.0/Prueba5/in_ram.txt\", in_ram);\nend\n```\n\n\nNow modelsim is loading the correct data. Thanks everybody.\n", "accept": true, "score": 2}, {"body": "Pasting a copy of the initialization data file (e.g. \"in_ram.txt\") into the project's ..\\simulation\\modelsim\\ directory also resolved this issue for me.\n", "accept": false, "score": 0}, {"body": "I was getting the same issue. It was due to other than binary characters present in the file.\nInitially my .txt file was looking like .txt file I am reading\n![.txt file I am reading](https://i.stack.imgur.com/icBV1.png)\nThen I removed all the \"-\" and it worked. Please check .txt file once if any character is misprinted.\n", "accept": false, "score": 0}], "score": [3.2174922080318446e-78, 4.0, 0.0, 0.0]}
{"question": "Quartus 11.0 says:\n\n> Error (10028): Can't resolve multiple constant drivers for net \"n[9]\"\n\nfor the following code:\n\n```\nmodule make_counter(h, clk, P);\n\ninput wire h;\ninput wire clk; \noutput wire P;\nreg r=1'b1;\nreg[9:0] n=10'b0000000000;\n\nalways @(posedge h)\nbegin\n    n<=0;\nend\n\nalways @(negedge clk)\nbegin\nif(n<600) \n    n<=n+1'b1;\n\nif(n==106)  \n    r<=1'b0;\nelse if(n==517)  \n    r<=1'b1;\nelse;\nend\nassign P=r;\n\nendmodule\n```\n\n\n\n---\n\n\n\n[########### image is here ###########](http://i.stack.imgur.com/k5Dmk.png)\n\n\n---\n\n\n\nzhe image is what i want. when flag1 start set n=0, and count clk;\n  when count to flag2, set P=0; when count to red arrow, set P=1;\n", "answer": [{"body": "As the warning says, there are multiple drivers for `n[9]`, and actually all of `n` and `r`, since `n` and `r` are both driven in the `initial` and the `always`, and when synthesizing the design, there can be only one driver for a reg.  And `n` is driven in multiple `always` blocks.\n\nFor synthesis, a reg should be driven from only one `always` block.\n\nFor the multiple always blocks where `n` is driven, combine these to only one, and use only one clock, e.g. `clk`.\n\nIf the purpose is to assign a default value for `n` and `r`, then make that in the declaration, and remove the `initial`, like:\n\n```\nreg r = 1'b1;\nreg[9:0] n = 0;\n```\n\n\nHowever, consider adding a reset signal if possible, then then use this reset signal to assign reset values to the regs, either synchronously or asynchronously.\n", "accept": false, "score": 0}, {"body": "Assuming `h` is synchronous to `clk`, simply sample `h` and figure out when the sample value is low and the current value is high (e.g. `h` rose). This way `n` is assigned within one always block (which is required for synthesis) and everything is is the same clocking domain.\n\n```\nalways @(negedge clk) begin\n  past_h <= h;\n  if(!past_h && h) begin // detect 0->1\n    n <= 10'h000;\n  end\n  else begin\n    n <= n + 1'b1;\n  end\nend\n```\n\n\nIf `h` is asynchronous, then things get more complicated to keep the signal clean. In which case I recommend reading [Clock Domain Crossing (CDC) Design & Verification Techniques](http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf) by Cliff Cummings\n", "accept": true, "score": 0}, {"body": "i think it will help you out. i have compiled this one in xilinx 14.5 synthesis is done.\n\n```\nmodule make_counter(h, clk, P);\n    input wire h;\n    input wire clk; \n\noutput wire P;\nreg r=1'b1;\nreg[9:0] n=10'b0000000000;\n\n\ntask cpu_write;\n   begin\n      @ (posedge h);\n    n <= 0;\n      @ (posedge clk);\n      if(n<600) \n    n<=n+1'b1;\n    if(n==106)  \n        r<=1'b0;\n    else if(n==517)  \n        r<=1'b1;\n    else;\n    end\n  endtask\nassign P=r;\n\nendmodule\n```\n\n", "accept": false, "score": -1}, {"body": "You can try to move the posedge h into the same always block as the negedge clock and sample h and clk based on the input logic. If h goes low before the negedge of clk then something like this may work.\n\n```\nmodule make_counter(h, clk, P);\n\ninput wire h;\ninput wire clk; \noutput wire P;\nreg r=1'b1;\nreg[9:0] n=10'b0000000000;\n\n\n\nalways @(negedge clk, posedge h)\nbegin\nif(h==1'b1)\n    n<=0;\nif(n<600) \n    n<=n+1'b1;\n\nif(n==106)  \n    r<=1'b0;\nelse if(n==517)  \n    r<=1'b1;\nelse;\nend\nassign P=r;\n\nendmodule\n```\n\n", "accept": false, "score": 0}], "score": [0.0, 2.0, -1.0, 0.0]}
{"question": "What is the difference between the following two examples with regards to simulation?\n\nA)\n\n```\nreg a;\ninitial a = 1'b0;\n```\n\n\nand \n\nB)\n\n```\nreg a = 1'b0;\n```\n\n\nIs it different for logic variables?\n", "answer": [{"body": "The end result is the same, i.e., there won't be any difference from the end user perspective.  The difference is that in the first case you are assigning the value during run time, and in the second case you are assigning the value during compile time.\n", "accept": false, "score": 3}, {"body": "The difference is initialization as part of a variable declarations execute before any process started by any `initial` or `always` constructs. If you wrote:\n\n```\nbit clk;\ninitial clk = 1;\nalways #5 clk++;\nalways @(posedge clk) ...;\n```\n\n\nThere is a race condition as to whether the `@(posedge clk)` gets triggered at time 0 or time 10. \nHowever with:\n\n```\nbit clk = 1;\nalways #5 clk++;\nalways @(posedge clk) ...;\n```\n\n\nThere is no race with the above. The first posedge will come at 10 time units.\n", "accept": true, "score": 9}, {"body": "On similar note :  \n\n```\nint val = 0 ; \nint val1 = val + 10 ;\n```\n\n\nwill produce a consistent result as the result is fixed at compile time , where as \n\n```\ninitial val = 0 ; \ninitial val1 = val + 10;\n```\n\n\nwill produce a inconsistent result [ as the ordering of assignment happens at run time and is simulator dependent ] \n", "accept": false, "score": -1}, {"body": "There is an important distinction: You have tagged your question \"verilog\" and \"system-verilog\". Which do you mean? The answer depends on which you mean because the behaviour is different in both.\n\n\n\nBoth \n\n```\nreg a;\ninitial a = 1'b0;\n```\n\n\nand\n\n```\nreg a = 1'b0;\n```\n\n\nwill behave the same way. In  cases, `a` will be initialised at time 0, ie at . This can lead to simulation races and non-deterministic behaviour. For example:\n\n```\nreg a;\ninitial a = 1'b1;\ninitial $display(a);\n```\n\n\nmight display `0` or might display `1` - there is a race between the initial blocks. And  the same thing will happen with this code:\n\n```\nreg a = 1'b1;\ninitial $display(a);\n```\n\n\n\n\n```\nreg a;\ninitial a = 1'b0;\n```\n\n\nand\n\n```\nreg a = 1'b0;\n```\n\n\nwill behave differently. In the first case, `a` will be initialised at time 0, ie at  which again can lead to simulation races and non-deterministic behaviour. However, there is no such problem with this code:\n\n```\nreg a = 1'b1;\ninitial $display(a);\n```\n\n\nIn this case, `a` will be initialised at  and therefore there is no race and therefore `1` will always be displayed.\n", "accept": false, "score": 3}, {"body": "\n\nAs per system Verilog LRM 1800-2012, Topic 6.8\n\n> A variable can be declared with an initializer, for example: int i = 0; Setting the initial value of a static variable as part of the\n  variable declaration (including static class members) shall occur\n  before any initial or always procedures are started (also see 6.21 and\n  10.5 on variable initialization with static and automatic lifetimes).\n", "accept": false, "score": 2}], "score": [7.809076666487646e-240, 18.0, -2.0, 6.0, 2.8095615937079885e-232]}
{"question": "I was asked this question in an interview. The interviewer asked the question like \" Suppose you have written a code for generating a clock of 250MHz in verilog and synthesized it. Now how will you make sure that the hardware generated will work for 250MHz before emulating it? \" \nI have searched internet regarding this but couldn't find any answer.\n", "answer": [{"body": "Run your clock generating Verilog code on a simulator.  \n\nThe FPGA vendors typically provide simulators with their synthesis tools; or you can use a free simulator, or commercial simulator from an EDA vendor.\n\nSimulators let you look at all of the values of the signals in a design over time, displayed in an intuitive graphical user interface, enabling you to find and fix many problems before you deploy your code on the FPGA.\n", "accept": false, "score": 2}, {"body": "- - \n", "accept": true, "score": 3}, {"body": "Sorry for posting as an answer, don't have reputation for a comment.\n\nI think maybe the answer the interviewer wanted is to use a timing analyzer. \n\nDefine your constraints in an SDC like file and use the vendor timing analyzer to check that the 250MHz clock will indeed work in that given hardware.\n", "accept": false, "score": 1}, {"body": "A netlist created by synthesis or PAR tool, should pass the main steps (not limited to them) below to be verified. FPGA tools have options to write out a gate-level netlist and export the tech library, so third party tools can also be used for these steps.\n\n Static Timing Analysis (STA)\n\nVerifies timing of the netlist regarding the timing constraints defined by the user. Xilinx and Intel (formerly Altera) have built-in tools in their design suites.\n\n Formal/Logic Equivalence Checking\n\nCompares the functionality of RTL and netlist. Since this is a formal process, there is no need to feed input vectors (e.g. testbench).\n\n Gate-level simulations\n\nVerifies both functionality and timing. Usually an SDF (Standard Delay Format) file is fed for timing data of the netlist. SDF can be created by synthesis, STA, or PAR tool.\n", "accept": false, "score": 0}], "score": [4.0, 6.0, 2.0, 0.0]}
{"question": "I have a number \"A\" that is 16 bit wide and is represented in 2's complement. How do I get \"-A\" in verilog?\n", "answer": [{"body": "```\nreg [4:0] num;\nreg  signed [4:0] neg;\n num= 5;   \n$display(\"num= %5b\", num);\n\nneg= -num;  \n$display(\"neg = %d\", neg);\n```\n\n\ncheck this link : [http://www.referencedesigner.com/tutorials/verilog/verilog_58.php](http://www.referencedesigner.com/tutorials/verilog/verilog_58.php)\n", "accept": false, "score": 0}, {"body": "```\nwire [15:0] A;\nwire [15:0] M_A; // Minus A\n\n// The thing about 2's complement, is that the complement can be computed as NEG(x) + 1.\n// In the following way:\nassign M_A[15:0] = ~A[15:0] + 1'b1;\n```\n\n", "accept": true, "score": 1}, {"body": "You can do 2's complement of the stored 2's complement number to get -A.\n\nSuppose here is the example.\n\n```\n- A = 10\n  So in 2's complement A = 0000_0000_0000_0010\n  Now for -A,\n  2's complement of A = 1111_1111_1111_1110 (-10 in 2's complement form)\n\n- A = -20\n  So in 2's complement A = 1111_1111_1110_1100\n  Now for -A,\n  2's complement of A = 0000_0000_0001_0100 (20 in 2's complement form)\n```\n\n", "accept": false, "score": 0}, {"body": "Easiest way I've done it in the past:\n\n```\nwire [7:0] A; \nwire [7:0] neg_A;\n\nassign A = 8'd4;      //  4\nassign neg_A = 0 - A; // -4\n```\n\n\nThe compiler/synthesizer is smart enough to implement a 2's compliment operation in this case and the code is easily readable.\n", "accept": false, "score": 0}], "score": [0.0, 2.0, 0.0, 0.0]}
{"question": "I use Xilinx ISE as a IDE.\nIf I add a 100 ps delay at every assignment in a always(Verilog)/process(VHDL) with sensitive list only have clock and reset.\nLike this.\n\n```\nalways@(posedge clk)\n    if(rst)\n      a <= #100 'd0;\n    else\n      a <= #100 b;\n    end\n```\n\n\nI think the delay function is only effect the simulation process.Because every book and user guide tell us `delay` is not synthesizable. \n\nBut I still wondering if the delay function can really effect the place or route's result?Like static timing or clock report?\nLike can make a circuit max frequency higher or slower?\n", "answer": [{"body": "No the #delay in your code is not going to affect the timing of the design when it is loaded on to the FPGA. \n\nIt also does not affect the place and route results or the static timing analysis. Both of these steps use timing information that is provided by the manufacturer in the form of device models.\n", "accept": false, "score": 3}, {"body": "Delay statements (`#100`) are usually ignored during synthesis in Verilog. So in synthesis it is the same as:\n\n```\nalways@(posedge clk)\n    if(rst)\n      a <= 0;\n    else\n      a <= b;\n    end\n```\n\n\nXlinx [Synthesis and Simuation Design Guide](https://www.xilinx.com/support/documentation/sw_manuals/xilinx11/sim.pdf) states:\n\n> Delays in Synthesis CodeDo not use Wait for XX ns (VHDL) or the #XX (Verilog) statements in\n  your code.  (...) This statement does not synthesize to a component.\n  In designs that include this construct, the functionality of the\n  simulated design does not always match the functionality of the\n  synthesized design.(...)Wait for XX ns Statement Verilog Coding Example`#XX;` Do not use the After XX ns statement in your VHDL code or the Delay\n  assignment in your Verilog code(...)Delay Assignment Verilog Coding Example`assign #XX Q=0;` XX specifies the number of nanoseconds that must pass before a\n  condition is executed. This statement is usually ignored by the\n  synthesis tool. In this case, the functionality of the simulated\n  design does not match the functionality of the synthesized design.\n", "accept": false, "score": 1}, {"body": "You are correct that there's nothing intrinsic about delay statements that makes them unsynthesizable, however it's wildly impractical to attempt to do so.  The reason for this is that once on the FPGA you are dealing with a physical circuit whose performance varies with PVT (process, voltage, temperature) and can do so by a lot!  The only hedge against this would be an analog circuit that attempts to sense all of the above and adjust itself accordingly.  Such a beast will still be limited in what it can do, and would be physically large and power hungry depending on the rage of delay and the variance in all of the above you want to support. \n\nSo with than in mind and considering that there is very little (read: no) demand for this outside of special purpose IO FPGA vendors don't provide any such components making the construct unsythesizable.\n", "accept": true, "score": 2}, {"body": "\"Usually\" there is no impact on synthesis and P&R results.\n\n> Xilinx: This statement is  ignored by the synthesis tool.\n\nWhen does it have impact then?\n\nAlthough the delay statement is ignored by the synthesis tool, the HDL code is a little bit different. That may change the seed of randomization in any stage (parsing, elaboration, synthesis etc.), so there is a possibility for different results. These results may be better or worse.\n\nIf a delay statement exists in the code, the following warning is expected from Xilinx ISE:\n\n> WARNING:Xst:916 - design.v line x: Delay is ignored for synthesis.\n", "accept": false, "score": 0}], "score": [2.989022349025198e-236, 2.7883773975592534e-232, 4.0, 0.0]}
{"question": "I want to convert my lane detection code written by C++ (OpenCV) to FPGA.  or  can help to embed the C ++ code into the FPGA. Or I can rewrite the lane detection code with . The question is, what are the advantages and disadvantages of these three ways? \n \n", "answer": [{"body": "SDSoc is better and easier, HLS like a blackbox, even UG902 have so many pages.\n\nonly my own opinion.\n", "accept": false, "score": 0}, {"body": "Take a look at [Xilinx XAPP1167](https://www.xilinx.com/support/documentation/application_notes/xapp1167.pdf) and the Xilinx [HLS Video Library Wiki](http://www.wiki.xilinx.com/HLS+Video+Library). \n\nThat appnote is a few years old (older than the SDSoC tools) but has a reference design for accelerating OpenCV applications in a Zynq using HLS.\n\nI can't speak to SDSoC, but I would highly recommend starting with HLS over a rewrite in Verilog. It sounds like you have exactly an intended use-case for HLS: to implement existing C++ applications in an FPGA. The downsides to it are (1) you'll likely need to modify your code a bit, since HLS doesn't support all C++ features, and (2) the performance may not be quite as good as a pure Verilog implementation.\n\nEven if you have hardware design experience, manually translating C++ to Verilog will require some significant effort. I'd avoid that approach unless HLS or SDSoC doesn't give you the performance you need.\n", "accept": false, "score": 0}, {"body": "Verilog is considered low-level these days.  Compare it with assembly for software implementation.  People use it only to get performance that they cannot attain with high-level languages such as C or Java in the software domain.\n\nIn the hardware domain, C (for Vivado HLS) or OpenCL are considered high-level languages.  OpenCL was developed with portability to other architectures like GPUs and CPUs in mind.  It has a lot more overhead in terms of communicating with the FPGA than Vivado HLS however.\n\nVivado HLS by itself produces just hardware modules in VHDL or Verilog, which you still have to connect to FPGA pins, ARM processors, etc.  It does not take care of the communication to your module.  You will still have to integrate your module in a Vivado block design or top-level VHDL or Verilog implementation yourself.\n\nSDSoC, not \"Vivado SDSoC\" by the way, also lets you to write your entire implementation (hardware and software) in C.  Under the hood, it will invoke Vivado HLS to implement the hardware module.  Afterwards, the tool will take care of implementing an interface between your hardware and the on-board ARM processors that will run the software.\n\nIn summary, I recommend SDSoC unless you have a good reason not to use it.  I do want to warn, however, that analyzing the synthesis results of Vivado HLS is a lot harder than analyzing Vivado output for Verilog or VHDL.  Therefore, I always recommend to make sure that your code works as a software implementation first.  With minimal effort, you should be able to compile any code in `gcc` or another compiler too.  Don't use the synthesis results to debug your code, but just to analyze the performance.\n", "accept": true, "score": 1}, {"body": "Start using OpenCL SDAccel or Intel SDK. OpenCL has verbose and well defined API - which is a good thing. It is very easy to learn and you can have parallel code execution similar to multi-module instances of Verilog/VHDL. OpenCl vs. HLS has benefits in not requiring to re-invent the whole system for managing data, I/O, pipes. etc. You get quite a bit of helper logic in OpenCL BSP (Intel) or shell (XILINX). Yeah, and start reading these long guides.\n", "accept": false, "score": 0}, {"body": "I would recommend SDAccel, as it is much more C++ \"software\" user friendly. At the same time, don't quote me on this, but I think they provide a OpenCV implementation out of the box, which means that probably you only need to massage you non-OpenCV code to achieve the performance you want.\n", "accept": false, "score": 0}], "score": [0.0, 0.0, 2.0, 0.0, 0.0]}
{"question": "I want to constrain an address in System Verilog so that the address is equal to two the power of value. for example the generated address(16-bit) should be\n\naddr = 0, 2, 4, 8, 16, 32 .... 32,768\n\nThe following works for me. However, I am looking for any other short and elegant way of doing it.\n\n```\nclass two_power_addr;\n  rand bit [15:0] addr;\n  bit [15:0] temp;\n\n  constraint c_addr {\n    addr == temp;\n  }\n\nendclass\n\nmodule tb();\n  two_power_addr c;\n\n  initial begin\n    c=new();\n    c.temp=0;\n    c.randomize();\n    $display(\"%0d \\n\", c.addr);\n    c.temp=16'h2;\n    for(int i=0; i<10; i++) begin      \n      c.randomize();\n      c.temp=c.temp<<1;\n      $display(\"%0d \\n\", c.addr);\n    end\n  end\nendmodule\n```\n\n", "answer": [{"body": "Her is a variant without constrains and classes  which works perfectly well in your case.\n\n```\nbit[3:0] rnd;\n logic address[15:0];\n\n rnd =  $urandom;\n address = 16'b1 << rnd;\n```\n\n\nI guess you can come up with a class randomization for `rnd` if you wish instead of $urandom.\n", "accept": false, "score": 0}, {"body": "You can write your constraint as follow to check whether the randomized value is of 2's power or not.\n\n```\nconstraint 2_power {\n  (addr != 0) -> (addr & (addr - 1)) == 0;\n}\n```\n\n", "accept": false, "score": 2}, {"body": "```\nconstraint c_addr { $onehot0(addr) == 1; }\n```\n\n", "accept": true, "score": 1}, {"body": "Here is one more alternative method to do same. Also I prefer Dave's method more as it is short, power of two can never be 0 so `$onehot0` can be replaced by `$onehot`. But as the question included`addr = 0`, in that case `$onehot0` can be used.\n```\nclass gen#(parameter width = 8);\n\n    rand bit [width-1:0] addr;\n    rand int num;\n  \n    constraint num_c { num inside {[0:width-1]};}\n    constraint pow_2 {  addr == 2**num;}\n\nendclass: gen\n```\n\n", "accept": false, "score": 0}], "score": [0.0, 1.0049370029959912e-156, 2.0, 0.0]}
{"question": "Is there a way to do explict resize to `LEN` of an expression?\n\nThe reason I want this, is to make the code explicitly describe the intention, and also to avoid the warnings for implicit resize that some tools generate.\n\nThe code below works in some tools, but fails in other:\n\n```\nlocalparam EXPR = 12;\nlocalparam LEN = 7;\nassign res = LEN'(EXPR);\n```\n\n\nBased on reading the Verilog-2001 standard, it looks like lengty by `LEN'...` can only be used for literals, e.g. `7'd12`, and not for general expressions.\n\nSo, is there a way to do explicit resize of general expressions in Verilog-2001?\n", "answer": [{"body": "How about\n\n```\nlocalparam LEN = 7;\nlocalparam [LEN-1:0] EXPR = 12;\nassign res = EXPR;\n```\n\n\nor if you need to use `EXPR` for some other purpose\n\n```\nlocalparam LEN = 7;\nlocalparam [LEN-1:0] EXPR7 = 12;\nlocalparam EXPR = 12;\nassign res = EXPR7\n```\n\n", "accept": false, "score": 1}, {"body": "The syntax you are looking for is already in SystemVerilog. You need to make sure you turn it on or use the proper .sv file extension so your tools recognize it. \n\n```\nassign res = LEN'(EXPR);\n```\n\n\nHowever, there is no way to dynamically calculate the length of a type - it needs to be a constant expression.\n\nBut you can dynamically apply a mask that truncates your value to desired length\n\n```\nassign res = EXPR & ((64'b10<<LEN)-1);\n```\n\n", "accept": true, "score": 2}, {"body": "System Verilog has a $bits() system call. It returns the number of bits required for an expression. Thus:\n\n```\nwire [11:0] res;\n$bits(res) // <= will return 12\n```\n\n\nYou have to check if you simulator/compiler supports it. Also I don't know if you can use it as:\n\n```\n$bits(res)'d7\n```\n\n\nThe only thing I should warn off is not to sacrifice your code readability to suppress superfluous warnings. Good readability prevents more errors than anything else.\n", "accept": false, "score": 0}, {"body": "I have a [systemverilog] macro I use for resizing:\n```\n// Drive a signal with a constant, automatically resize constant to signal value\n`define assign_const(SIGNAL,VALUE) assign SIGNAL = ($bits(SIGNAL))'(VALUE)\n```\n\nThe `($bits(SIGNAL))'(VALUE)` is the critical part. It uses $bits to determine the signal length and recasts the value accordingly.\n", "accept": false, "score": 0}], "score": [9.769915148057197e-156, 4.0, 0.0, 0.0]}
{"question": "Is it possible to do formal verification with Chisel3 HDL language?\nIf yes, is there an open-source software to do that ?\nI know that we can do verilog formal verification with Yosys, but with chisel ?\n", "answer": [{"body": "SpaceCowboy asked the same question [here](https://stackoverflow.com/questions/49800826/chisel-firrtl-verilog-backend-proof-of-work). And jkoening responded it: not now but maybe it will be done.\n", "accept": false, "score": 2}, {"body": "It's possible to use Yosys-smtbmc with some little hacks described [here](http://www.fabienm.eu/flf/prove-chisel-design-with-yosys-smtbmc/) to \u00abinject\u00bb formal properties in Verilog generated.\n", "accept": false, "score": 1}, {"body": "There is a chisel package named [chisel-formal](https://github.com/tdb-alcorn/chisel-formal) now.\n```\nimport chisel3.formal._\n```\n\nThis extends Module with trait named Formal.\n```\nclass MyModule extends Module with Formal {\n//...\n      past(io.Mwrite, 1) (pMwrite => {\n        when(io.Mwrite === true.B) {\n          assert(pMwrite === false.B)\n        }\n      })\n      cover(countreg === 10.U)\n//...\n}\n```\n\nThat allow to use assert(), assume(), cover(), past(), ... functions.\nFull howto is given on [github repository](https://github.com/tdb-alcorn/chisel-formal).\n", "accept": false, "score": 1}, {"body": "formal verification is now integrated under [chiseltest](https://github.com/ucb-bar/chiseltest) official test library.\n", "accept": true, "score": 1}], "score": [7.726464918317663e-238, 2.164490505955344e-246, 1.4155761056698778e-232, 2.0]}
{"question": "What happens if I have an `x` in my enable equation for a flop? \n\nTake for example a flop coded like below\n\n```\nalways @(posedge clock) begin\n  if(en) q <= d;\nend\n```\n\n\nSo if `en` is `x` does that mean `reg q` will hold its previous state and not latch a new one (considering if statement with an `x` evaluates to 0/false) OR will it also be `x` in sims? \nAnd is this something that can vary based on simulators used?\n\nThanks!\n", "answer": [{"body": "X-es will propagate from any FF input to all outputs. In fact they tend to propagate throughout a design like wildfire. Muxes, arithmetic, decoders almost everything quickly produces X if an input is X. \nThere are a few exceptions like: \n\n- - \n\nBut a two-input OR gate where the inputs are 0 and X, will produce X.\n\nThe propagation of X-es is well defined and you should find the same behavior in all simulators.\n", "accept": false, "score": 1}, {"body": "Since  refers to an undefined state, thus the output prediction is not possible in that case. Thus we would be getting a output as  itself from the flip-flop. \n\nAs stated by [oldfart](https://stackoverflow.com/questions/49770129/x-value-on-flop-enable-equation) above, in case of AND & OR gates, the output depends on the presence of 1 & 0 logic input, respectively (at any of the other input terminals of that gate).\n", "accept": false, "score": 0}, {"body": "Any condition in the 'if' statement is considered 2-state. Verilog standard conversion from 'x' pr 'z' to a 2-state will produce '0'. So, your `if (en)` will be false if 'en' is 'x' or 'z', meaning that it will hold.\n\nSo, answering your question, `reg q` will hold the value.\n\nsame is true in system verilog if you assign a 4-state variable to a 2-state variable, i.e. 'bit';\n", "accept": true, "score": 2}, {"body": "For completeness, the latest standard IEEE1800-2012 for SystemVerilog specifies that a values in the predicate of an `if` conditional is `'bx`, the statement shall evaluate to false, ie same as if `en` were `'b0` (See section 12.4). The other answers here give a good understanding of what that value means in the larger context of RTL design.\n", "accept": false, "score": 1}], "score": [3.7029619773064302e-233, 0.0, 4.0, 2.0]}
{"question": "I'm writting a piece of code in Quartus verilog (`.v`) and I'm trying to write a enum type inside my module:\n\n```\nmodule Controller(clk, IorD);\n\n    enum {READ, DECODE} state;\n    myState = READ;\n    //...\n```\n\n\nBut it gives me the following error: `Error (10170): Verilog HDL syntax error at Controller.v(3) near text \"{\"; expecting \";\"`.\n\nWhat am I doing wrong? How can I use a enum in verilog?\n", "answer": [{"body": "`enum` is a SystemVerilog feature. You will need to make sure that the file type in Quartus is SystemVerilog (usually the `.sv` extension is used too)\n", "accept": true, "score": 4}, {"body": "You can instead use parameters in place of enums if you are restricted to using verilog only in the tool.\nIf you can switch to other tools try edaplayground(dot)com\n\nexample code as requested below:\n\n```\nlocalparam START =1;\nlocalparam STOP  =2;\n```\n\n\nUse localparam instead of parameter because you really don't want these values to be changed during instantiation.\n", "accept": false, "score": 3}, {"body": "You will need to use typedef.\n\nIn your case =>\n\nmodule Controller(clk, IorD);\n\n```\ntypedef enum {READ, DECODE} state_e;\n\nstate_e myState;\n\n//Now you can use myState ...\n```\n\n", "accept": false, "score": 0}, {"body": "`enum` is not a part of IEEE Std 1364-2005 specification (newest Verilog specification).\nYou have to use SystemVerilog which support `enum` or make a workaround in Verilog:\n```\nparameter READ   = 'd 0;\nparameter DECODE = 'd 1;\n\nmy_state = STATE_READ;\n```\n\nI suggest placing all parameters in second file with extension `.vh` (Verilog Header) and include them by ``include` directive. For example:\n```\n`include \"parameters.vh\"\n```\n\nYou can also notice that I used `my_state` except `myState` because in Verilog naming conventions suggest to use lowercase with underscores (`_`) to separate words.\n", "accept": false, "score": 2}], "score": [8.0, 5.97981743567297e-156, 0.0, 6.017487675163642e-156]}
{"question": "I want to set all the registers in the array to zero. However, I've parametrized the sizing of the array:\n\n```\nlogic [WIDTH-2:0] numelem [0:MAXBITS-1];\n```\n\n\nIs there a way where I could essentially do `numelem <= {0,0,0,0,...}` but for a generic size? The method preferably needs to be non-blocking since I need to do the assignment within an `always_ff` block. Thanks.\n", "answer": [{"body": "I am in favor of using the old fashioned for loop: \n\n```\nint c;\n   ...\n   for (c=0; c<MAXBITS; c=c+1) numelem [c] <= 'b0;\n```\n\n", "accept": false, "score": 1}, {"body": "There are a few ways to achieve this:\n\n1) As Oldfart suggested, use a for loop; its simple and easy to understand\n\n```\nint i;\n...\nfor (i = 0; i < MAXBITS; i = i + 1) begin\n  numelem[i] <= '0;\nend\n```\n\n\n2) Use array assignment pattern with the `default` keyword:\n\n```\nnumelem <= '{default: '0};\n```\n\n\n3) Use `bit` type instead of `logic` type if you dont need to simulate `'bx` or `'bz` states; variables of type `bit` are initialized to `'b0` instead of `'bx`.\n", "accept": true, "score": 4}, {"body": "```\nlogic [WIDTH-2:0] numelem [0:MAXBITS-1] = '{default:'0};\n```\n\n", "accept": false, "score": 1}, {"body": "Just chiming in with another option which can be used for comparison as well:\n```\nsignal = {$bits(signal){1'b0}};\nsignal == {$bits(signal){1'b0}}; // This will evaluate to true\n```\n\n", "accept": false, "score": 0}], "score": [1.0936879801051476e-156, 8.0, 3.723740851552029e-158, 0.0]}
{"question": "I'm using systemVerilog and I have a package that holds some of my modules parameter values (for example `parameter SPI_RATE = 2_000_000;`). Is there any way I can set one value for simulation and a different one for synthesis? (I'm using ModelSim).\nFor example I would like something like:\n\n```\nif(IN_SIM) begin\nparameter SPI_RATE = 2_000_000;\nend\nelse begin\nparameter SPI_RATE = 1_000_000;\nend\n```\n\n\nThanks!\n", "answer": [{"body": "Yes, that's possible. SystemVerilog supports  such as ``ifdef`, ``ifndef`, ``else`, ``elsif`, and ``endif`. Note that those directives are using a  (ASCII 0x60) and not a normal apostrophe (ASCII 0x27).\n\nFurthermore, most synthesis tools support the macro identifier `SYNTHESIS`. So, you could do the following:\n\n```\n`ifdef SYNTHESIS\n  parameter SPI_RATE = 1_000_000;\n`else\n  parameter SPI_RATE = 2_000_000;    \n`endif\n```\n\n", "accept": true, "score": 3}, {"body": "Yes. You can set a macro from the command line in any simulation using the `+define` plusarg, eg:\n\n```\n+define+SPI_RATE=2_000_000\n```\n\n\nThen somewhere in your code, you can say\n\n```\nparameter SPI_RATE = `SPI_RATE;\n```\n\n\nAnd in your synthesiser there will be a mechanism for setting the value of a macro: read the instructions for your synthesiser.\n", "accept": false, "score": 0}, {"body": "With Synplify Pro, you can use the /*synthesis translate_off */ /*synthesis translate_off */ to accomplish this, a similar construct is usable in VHDL with appropriate syntax/comment changes. Xilinx Vivado uses // synthesis translate_off and // synthesis translate_on\n\n```\nconst logic IN_SIM = 1'b0\n/*synthesis translate_off */\n    || 1'b1\n/*synthesis translate_on */\n    ;\n```\n\n\nThe advantage of this construct is that it doesn't require any external scripting changes.\n", "accept": false, "score": -2}, {"body": "IMHO -\nUsing the first answer\n`ifdef SYNTHESIS\nis much preferred over the 3rd answer\n/* synthesis translate_off */\nThe last form is a variation of /* synopsys translate_off */, which was unique to one synthesis tool.\nThe macro SYNTHESIS has been in common use for more than a decade, and should be defined by any synthesis tool, without any extra command line options.\nIf you want to run equivalence checking (rtl vs gate level netlist), you will probably need to define the SYNTHESIS macro by the method recommended for that equivalence tool.\n", "accept": false, "score": 0}], "score": [6.0, 0.0, -1.0373765235430644e-156, 0.0]}
{"question": "I have written the following `assign` statement:\n```\nassign F = (BCD == 4'd1 | BCD == 4'd2 | BCD == 4'd3 | BCD == 4'd4 | BCD == 4'd5) ? 1'b1 : 1'b0;\n```\n\nwhere if the `BCD` input (4-bits) is 1-5, the function returns a 1 and otherwise returns a 0. This works perfectly how I intended, but I'm looking for a more efficient way to write the \"OR\" parts. Is there a more efficient way to write this?\n", "answer": [{"body": "Since your values are in a continuous range, this can be simplified as:\n```\nassign F = ((BCD >= 4'd1) && (BCD <= 4'd5));\n```\n\nIf your tool set supports SystemVerilog syntax, you could also use the `inside` operator.  Refer to IEEE Std 1800-2017, section 11.4.13 .\n", "accept": false, "score": 1}, {"body": "No, one should use each complete expressions separated by `|`. However, in this particular situation, you can use `(BCD >= 4'd1) & (BCD <= 4'd5)`.\n", "accept": false, "score": 2}, {"body": "There's no need for the ternary operator here. The result of each equality(`==`) is 1-bit, and you are doing a  OR (`|`). You probably should be using a  OR (`||`) whose result is also 1-bit.\n```\nassign F = (BCD == 4'd1 || BCD == 4'd2 || BCD == 4'd3 || BCD == 4'd4 || BCD == 4'd5);\n```\n\nIn SystemVerilog which most tools are supporting, you can use the inside operator\n```\nassign F = BCD inside {[1:5]}; //  contiguous range\nassign F = BCD inside {[1:3],5, [7:10]}; //  noncontiguous values\n```\n\n", "accept": true, "score": 3}, {"body": "There are several ways to do this:\na) Boundary check.\n```\nassign F = (BCD > 4'd0) & (BCD < 4'd6);\n```\n\nb) OR reduction and a high limit check.\n```\nassign F = |BCD & (BCD < 4'd6);\n```\n\nc) This is a behavioural hardware description, it would be optimized by the synthesis tool. It is parameterized, though.\n```\nlocalparam LOW = 1;\nlocalparam HIGH = 5;\ninteger i;\nreg F;\nalways @ (*) begin\n  F = 1'b0;\n  for(i = LOW; i <= HIGH; i = i + 1) begin: val_check\n    if(BCD == i[3:0]) F = 1'b1;\n  end\nend\n```\n\n", "accept": false, "score": 0}], "score": [4.285472299890113e-157, 4.273386982817057e-241, 6.0, 0.0]}
{"question": "I am having some trouble with Vivado where it is saying that there is a previously defined package and I believe it is causing failure in synthesis due to the order that these packages are being compiled. I have the file that is being reported as being defined twice added to the project as a verilog header that is labeled for global inclusion.\nI have attempted to change the import statements to include statements and there is now a mix because I am unsure which is the correct way and what both of them are doing. Before I added the include statements the project was failing to synthesize because it couldn't find the package at all.\n", "answer": [{"body": "`include is like copy-pasting the text of one file into another. import allows you to use the things defined in a package without having to prefix the package name in front of them.\nIn order to import the package must have first been defined, so depending on how your project is set up you may need `include to pull in the code that defines it.\n", "accept": false, "score": 1}, {"body": " is a  directive used to include text from other files in compilation. It is the same as #include in 'c/c++'. There are essentially two forms:\n```\n`include \"file.name\"\nor \n`inclde <file.name>\n```\n\nThe difference is in using of current directory for locating the file. Usually the +incdir+ or similar qualifiers tells the compiler where to look for the included files. A compiler will search for the 'file.name' in the list of provided directories. Then it will parse its code before the rest.\n is a SystemVerilog language construct and is provides an ability to import contents of a SystemVerilog package. In a sense it is similar to the c++  statement for namespaces.\nImporting means to provide an ability to use a package member without specifying the package name.\nFor the following package:\n```\npackage pkg;\n   function foo; ... endfunction\n   function bar; ... endfunction\nendpackage\n```\n\nWithout  you have to use `pkg::foo` or `pkg::bar` to use its functions.\nImport can have one of two forms:\n```\nimport pkg::*; // import all contents of the package 'pkg' (foo and bar)\nor \nimport pkg::foo; // where it only imports 'foo' from the package.\n```\n\nIn both cases you can use just `foo` to access the function of `bar` in the first case.\n", "accept": false, "score": 1}, {"body": "`include is a pre-processing directive that is just text in a file getting inserted at the point of inclusion. It is unaware of any SystemVerilog syntax. It is  and injected into the stream of characters the compiler parses as SystemVerilog syntax.\nA `package` is a namespace containing declarations of variables, types and other SystemVerilog constructs. It  part of the SystemVerilog syntax. A package  be defined prior to referencing any of its content.\nBoth constructs have implications on certain \"define before referencing\" rules, we would have to see exactly the way you are trying to use it. It would help to get a better understanding of the operation of those two constructs.\nI suggest looking at my post [\"SystemVerilog Coding Guidelines: Package import versus `include\"](https://blogs.sw.siemens.com/verificationhorizons/2010/07/13/package-import-versus-include/)\n", "accept": true, "score": 1}, {"body": "The issue seems to one of visibility.\nThe difference WRT visibility/access:\n- - \n", "accept": false, "score": 1}], "score": [2.0, 7.099259201481185e-156, 2.0, 1.3276197119120674e-240]}
