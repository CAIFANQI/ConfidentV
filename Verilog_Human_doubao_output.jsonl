{"task_id": "mux2to1v", "doubao_output": ["assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule"]}
{"task_id": "m2014_q6b", "doubao_output": ["always @(*) begin\n    case (y)\n        3'b000: Y2 = w ? 1'b0 : 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b1;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = w ? 1'b1 : 1'b1;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = w ? 1'b0 : 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b1;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = w ? 1'b1 : 1'b1;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = w ? 1'b0 : 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b0;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = w ? 1'b1 : 1'b1;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = w ? 1'b0 : 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b1;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = w ? 1'b1 : 1'b1;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b0;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = 1'b0;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b0;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = 1'b0;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = w ? 1'b0 : 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b1;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = w ? 1'b1 : 1'b1;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = 1'b0;\n        3'b001: Y2 = w ? 1'b0 : 1'b1;\n        3'b010: Y2 = w ? 1'b0 : 1'b1;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = w ? 1'b0 : 1'b1;\n        3'b101: Y2 = w ? 1'b0 : 1'b1;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: // State A\n            if (w)\n                Y2 = 1'b0;\n            else\n                Y2 = 1'b0;\n        3'b001: // State B\n            if (w)\n                Y2 = 1'b1;\n            else\n                Y2 = 1'b0;\n        3'b010: // State C\n            if (w)\n                Y2 = 1'b1;\n            else\n                Y2 = 1'b0;\n        3'b011: // State D\n            if (w)\n                Y2 = 1'b0;\n            else\n                Y2 = 1'b1;\n        3'b100: // State E\n            if (w)\n                Y2 = 1'b1;\n            else\n                Y2 = 1'b0;\n        3'b101: // State F\n            if (w)\n                Y2 = 1'b1;\n            else\n                Y2 = 1'b0;\n        default:\n            Y2 = 1'bx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (y)\n        3'b000: Y2 = w ? 1'b0 : 1'b0;\n        3'b001: Y2 = w ? 1'b1 : 1'b0;\n        3'b010: Y2 = w ? 1'b1 : 1'b1;\n        3'b011: Y2 = w ? 1'b0 : 1'b1;\n        3'b100: Y2 = w ? 1'b1 : 1'b1;\n        3'b101: Y2 = w ? 1'b1 : 1'b0;\n        default: Y2 = 1'bx;\n    endcase\nend\nendmodule"]}
{"task_id": "ringer", "doubao_output": ["assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule", "assign ringer = ring & (~vibrate_mode);\nassign motor = ring & vibrate_mode;\nendmodule"]}
{"task_id": "alwaysblock1", "doubao_output": ["assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule", "assign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule"]}
{"task_id": "zero", "doubao_output": ["assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule", "assign zero = 1'b0;\nendmodule"]}
{"task_id": "circuit7", "doubao_output": ["always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule"]}
{"task_id": "ece241_2014_q5a", "doubao_output": ["    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: state <= x ? S1 : S0;\n                S1: state <= S1;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign z = (state == S1) ? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n            endcase\n        end\n    end\n\n    assign z = (state == S0)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign z = (state == S0)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    assign z = (state == S1)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    assign z = (state == S0)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign z = (state == S0)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign z = (state == S1)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1; else state <= S0;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign z = (state == S1)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    assign z = (state == S0)? ~x : x;\n\nendmodule", "    reg state;\n    parameter S0 = 1'b0, S1 = 1'b1;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: if (x) state <= S1;\n                S1: state <= S1;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign z = (state == S0)? ~x : x;\n\nendmodule"]}
{"task_id": "fsm3", "doubao_output": ["    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule"]}
{"task_id": "vector2", "doubao_output": ["assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule", "assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule"]}
{"task_id": "m2014_q4c", "doubao_output": ["always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "mt2015_q4a", "doubao_output": ["assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule", "assign z = (x ^ y) & x;\nendmodule"]}
{"task_id": "shift18", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;\n            2'b01: q <= q << 8;\n            2'b10: q <= $signed(q) >>> 1;\n            2'b11: q <= $signed(q) >>> 8;\n            default: q <= q;\n        endcase\n    end\nend\nendmodule"]}
{"task_id": "ece241_2013_q8", "doubao_output": ["    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State update\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State update\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State update\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State update\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S2: z = x;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2) && x;\n    end\n\nendmodule"]}
{"task_id": "m2014_q6", "doubao_output": ["    // Define states\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 0, B = 1, C = 2, D = 3, E = 4, F = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    parameter A = 0, B = 1, C = 2, D = 3, E = 4, F = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) | (state == F);\n\nendmodule", "    parameter A = 0, B = 1, C = 2, D = 3, E = 4, F = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E || state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w? A : B;\n            B: next_state = w? D : C;\n            C: next_state = w? D : E;\n            D: next_state = w? A : F;\n            E: next_state = w? D : E;\n            F: next_state = w? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E || state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define states\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule"]}
{"task_id": "fsm_ps2data", "doubao_output": ["    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message <= {message[15:0], in};\n                BYTE1: message <= {message[15:0], in};\n                BYTE2: message <= {message[15:0], in};\n                BYTE3: message <= {message[15:0], in};\n            endcase\n        end\n    end\n\n    assign out_bytes = message;\n    assign done = (state == BYTE3);\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'd0, BYTE1 = 2'd1, BYTE2 = 2'd2, BYTE3 = 2'd3;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message[23:16] <= in;\n                BYTE1: message[15:8] <= in;\n                BYTE2: message[7:0] <= in;\n                default: message <= message;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = done ? message : 24'bx;\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] shift_reg;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: shift_reg <= {shift_reg[15:0], in};\n                BYTE1: shift_reg <= {shift_reg[15:0], in};\n                BYTE2: shift_reg <= {shift_reg[15:0], in};\n                BYTE3: shift_reg <= {shift_reg[15:0], in};\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = shift_reg;\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message <= in[3] ? {16'b0, in} : message;\n                BYTE1: message <= {message[15:0], in};\n                BYTE2: message <= {message[7:0], in};\n                BYTE3: message <= in[3] ? {16'b0, in} : message;\n                default: message <= 24'b0;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = done ? message : 24'b0;\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message <= in[3] ? {16'b0, in} : message;\n                BYTE1: message <= {message[15:0], in};\n                BYTE2: message <= {message[7:0], in};\n                BYTE3: message <= in[3] ? {16'b0, in} : message;\n                default: message <= message;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = message;\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message <= in[3] ? {16'b0, in} : message;\n                BYTE1: message <= {message[15:0], in};\n                BYTE2: message <= {message[7:0], in};\n                default: message <= message;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = message;\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'd0, BYTE1 = 2'd1, BYTE2 = 2'd2, BYTE3 = 2'd3;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message[23:16] <= in;\n                BYTE1: message[15:8] <= in;\n                BYTE2: message[7:0] <= in;\n                default: message <= message;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = done ? message : 24'bx;\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message <= {message[15:0], in};\n                BYTE1: message <= {message[15:0], in};\n                BYTE2: message <= {message[15:0], in};\n                BYTE3: message <= {message[15:0], in};\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = message;\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message <= {message[15:0], in};\n                BYTE1: message <= {message[15:0], in};\n                BYTE2: message <= {message[15:0], in};\n                BYTE3: message <= {message[15:0], in};\n            endcase\n        end\n    end\n\n    assign out_bytes = message;\n    assign done = (state == BYTE3);\n\nendmodule", "    reg [1:0] state, next_state;\n    reg [23:0] message;\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in[3] ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = in[3] ? BYTE1 : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Datapath logic\n    always @(posedge clk) begin\n        if (reset) begin\n            message <= 24'b0;\n        end else begin\n            case (state)\n                IDLE: message <= {message[15:0], in};\n                BYTE1: message <= {message[15:0], in};\n                BYTE2: message <= {message[15:0], in};\n                BYTE3: message <= {message[15:0], in};\n            endcase\n        end\n    end\n\n    // Output logic\n    assign done = (state == BYTE3);\n    assign out_bytes = message;\n\nendmodule"]}
{"task_id": "2012_q2b", "doubao_output": ["// Y1 is the input of state flip - flop y[1]. State B (y[1]=1) can be reached when the current state is A (y[0]=1) and w = 1.\nassign Y1 = y[0] & w;\n\n// Y3 is the input of state flip - flop y[3]. State D can be reached from states B, C, E, F when w = 0.\nassign Y3 = (~w) & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\nendmodule", "// Y1 is the input of state flip - flop y[1]. State B is represented by y[1].\n// B can be reached from A when w = 1. So Y1 should be high when y[0] is high and w is 1.\nassign Y1 = y[0] & w;\n\n// Y3 is the input of state flip - flop y[3]. State D can be reached from B, C, E, F when w = 0.\nassign Y3 = (~w) & (y[1] | y[2] | y[4] | y[5]);\n\nendmodule", "// Y1 is the input of state flip - flop y[1]. State B (y[1]=1) can be reached when the current state is A (y[0]=1) and w = 1.\nassign Y1 = y[0] & w;\n\n// Y3 is the input of state flip - flop y[3]. State D can be reached from B, C, E, F when w = 0 and from D when w = 0.\nassign Y3 = (~w) & (y[1] | y[2] | y[4] | y[5] | y[3]);\n\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\nendmodule", "assign Y1 = y[0] & w;\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\nendmodule", "// Y1 is the input of state flip - flop y[1]. State B (y[1]=1) is reached when the current state is A (y[0]=1) and w = 1.\nassign Y1 = y[0] & w;\n\n// Y3 is the input of state flip - flop y[3]. State D can be reached from B, C, E, F when w = 0 and from A when w = 0.\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w) | (y[0] & ~w);\n\nendmodule"]}
{"task_id": "vector0", "doubao_output": ["assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule", "assign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule"]}
{"task_id": "kmap4", "doubao_output": ["always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~b & ~d & c) | (b & d & c) | (a & ~b & ~c) | (a & b & c);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~a & c & ~b) | (~a & c & ~d) | (a & ~c & ~b) | (a & ~c & ~d) | (a & c & b) | (a & c & d);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~a & ~b & d) | (~a & c & ~b) | (a & ~c & ~b) | (a & ~c & ~d) | (a & b & ~d) | (a & c & b);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~a & c & ~b) | (~a & c & ~d) | (a & ~c & ~b) | (a & ~c & ~d) | (a & c & b) | (a & c & d);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~b & ~d & c) | (b & d & c) | (a & ~b & ~c) | (a & b & c);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~a & c & ~b) | (~a & c & ~d) | (a & ~c & ~b) | (a & ~c & ~d) | (a & c & b) | (a & c & d);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~a & c & ~b) | (~a & c & ~d) | (a & ~c & ~b) | (a & ~c & ~d) | (a & c & b) | (a & c & d);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~b & ~d & c) | (b & d & c) | (a & ~b & ~c) | (a & b & c);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~a & ~b & d) | (~a & b & ~d) | (a & ~b & c) | (a & ~c & ~d) | (a & b & c) | (a & b & d);\nend\nendmodule", "always @(posedge clk) begin\n    out <= (~a & ~c & b) | (~a & ~c & d) | (~a & c & ~b) | (~a & c & ~d) | (a & ~c & ~b) | (a & ~c & ~d) | (a & c & b) | (a & c & d);\nend\nendmodule"]}
{"task_id": "vector1", "doubao_output": ["assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule", "assign out_hi = in[15:8];\nassign out_lo = in[7:0];\nendmodule"]}
{"task_id": "norgate", "doubao_output": ["assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule", "assign out = ~(a | b);\nendmodule"]}
{"task_id": "alwaysblock2", "doubao_output": ["assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways_ff @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule", "assign out_assign = a ^ b;\n\nalways_comb begin\n    out_always_comb = a ^ b;\nend\n\nalways_ff @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule"]}
{"task_id": "m2014_q6c", "doubao_output": ["assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule", "assign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\nendmodule"]}
{"task_id": "mux256to1", "doubao_output": ["assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule", "assign out = in[sel];\nendmodule"]}
{"task_id": "2014_q4a", "doubao_output": ["always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule"]}
{"task_id": "ece241_2014_q4", "doubao_output": ["    reg q1, q2, q3;\n\n    // First D flip - flop\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n    end\n\n    // Second D flip - flop\n    always @(posedge clk) begin\n        q2 <= x & ~q2;\n    end\n\n    // Third D flip - flop\n    always @(posedge clk) begin\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n    wire xor_out, and_out, or_out;\n\n    // XOR gate\n    assign xor_out = x ^ q1;\n    // AND gate\n    assign and_out = x & ~q2;\n    // OR gate\n    assign or_out = x | ~q3;\n\n    // D flip - flops\n    always @(posedge clk) begin\n        q1 <= xor_out;\n        q2 <= and_out;\n        q3 <= or_out;\n    end\n\n    // Three - input XNOR gate\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    // First D flip - flop\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n    end\n\n    // Second D flip - flop\n    always @(posedge clk) begin\n        q2 <= x & ~q2;\n    end\n\n    // Third D flip - flop\n    always @(posedge clk) begin\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    // D flip - flop for XOR gate\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n    end\n\n    // D flip - flop for AND gate\n    always @(posedge clk) begin\n        q2 <= x & ~q2;\n    end\n\n    // D flip - flop for OR gate\n    always @(posedge clk) begin\n        q3 <= x | ~q3;\n    end\n\n    // Three - input XNOR gate\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    // D flip - flop for XOR gate\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n    end\n\n    // D flip - flop for AND gate\n    always @(posedge clk) begin\n        q2 <= x & ~q2;\n    end\n\n    // D flip - flop for OR gate\n    always @(posedge clk) begin\n        q3 <= x | ~q3;\n    end\n\n    // Three - input XNOR gate\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule", "    reg q1, q2, q3;\n\n    always @(posedge clk) begin\n        q1 <= x ^ q1;\n        q2 <= x & ~q2;\n        q3 <= x | ~q3;\n    end\n\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule"]}
{"task_id": "circuit4", "doubao_output": ["assign q = ~a & (c | b) | a & c;\nendmodule", "assign q = ~a | b | c;\nendmodule", "assign q = ~a & (b | c) | a & c;\nendmodule", "assign q = (~a & (b | c)) | (a & c);\nendmodule", "assign q = ~a | b | c;\nendmodule", "assign q = ~a | b | c;\nendmodule", "assign q = (~a & (b | c)) | (a & c);\nendmodule", "assign q = (~a & (b | c)) | (a & c);\nendmodule", "assign q = (~a & (b | c)) | (a & c);\nendmodule", "assign q = ~a & (c | b) | a & c;\nendmodule"]}
{"task_id": "rule110", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0)? q[i-1] : 1'b0, q[i], (i < 511)? q[i+1] : 1'b0})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (integer i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0)? 1'b0 : q[i-1], q[i], (i == 511)? 1'b0 : q[i+1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0)? 1'b0 : q[i-1], q[i], (i == 511)? 1'b0 : q[i+1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (integer i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0)? 1'b0 : q[i-1], q[i], (i == 511)? 1'b0 : q[i+1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0)? 1'b0 : q[i-1], q[i], (i == 511)? 1'b0 : q[i+1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0)? 1'b0 : q[i-1], q[i], (i == 511)? 1'b0 : q[i+1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (integer i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0)? 1'b0 : q[i-1], q[i], (i == 511)? 1'b0 : q[i+1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (integer i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0)? q[i-1] : 1'b0, q[i], (i < 511)? q[i+1] : 1'b0})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0)? q[i-1] : 1'b0, q[i], (i < 511)? q[i+1] : 1'b0})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (integer i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0)? 1'b0 : q[i-1], q[i], (i == 511)? 1'b0 : q[i+1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\nendmodule"]}
{"task_id": "fsm3s", "doubao_output": ["    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State update on positive clock edge\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Parameterize the states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine)\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule", "    // Define state parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? B : A;\n            B: next_state = in? B : C;\n            C: next_state = in? D : A;\n            D: next_state = in? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule"]}
{"task_id": "circuit5", "doubao_output": ["always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'b1111; // Assuming 'f' means all bits set, can adjust as per actual meaning\n    endcase\nend\nendmodule", "always @(*) begin\n    case(c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'b1111; // Here we assume 'f' means all 1s, if it's wrong, adjust according to the actual meaning\n    endcase\nend\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'b1111; // Assuming f is represented as all 1s here as it's not defined in the input ports\n    endcase\nend\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "always @(*) begin\n    case(c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'b1111; // Assuming 'f' is meant to be a constant value, here using 4'b1111 as an example\n    endcase\nend\nendmodule", "always @(*) begin\n    case(c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'df;\n    endcase\nend\nendmodule", "always @(*) begin\n    case(c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'hf;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'b1111; // Assuming f is represented as all 1s here as it's not defined clearly\n    endcase\nend\nendmodule", "always @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        default: q = 4'df;\n    endcase\nend\nendmodule"]}
{"task_id": "bugs_mux2", "doubao_output": ["    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\n\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\n\nendmodule", "    always @(posedge clk) begin\n        if (sel) begin\n            out <= b;\n        end else begin\n            out <= a;\n        end\n    end\nendmodule"]}
{"task_id": "mt2015_muxdff", "doubao_output": ["always @(posedge clk) begin\n    Q <= L ? r_in : q_in;\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    Q <= L ? r_in : q_in;\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    Q <= L ? r_in : q_in;\nend\nendmodule", "always @(posedge clk) begin\n    Q <= L ? r_in : q_in;\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\nendmodule"]}
{"task_id": "edgecapture", "doubao_output": ["reg [31:0] in_reg;\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n    end else begin\n        out <= out | (in_reg & ~in);\n    end\n    in_reg <= in;\nend\nendmodule", "reg [31:0] in_d;\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n    end else begin\n        in_d <= in;\n        out <= out | (in_d & ~in);\n    end\nend\nendmodule", "reg [31:0] in_d;\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n    end else begin\n        in_d <= in;\n        out <= out | (in_d & ~in);\n    end\nend\nendmodule", "reg [31:0] in_d;\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n    end else begin\n        in_d <= in;\n        out <= out | (in_d & ~in);\n    end\nend\nendmodule", "reg [31:0] in_reg;\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n    end else begin\n        out <= out | (in_reg & ~in);\n    end\n    in_reg <= in;\nend\nendmodule", "    reg [31:0] in_d;\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n        end else begin\n            in_d <= in;\n            out <= out | (in_d & ~in);\n        end\n    end\nendmodule", "    reg [31:0] in_prev;\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            in_prev <= in;\n        end else begin\n            in_prev <= in;\n            for (int i = 0; i < 32; i = i + 1) begin\n                if (in_prev[i] == 1'b1 && in[i] == 1'b0) begin\n                    out[i] <= 1'b1;\n                end\n            end\n        end\n    end\nendmodule", "    reg [31:0] in_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n        end else begin\n            out <= out | (in_reg & ~in);\n        end\n        in_reg <= in;\n    end\nendmodule", "    reg [31:0] in_prev;\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            in_prev <= in;\n        end else begin\n            in_prev <= in;\n            for (int i = 0; i < 32; i = i + 1) begin\n                if (in_prev[i] == 1'b1 && in[i] == 1'b0) begin\n                    out[i] <= 1'b1;\n                end\n            end\n        end\n    end\nendmodule", "    reg [31:0] in_prev;\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            in_prev <= in;\n        end else begin\n            in_prev <= in;\n            out <= out | (in_prev & ~in);\n        end\n    end\nendmodule"]}
{"task_id": "dff8", "doubao_output": ["always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule"]}
{"task_id": "ece241_2014_q1c", "doubao_output": ["assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = (a[7] == b[7]) && (s[7] != a[7]);\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule", "assign s = a + b;\nassign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule"]}
{"task_id": "review2015_fsmonehot", "doubao_output": ["// Next state logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[1] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// Next state logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[1] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & d;\nassign Count_next = state[3] | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// State transition logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & ~d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// State transition logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & ~d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// Next state logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & ~d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "assign B3_next = state[2];\nassign S_next = state[0] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & ~d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// Next state logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & ~d;\nassign Count_next = state[3] | state[4] | state[5] | state[6] | state[7] | (state[8] & ~done_counting);\nassign Wait_next = state[8] & done_counting;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// Next state logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & ~d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// Next state logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[1] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule", "// Next-state logic\nassign B3_next = state[2];\nassign S_next = state[0] & ~d | state[3] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & ~d;\nassign Count_next = state[3] & d | state[4] | state[5] | state[6] | state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\n// Output logic\nassign done = state[9];\nassign counting = state[8];\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule"]}
{"task_id": "counter_2bc", "doubao_output": ["always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\nendmodule"]}
{"task_id": "always_casez", "doubao_output": ["always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (in[0]) begin\n        pos <= 3'd0;\n    end else if (in[1]) begin\n        pos <= 3'd1;\n    end else if (in[2]) begin\n        pos <= 3'd2;\n    end else if (in[3]) begin\n        pos <= 3'd3;\n    end else if (in[4]) begin\n        pos <= 3'd4;\n    end else if (in[5]) begin\n        pos <= 3'd5;\n    end else if (in[6]) begin\n        pos <= 3'd6;\n    end else if (in[7]) begin\n        pos <= 3'd7;\n    end else begin\n        pos <= 3'd0;\n    end\nend\nendmodule"]}
{"task_id": "always_nolatches", "doubao_output": ["always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: ;\n    endcase\nend\nendmodule", "always @(*) begin\n    left = 1'b0;\n    down = 1'b0;\n    right = 1'b0;\n    up = 1'b0;\n    case (scancode)\n        16'he06b: left = 1'b1;\n        16'he072: down = 1'b1;\n        16'he074: right = 1'b1;\n        16'he075: up = 1'b1;\n        default: begin\n            left = 1'b0;\n            down = 1'b0;\n            right = 1'b0;\n            up = 1'b0;\n        end\n    endcase\nend\nendmodule"]}
{"task_id": "m2014_q4j", "doubao_output": ["wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule", "wire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule"]}
{"task_id": "history_shift", "doubao_output": ["always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule", "always_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule"]}
{"task_id": "wire_decl", "doubao_output": ["wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule", "wire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule"]}
{"task_id": "dff", "doubao_output": ["always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule", "always @(posedge clk) begin\n    q <= d;\nend\nendmodule"]}
{"task_id": "ece241_2013_q12", "doubao_output": ["reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] q;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] q;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        q <= {q[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = q[0];\n        3'b001: Z = q[1];\n        3'b010: Z = q[2];\n        3'b011: Z = q[3];\n        3'b100: Z = q[4];\n        3'b101: Z = q[5];\n        3'b110: Z = q[6];\n        3'b111: Z = q[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule", "reg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule"]}
{"task_id": "thermostat", "doubao_output": ["assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = heater | aircon | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = heater | aircon | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = fan_on | heater | aircon;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = heater | aircon | fan_on;\nendmodule", "assign heater = mode & too_cold;\nassign aircon = ~mode & too_hot;\nassign fan = (heater | aircon) | fan_on;\nendmodule"]}
{"task_id": "ece241_2013_q2", "doubao_output": ["// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (a | b | ~c | d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (~a | b | ~c | ~d) & (~a | ~b | ~c | d);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (a | b | ~c | d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (~a | b | ~c | ~d) & (~a | ~b | ~c | d);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & d) | (a & b & c & d) | (~a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (d) & (c | ~a) & (c | b);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (c | d) & (b | ~d) & (~a | b | c);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (a | b | ~c | d) & (a | ~b | ~c | ~d) & (~a | ~b | c | ~d);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & d) | (a & b & c & d) | (~a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (d) & (c) & (a | b);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (c | ~d) & (~a | b | c) & (a | ~b | c) & (a | b | ~c | d);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (a | b | ~c | d) & (a | ~b | ~c | d) & (a | ~b | c | ~d) & (a | ~b | c | d) & (~a | b | ~c | ~d) & (~a | b | ~c | d) & (~a | ~b | c | d);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (a | b | ~c | d) & (a | ~b | ~c | ~d) & (~a | ~b | c | d);\n\nendmodule", "// Minimum sum - of - products form\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Minimum product - of - sums form\nassign out_pos = (a | b | ~c | d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (~a | b | ~c | ~d) & (~a | ~b | ~c | d);\n\nendmodule"]}
{"task_id": "lfsr32", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[31] <= q[30];\n        q[30] <= q[29];\n        q[29] <= q[28];\n        q[28] <= q[27];\n        q[27] <= q[26];\n        q[26] <= q[25];\n        q[25] <= q[24];\n        q[24] <= q[23];\n        q[23] <= q[22];\n        q[22] <= q[21] ^ q[31];\n        q[21] <= q[20];\n        q[20] <= q[19];\n        q[19] <= q[18];\n        q[18] <= q[17];\n        q[17] <= q[16];\n        q[16] <= q[15];\n        q[15] <= q[14];\n        q[14] <= q[13];\n        q[13] <= q[12];\n        q[12] <= q[11];\n        q[11] <= q[10];\n        q[10] <= q[9];\n        q[9] <= q[8];\n        q[8] <= q[7];\n        q[7] <= q[6];\n        q[6] <= q[5];\n        q[5] <= q[4];\n        q[4] <= q[3];\n        q[3] <= q[2];\n        q[2] <= q[1] ^ q[31];\n        q[1] <= q[0] ^ q[31];\n        q[0] <= q[31];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0];\n        q[1] <= q[0];\n        q[2] <= q[31] ^ q[1];\n        q[3:21] <= q[2:20];\n        q[22] <= q[31] ^ q[21];\n        q[23:31] <= q[22:30];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0];\n        q[1] <= q[0];\n        q[2] <= q[1] ^ q[31];\n        q[3:21] <= q[2:20];\n        q[22] <= q[21] ^ q[31];\n        q[23:31] <= q[22:30];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[0] <= q[31] ^ q[21];\n        q[1] <= q[0];\n        q[2] <= q[31] ^ q[1];\n        q[3:21] <= q[2:20];\n        q[22] <= q[31] ^ q[21];\n        q[23:31] <= q[22:30];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0];\n        q[1] <= q[0];\n        q[2] <= q[1] ^ q[31];\n        q[3:21] <= q[2:20];\n        q[22] <= q[21] ^ q[31];\n        q[23:31] <= q[22:30];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0];\n        q[1] <= q[0];\n        q[2] <= q[1] ^ q[31];\n        q[3:21] <= q[2:20];\n        q[22] <= q[21] ^ q[31];\n        q[23:31] <= q[22:30];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0];\n        q[1] <= q[0];\n        q[2] <= q[1] ^ q[31];\n        q[3:21] <= q[2:20];\n        q[22] <= q[21] ^ q[31];\n        q[23:31] <= q[22:30];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0];\n        q[1] <= q[0];\n        q[2] <= q[1] ^ q[31];\n        q[3:21] <= q[2:20];\n        q[22] <= q[21] ^ q[31];\n        q[23:31] <= q[22:30];\n    end\nend\nendmodule"]}
{"task_id": "circuit3", "doubao_output": ["assign q = (a & d) | (b & (c | d)) | (a & c);\nendmodule", "assign q = (a & d) | (b & ~d) | (c & ~d);\nendmodule", "assign q = (a & d) | (b & (c | d)) | (c & d);\nendmodule", "assign q = (a & d) | (b & (c | d)) | (c & d);\nendmodule", "assign q = (a & d) | (b & (c | d)) | (a & c);\nendmodule", "assign q = (a & d) | (b & (c | d)) | (a & c);\nendmodule", "assign q = (a & d) | (b & ~d) | (c & ~d);\nendmodule", "assign q = (a & d) | (b & (c | d)) | (c & d);\nendmodule", "assign q = (a & d) | (b & ~d) | (c & ~d);\nendmodule", "assign q = (a & d) | (b & (c | d)) | (c & d);\nendmodule"]}
{"task_id": "7420", "doubao_output": ["assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule", "assign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule"]}
{"task_id": "popcount255", "doubao_output": ["always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    out = 8'b0;\n    for (i = 0; i < 255; i = i + 1) begin\n        if (in[i]) begin\n            out = out + 1;\n        end\n    end\nend\nendmodule"]}
{"task_id": "gatesv", "doubao_output": ["assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule", "assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule", "assign out_both[2] = in[2] & in[3];\nassign out_both[1] = in[1] & in[2];\nassign out_both[0] = in[0] & in[1];\n\nassign out_any[3] = in[3] | in[2];\nassign out_any[2] = in[2] | in[1];\nassign out_any[1] = in[1] | in[0];\n\nassign out_different[3] = in[3] ^ in[0];\nassign out_different[2] = in[2] ^ in[3];\nassign out_different[1] = in[1] ^ in[2];\nassign out_different[0] = in[0] ^ in[1];\n\nendmodule", "assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule", "assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule", "assign out_both[2] = in[2] & in[3];\nassign out_both[1] = in[1] & in[2];\nassign out_both[0] = in[0] & in[1];\n\nassign out_any[3] = in[3] | in[2];\nassign out_any[2] = in[2] | in[1];\nassign out_any[1] = in[1] | in[0];\n\nassign out_different[3] = in[3] ^ in[0];\nassign out_different[2] = in[2] ^ in[3];\nassign out_different[1] = in[1] ^ in[2];\nassign out_different[0] = in[0] ^ in[1];\n\nendmodule", "assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule", "assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule", "assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule", "assign out_both = {in[3] & in[2], in[2] & in[1], in[1] & in[0]};\nassign out_any = {in[3] | in[2], in[2] | in[1], in[1] | in[0]};\nassign out_different = {in[3] ^ in[0], in[2] ^ in[3], in[1] ^ in[2], in[0] ^ in[1]};\nendmodule"]}
{"task_id": "circuit6", "doubao_output": ["always @(*) begin\n    case (a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule", "always @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\nendmodule"]}
{"task_id": "countslow", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule"]}
{"task_id": "m2014_q4f", "doubao_output": ["assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule", "assign out = in1 & ~in2;\nendmodule"]}
{"task_id": "m2014_q4h", "doubao_output": ["assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule"]}
{"task_id": "fsm1", "doubao_output": ["    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            case (state)\n                A: state <= in ? A : B;\n                B: state <= in ? B : A;\n                default: state <= B;\n            endcase\n        end\n    end\n\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? A : B;\n            B: next_state = in? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in? A : B;\n            B: next_state = in? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops (with asynchronous reset)\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            case (state)\n                A: state <= in ? A : B;\n                B: state <= in ? B : A;\n            endcase\n        end\n    end\n\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            case (state)\n                A: state <= in? A : B;\n                B: state <= in? B : A;\n            endcase\n        end\n    end\n\n    assign out = (state == B);\n\nendmodule"]}
{"task_id": "dualedge", "doubao_output": ["reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule", "reg q1, q2;\n\nalways @(posedge clk) begin\n    q1 <= d;\nend\n\nalways @(negedge clk) begin\n    q2 <= d;\nend\n\nalways @(*) begin\n    q = clk? q1 : q2;\nend\n\nendmodule"]}
{"task_id": "xnorgate", "doubao_output": ["assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule", "assign out = ~(a ^ b);\nendmodule"]}
{"task_id": "mt2015_q4", "doubao_output": ["wire a1_out, b1_out, a2_out, b2_out;\nwire or_out, and_out;\n\n// Instantiate the first A sub - module\nA inst_a1(.x(x), .y(y), .z(a1_out));\n// Instantiate the first B sub - module\nB inst_b1(.x(x), .y(y), .z(b1_out));\n// Instantiate the second A sub - module\nA inst_a2(.x(x), .y(y), .z(a2_out));\n// Instantiate the second B sub - module\nB inst_b2(.x(x), .y(y), .z(b2_out));\n\n// Perform OR operation\nassign or_out = a1_out | b1_out;\n// Perform AND operation\nassign and_out = a2_out & b2_out;\n\n// Perform XOR operation\nassign z = or_out ^ and_out;\n\nendmodule", "wire z_a1, z_b1, z_a2, z_b2;\nwire z_or, z_and;\n\n// Instantiate the first A sub - module\nA u1 (.x(x), .y(y), .z(z_a1));\n\n// Instantiate the first B sub - module\nB u2 (.x(x), .y(y), .z(z_b1));\n\n// Instantiate the second A sub - module\nA u3 (.x(x), .y(y), .z(z_a2));\n\n// Instantiate the second B sub - module\nB u4 (.x(x), .y(y), .z(z_b2));\n\n// OR operation\nassign z_or = z_a1 | z_b1;\n\n// AND operation\nassign z_and = z_a2 & z_b2;\n\n// XOR operation\nassign z = z_or ^ z_and;\n\nendmodule", "wire a1_out, b1_out, a2_out, b2_out;\nwire or_out, and_out;\n\n// Instantiate the first A sub - module\nA u1 (.x(x), .y(y), .z(a1_out));\n// Instantiate the first B sub - module\nB u2 (.x(x), .y(y), .z(b1_out));\n// Instantiate the second A sub - module\nA u3 (.x(x), .y(y), .z(a2_out));\n// Instantiate the second B sub - module\nB u4 (.x(x), .y(y), .z(b2_out));\n\n// Perform OR operation\nassign or_out = a1_out | b1_out;\n// Perform AND operation\nassign and_out = a2_out & b2_out;\n// Perform XOR operation\nassign z = or_out ^ and_out;\n\nendmodule", "wire a1_out, b1_out, a2_out, b2_out;\nwire or_out, and_out;\n\nA inst_A1 (.x(x), .y(y), .z(a1_out));\nB inst_B1 (.x(x), .y(y), .z(b1_out));\nA inst_A2 (.x(x), .y(y), .z(a2_out));\nB inst_B2 (.x(x), .y(y), .z(b2_out));\n\nassign or_out = a1_out | b1_out;\nassign and_out = a2_out & b2_out;\nassign z = or_out ^ and_out;\n\nendmodule", "wire a1_out, b1_out, a2_out, b2_out;\nwire or_out, and_out;\n\n// Instantiate the first A sub - module\nA inst_a1(.x(x), .y(y), .z(a1_out));\n// Instantiate the first B sub - module\nB inst_b1(.x(x), .y(y), .z(b1_out));\n// Instantiate the second A sub - module\nA inst_a2(.x(x), .y(y), .z(a2_out));\n// Instantiate the second B sub - module\nB inst_b2(.x(x), .y(y), .z(b2_out));\n\n// OR operation\nassign or_out = a1_out | b1_out;\n// AND operation\nassign and_out = a2_out & b2_out;\n\n// XOR operation\nassign z = or_out ^ and_out;\n\nendmodule", "wire z_a1, z_b1, z_a2, z_b2;\nwire or_out, and_out;\n\n// Instantiate the first A sub - module\nA u1 (.x(x), .y(y), .z(z_a1));\n// Instantiate the first B sub - module\nB u2 (.x(x), .y(y), .z(z_b1));\n// Instantiate the second A sub - module\nA u3 (.x(x), .y(y), .z(z_a2));\n// Instantiate the second B sub - module\nB u4 (.x(x), .y(y), .z(z_b2));\n\n// Perform OR operation\nassign or_out = z_a1 | z_b1;\n// Perform AND operation\nassign and_out = z_a2 & z_b2;\n\n// Perform XOR operation\nassign z = or_out ^ and_out;\n\nendmodule", "wire a1_out, b1_out, a2_out, b2_out;\nwire or_out, and_out;\n\n// Instantiate the first A and B sub - modules\nA inst_A1(.x(x), .y(y), .z(a1_out));\nB inst_B1(.x(x), .y(y), .z(b1_out));\n\n// Instantiate the second A and B sub - modules\nA inst_A2(.x(x), .y(y), .z(a2_out));\nB inst_B2(.x(x), .y(y), .z(b2_out));\n\n// Perform OR operation\nassign or_out = a1_out | b1_out;\n\n// Perform AND operation\nassign and_out = a2_out & b2_out;\n\n// Perform XOR operation\nassign z = or_out ^ and_out;\n\nendmodule", "wire z_a1, z_b1, z_a2, z_b2;\nwire z_or, z_and;\n\n// Instantiate the first A sub - module\nA inst_A1(.x(x), .y(y), .z(z_a1));\n// Instantiate the first B sub - module\nB inst_B1(.x(x), .y(y), .z(z_b1));\n// Instantiate the second A sub - module\nA inst_A2(.x(x), .y(y), .z(z_a2));\n// Instantiate the second B sub - module\nB inst_B2(.x(x), .y(y), .z(z_b2));\n\n// Perform OR operation\nassign z_or = z_a1 | z_b1;\n// Perform AND operation\nassign z_and = z_a2 & z_b2;\n\n// Perform XOR operation\nassign z = z_or ^ z_and;\n\nendmodule", "wire a1_out, b1_out, a2_out, b2_out;\nwire or_out, and_out;\n\nA u1_A (.x(x), .y(y), .z(a1_out));\nB u1_B (.x(x), .y(y), .z(b1_out));\nA u2_A (.x(x), .y(y), .z(a2_out));\nB u2_B (.x(x), .y(y), .z(b2_out));\n\nassign or_out = a1_out | b1_out;\nassign and_out = a2_out & b2_out;\nassign z = or_out ^ and_out;\n\nendmodule", "wire a1_out, b1_out, a2_out, b2_out;\nwire or_out, and_out;\n\nA inst_A1 (.x(x), .y(y), .z(a1_out));\nB inst_B1 (.x(x), .y(y), .z(b1_out));\nA inst_A2 (.x(x), .y(y), .z(a2_out));\nB inst_B2 (.x(x), .y(y), .z(b2_out));\n\nassign or_out = a1_out | b1_out;\nassign and_out = a2_out & b2_out;\n\nassign z = or_out ^ and_out;\n\nendmodule"]}
{"task_id": "rotate100", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]};\n            2'b10: q <= {q[98:0], q[99]};\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]};\n            2'b10: q <= {q[98:0], q[99]};\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]};\n            2'b10: q <= {q[98:0], q[99]};\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'b01) begin\n        q <= {q[0], q[99:1]};\n    end else if (ena == 2'b10) begin\n        q <= {q[98:0], q[99]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]};\n            2'b10: q <= {q[98:0], q[99]};\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]};\n            2'b10: q <= {q[98:0], q[99]};\n            default: q <= q;\n        endcase\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'b01) begin\n        q <= {q[0], q[99:1]};\n    end else if (ena == 2'b10) begin\n        q <= {q[98:0], q[99]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'b01) begin\n        q <= {q[0], q[99:1]};\n    end else if (ena == 2'b10) begin\n        q <= {q[98:0], q[99]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'b01) begin\n        q <= {q[0], q[99:1]};\n    end else if (ena == 2'b10) begin\n        q <= {q[98:0], q[99]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena == 2'b01) begin\n        q <= {q[0], q[99:1]};\n    end else if (ena == 2'b10) begin\n        q <= {q[98:0], q[99]};\n    end\nend\nendmodule"]}
{"task_id": "review2015_count1k", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule"]}
{"task_id": "notgate", "doubao_output": ["assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule", "assign out = ~in;\nendmodule"]}
{"task_id": "fsm_onehot", "doubao_output": ["// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule", "// State transition logic\nassign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\nassign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\nassign next_state[2] = state[1] & in;\nassign next_state[3] = state[2] & in;\nassign next_state[4] = state[3] & in;\nassign next_state[5] = state[4] & in;\nassign next_state[6] = state[5] & in;\nassign next_state[7] = (state[6] & in) | (state[7] & in);\nassign next_state[8] = state[5] & ~in;\nassign next_state[9] = state[6] & ~in;\n\n// Output logic\nassign out1 = state[8] | state[9];\nassign out2 = state[7] | state[9];\n\nendmodule"]}
{"task_id": "ece241_2013_q7", "doubao_output": ["always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;\n        2'b01: Q <= 1'b0;\n        2'b10: Q <= 1'b1;\n        2'b11: Q <= ~Q;\n    endcase\nend\nendmodule"]}
{"task_id": "popcount3", "doubao_output": ["assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule", "assign out = in[0] + in[1] + in[2];\nendmodule"]}
{"task_id": "vector5", "doubao_output": ["assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule", "assign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[ 9] = ~(d ^ a);\nassign out[ 8] = ~(d ^ b);\nassign out[ 7] = ~(d ^ c);\nassign out[ 6] = ~(d ^ d);\nassign out[ 5] = ~(d ^ e);\nassign out[ 4] = ~(e ^ a);\nassign out[ 3] = ~(e ^ b);\nassign out[ 2] = ~(e ^ c);\nassign out[ 1] = ~(e ^ d);\nassign out[ 0] = ~(e ^ e);\nendmodule"]}
{"task_id": "lemmings1", "doubao_output": ["    // Define states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine)\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left? RIGHT : LEFT;\n            RIGHT: next_state = bump_right? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    // State declarations\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    reg state, next_state;\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    // Parameter definition for states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flop with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine)\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end else begin\n            case (state)\n                LEFT: begin\n                    if (bump_left) begin\n                        state <= RIGHT;\n                    end else begin\n                        state <= LEFT;\n                    end\n                end\n                RIGHT: begin\n                    if (bump_right) begin\n                        state <= LEFT;\n                    end else begin\n                        state <= RIGHT;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: next_state = bump_left ? RIGHT : LEFT;\n            RIGHT: next_state = bump_right ? LEFT : RIGHT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine)\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n\nendmodule", "parameter LEFT = 1'b0, RIGHT = 1'b1;\nreg state, next_state;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        LEFT: next_state = bump_left? RIGHT : LEFT;\n        RIGHT: next_state = bump_right? LEFT : RIGHT;\n        default: next_state = LEFT;\n    endcase\nend\n\n// State flip-flops\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= LEFT;\n    else\n        state <= next_state;\nend\n\n// Output logic\nassign walk_left = (state == LEFT);\nassign walk_right = (state == RIGHT);\n\nendmodule"]}
{"task_id": "circuit1", "doubao_output": ["assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule", "assign q = a & b;\nendmodule"]}
{"task_id": "7458", "doubao_output": ["wire and1 = p1a & p1b & p1c;\nwire and2 = p1d & p1e & p1f;\nwire and3 = p2a & p2b;\nwire and4 = p2c & p2d;\n\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule", "    wire and1, and2, and3, and4;\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\nendmodule", "wire and1;\nwire and2;\nwire and3;\nwire and4;\n\nassign and1 = p1a & p1b & p1c;\nassign and2 = p1d & p1e & p1f;\nassign and3 = p2a & p2b;\nassign and4 = p2c & p2d;\n\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule", "    wire and1, and2, and3, and4;\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\nendmodule", "wire and1;\nwire and2;\nwire and3;\nwire and4;\n\nassign and1 = p1a & p1b & p1c;\nassign and2 = p1d & p1e & p1f;\nassign and3 = p2a & p2b;\nassign and4 = p2c & p2d;\n\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule", "wire and1_1;\nwire and1_2;\nwire and2_1;\nwire and2_2;\n\nassign and1_1 = p1a & p1b & p1c;\nassign and1_2 = p1d & p1e & p1f;\nassign and2_1 = p2a & p2b;\nassign and2_2 = p2c & p2d;\n\nassign p1y = and1_1 | and1_2;\nassign p2y = and2_1 | and2_2;\n\nendmodule", "    wire and1, and2, and3, and4;\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\nendmodule", "    wire and1, and2, and3, and4;\n\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\n\nendmodule", "wire and1 = p1a & p1b & p1c;\nwire and2 = p1d & p1e & p1f;\nwire and3 = p2a & p2b;\nwire and4 = p2c & p2d;\n\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule", "    wire and1, and2, and3, and4;\n    assign and1 = p1a & p1b & p1c;\n    assign and2 = p1d & p1e & p1f;\n    assign and3 = p2a & p2b;\n    assign and4 = p2c & p2d;\n    assign p1y = and1 | and2;\n    assign p2y = and3 | and4;\nendmodule"]}
{"task_id": "2014_q3c", "doubao_output": ["always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\n\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\n\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\n\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end\n            else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b001: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        end\n        3'b010: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end else begin\n                Y0 <= 1'b1;\n                z <= 1'b0;\n            end\n        end\n        3'b011: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        3'b100: begin\n            if (x == 1'b0) begin\n                Y0 <= 1'b1;\n                z <= 1'b1;\n            end else begin\n                Y0 <= 1'b0;\n                z <= 1'b1;\n            end\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\n\nendmodule"]}
{"task_id": "m2014_q4e", "doubao_output": ["assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule", "assign out = ~(in1 | in2);\nendmodule"]}
{"task_id": "wire4", "doubao_output": ["assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule", "assign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule"]}
{"task_id": "m2014_q4b", "doubao_output": ["always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "always_case", "doubao_output": ["always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'b000: out <= data0;\n        3'b001: out <= data1;\n        3'b010: out <= data2;\n        3'b011: out <= data3;\n        3'b100: out <= data4;\n        3'b101: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule", "always @(posedge clk) begin\n    case (sel)\n        3'd0: out <= data0;\n        3'd1: out <= data1;\n        3'd2: out <= data2;\n        3'd3: out <= data3;\n        3'd4: out <= data4;\n        3'd5: out <= data5;\n        default: out <= 4'b0000;\n    endcase\nend\nendmodule"]}
{"task_id": "timer", "doubao_output": ["reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 10'b0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 10'b0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 10'd0) begin\n        counter <= counter - 10'd1;\n    end\nend\n\nassign tc = (counter == 10'd0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule", "reg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter != 0) begin\n        counter <= counter - 1;\n    end\nend\n\nassign tc = (counter == 0);\n\nendmodule"]}
{"task_id": "review2015_fsmseq", "doubao_output": ["    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule", "    reg [3:0] state;\n    parameter S0 = 4'b0000, S1 = 4'b0001, S2 = 4'b0010, S3 = 4'b0011, S4 = 4'b0100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 1'b0;\n        end\n        else begin\n            case (state)\n                S0: begin\n                    if (data)\n                        state <= S1;\n                    else\n                        state <= S0;\n                    start_shifting <= 1'b0;\n                end\n                S1: begin\n                    if (data)\n                        state <= S2;\n                    else\n                        state <= S0;\n                    start_shifting <= 1'b0;\n                end\n                S2: begin\n                    if (!data)\n                        state <= S3;\n                    else\n                        state <= S2;\n                    start_shifting <= 1'b0;\n                end\n                S3: begin\n                    if (data)\n                        state <= S4;\n                    else\n                        state <= S0;\n                    start_shifting <= 1'b0;\n                end\n                S4: begin\n                    state <= S4;\n                    start_shifting <= 1'b1;\n                end\n                default: begin\n                    state <= S0;\n                    start_shifting <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [3:0] state;\n    parameter S0 = 4'b0000, S1 = 4'b0001, S2 = 4'b0010, S3 = 4'b0011, S4 = 4'b0100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 1'b0;\n        end else begin\n            case (state)\n                S0: begin\n                    if (data)\n                        state <= S1;\n                    else\n                        state <= S0;\n                    start_shifting <= 1'b0;\n                end\n                S1: begin\n                    if (data)\n                        state <= S2;\n                    else\n                        state <= S0;\n                    start_shifting <= 1'b0;\n                end\n                S2: begin\n                    if (!data)\n                        state <= S3;\n                    else\n                        state <= S2;\n                    start_shifting <= 1'b0;\n                end\n                S3: begin\n                    if (data)\n                        state <= S4;\n                    else\n                        state <= S0;\n                    start_shifting <= 1'b0;\n                end\n                S4: begin\n                    state <= S4;\n                    start_shifting <= 1'b1;\n                end\n                default: begin\n                    state <= S0;\n                    start_shifting <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S2 : S3;\n            S3: next_state = data ? S4 : S0;\n            S4: next_state = S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4);\n\nendmodule"]}
{"task_id": "dff8r", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "edgedetect2", "doubao_output": ["reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    anyedge <= in & ~in_prev;\nend\nendmodule"]}
{"task_id": "count1to10", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1;\n    end else if (q == 4'd10) begin\n        q <= 4'd1;\n    end else begin\n        q <= q + 4'd1;\n    end\nend\nendmodule"]}
{"task_id": "circuit9", "doubao_output": ["always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6) ? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (a) begin\n        q <= 3'd4;\n    end else begin\n        q <= (q == 3'd6)? 3'd0 : q + 1;\n    end\nend\nendmodule"]}
{"task_id": "lfsr5", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2];\n        q[2] <= q[1] ^ q[4];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[3];\n        q[3] <= q[2];\n        q[2] <= q[1] ^ q[4];\n        q[1] <= q[0];\n        q[0] <= q[4];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[0];\n        q[3] <= q[4] ^ q[0];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[0];\n        q[3] <= q[4] ^ q[0];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[0];\n        q[3] <= q[4] ^ q[0];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[0];\n        q[3] <= q[4] ^ q[0];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q <= {q[3]^q[4], q[4], q[2], q[3], q[1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q <= {q[3]^q[4], q[4], q[2], q[3], q[1]};\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[0];\n        q[3] <= q[4] ^ q[0];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;\n    end else begin\n        q[4] <= q[0];\n        q[3] <= q[4] ^ q[0];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\nendmodule"]}
{"task_id": "bugs_addsubz", "doubao_output": ["    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        if (out == 8'b0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        if (out == 8'b0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        if (out == 8'b0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        if (out == 8'b0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule", "    always @(*) begin\n        case (do_sub)\n          0: out = a + b;\n          1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule"]}
{"task_id": "m2014_q3", "doubao_output": ["assign f = (x[4:1] == 4'b0111) | (x[4:1] == 4'b1100) | (x[4:1] == 4'b1101) | (x[4:1] == 4'b1000) | (x[4:1] == 4'b1001);\nendmodule", "always_comb begin\n    case (x)\n        4'b0000, 4'b0011, 4'b0010: f = 1'bx;\n        4'b0100, 4'b0110: f = 1'b0;\n        4'b0101: f = 1'bx;\n        4'b0111: f = 1'b1;\n        4'b1100, 4'b1101: f = 1'b1;\n        4'b1111, 4'b1110: f = 1'bx;\n        4'b1000, 4'b1001: f = 1'b1;\n        4'b1011: f = 1'b0;\n        4'b1010: f = 1'bx;\n    endcase\nend\nendmodule", "assign f = (x[3] & x[4]) | (x[3] & ~x[2]) | (~x[3] & x[4] & x[2]);\nendmodule", "assign f = (~x[3] & x[2] & x[1]) | (x[3] & ~x[2]) | (x[3] & x[1]);\nendmodule", "assign f = (x[4:1] == 4'b0111) | (x[4:1] == 4'b1100) | (x[4:1] == 4'b1101) | (x[4:1] == 4'b1000) | (x[4:1] == 4'b1001);\nendmodule", "always_comb begin\n    case (x)\n        4'b0000, 4'b0011, 4'b0010: f = 1'bx;\n        4'b0100, 4'b0110: f = 1'b0;\n        4'b0101: f = 1'bx;\n        4'b0111: f = 1'b1;\n        4'b1100, 4'b1101: f = 1'b1;\n        4'b1111, 4'b1110: f = 1'bx;\n        4'b1000, 4'b1001: f = 1'b1;\n        4'b1011: f = 1'b0;\n        4'b1010: f = 1'bx;\n    endcase\nend\nendmodule", "assign f = (x[4:1] == 4'b0111) | (x[4:1] == 4'b1100) | (x[4:1] == 4'b1101) | (x[4:1] == 4'b1000) | (x[4:1] == 4'b1001);\nendmodule", "assign f = (x[3] & x[4]) | (x[3] & x[1]) | (x[4] & ~x[2]);\nendmodule", "assign f = (x[3] & x[4]) | (x[3] & ~x[2]) | (~x[3] & x[4] & x[2]);\nendmodule", "always_comb begin\n    case (x)\n        4'b0000, 4'b0011, 4'b0010: f = 1'bx;\n        4'b0100, 4'b0110: f = 1'b0;\n        4'b0101: f = 1'bx;\n        4'b0111: f = 1'b1;\n        4'b1100, 4'b1101: f = 1'b1;\n        4'b1111, 4'b1110: f = 1'bx;\n        4'b1000, 4'b1001: f = 1'b1;\n        4'b1011: f = 1'b0;\n        4'b1010: f = 1'bx;\n    endcase\nend\nendmodule"]}
{"task_id": "bugs_case", "doubao_output": ["always @(*) begin\n    valid = 1'b0;\n    out = 4'b0;\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'b0;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    valid = 1'b0;\n    out = 4'b0;\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'b0;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    valid = 1'b0;\n    out = 4'b0;\n    case (code)\n        8'h45: begin\n            valid = 1'b1;\n            out = 4'd0;\n        end\n        8'h16: begin\n            valid = 1'b1;\n            out = 4'd1;\n        end\n        8'h1e: begin\n            valid = 1'b1;\n            out = 4'd2;\n        end\n        8'h26: begin\n            valid = 1'b1;\n            out = 4'd3;\n        end\n        8'h25: begin\n            valid = 1'b1;\n            out = 4'd4;\n        end\n        8'h2e: begin\n            valid = 1'b1;\n            out = 4'd5;\n        end\n        8'h36: begin\n            valid = 1'b1;\n            out = 4'd6;\n        end\n        8'h3d: begin\n            valid = 1'b1;\n            out = 4'd7;\n        end\n        8'h3e: begin\n            valid = 1'b1;\n            out = 4'd8;\n        end\n        8'h46: begin\n            valid = 1'b1;\n            out = 4'd9;\n        end\n        default: begin\n            valid = 1'b0;\n            out = 4'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    valid = 1'b0;\n    out = 4'b0000;\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'b0000;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    valid = 1'b0;\n    out = 4'b0000;\n    case (code)\n        8'h45: begin\n            valid = 1'b1;\n            out = 4'd0;\n        end\n        8'h16: begin\n            valid = 1'b1;\n            out = 4'd1;\n        end\n        8'h1e: begin\n            valid = 1'b1;\n            out = 4'd2;\n        end\n        8'h26: begin\n            valid = 1'b1;\n            out = 4'd3;\n        end\n        8'h25: begin\n            valid = 1'b1;\n            out = 4'd4;\n        end\n        8'h2e: begin\n            valid = 1'b1;\n            out = 4'd5;\n        end\n        8'h36: begin\n            valid = 1'b1;\n            out = 4'd6;\n        end\n        8'h3d: begin\n            valid = 1'b1;\n            out = 4'd7;\n        end\n        8'h3e: begin\n            valid = 1'b1;\n            out = 4'd8;\n        end\n        8'h46: begin\n            valid = 1'b1;\n            out = 4'd9;\n        end\n        default: begin\n            valid = 1'b0;\n            out = 4'b0000;\n        end\n    endcase\nend\nendmodule", "always @(*) begin\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\nendmodule"]}
{"task_id": "vectorr", "doubao_output": ["assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule"]}
{"task_id": "kmap3", "doubao_output": ["always @(*) begin\n    if ((c & ~d) | (b & d) | (a & ~b & ~c)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (~c & ~b & a) | (c & b)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (b & d) | (a & ~b)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (~c & ~b & a) | (c & b)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (b & d) | (~a & ~b & c) | (a & ~b & ~c)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (b & d) | (~a & ~b & c)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (~c & ~b & a) | (c & b)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (b & d) | (a & ~b)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (b & d) | (a & ~b & ~c)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule", "always @(*) begin\n    if ((c & ~d) | (b & ~a & ~c) | (a & ~b & c) | (a & b & ~c) | (a & b & c)) begin\n        out = 1;\n    end else begin\n        out = 0;\n    end\nend\nendmodule"]}
{"task_id": "review2015_shiftcount", "doubao_output": ["always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end\n    else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end\n    else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end\n    else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end\n    else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {q[2:0], data};\n    end\n    else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule"]}
{"task_id": "wire", "doubao_output": ["assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule", "assign out = in;\nendmodule"]}
{"task_id": "review2015_fsmshift", "doubao_output": ["reg [1:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 2'b00;\n        shift_ena <= 1'b1;\n    end else if (counter < 2'b11) begin\n        counter <= counter + 1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [1:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 2'b00;\n        shift_ena <= 1'b1;\n    end else if (counter < 2'b11) begin\n        counter <= counter + 1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'd0;\n        shift_ena <= 1'b1;\n    end else if (counter < 3'd3) begin\n        counter <= counter + 1'b1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'd0;\n        shift_ena <= 1'b1;\n    end else if (counter < 3'd3) begin\n        counter <= counter + 1'b1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'd0;\n        shift_ena <= 1'b1;\n    end else if (counter < 3'd3) begin\n        counter <= counter + 1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [1:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 2'b00;\n        shift_ena <= 1'b1;\n    end else if (counter < 2'b11) begin\n        counter <= counter + 1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'd0;\n        shift_ena <= 1'b1;\n    end else if (counter < 3'd3) begin\n        counter <= counter + 1'b1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [1:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 2'b00;\n        shift_ena <= 1'b1;\n    end else if (counter < 2'b11) begin\n        counter <= counter + 1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [1:0] counter;\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 2'b00;\n        shift_ena <= 1'b1;\n    end else if (counter < 2'b11) begin\n        counter <= counter + 1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule", "reg [1:0] counter;\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 2'b00;\n        shift_ena <= 1'b1;\n    end else if (counter < 2'b11) begin\n        counter <= counter + 1;\n        shift_ena <= 1'b1;\n    end else begin\n        shift_ena <= 1'b0;\n    end\nend\nendmodule"]}
{"task_id": "count15", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1'b1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1'b1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1'b1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1'b1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule"]}
{"task_id": "always_if", "doubao_output": ["// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always <= b;\n    end\n    else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always = b;\n    end\n    else begin\n        out_always = a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 & sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 & sel_b2) begin\n        out_always <= b;\n    end else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always <= b;\n    end else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always <= b;\n    end else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always <= b;\n    end\n    else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always <= b;\n    end\n    else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 & sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 & sel_b2) begin\n        out_always <= b;\n    end else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always <= b;\n    end else begin\n        out_always <= a;\n    end\nend\n\nendmodule", "// Using assign statement\nassign out_assign = (sel_b1 && sel_b2)? b : a;\n\n// Using procedural if statement\nalways @(posedge clk) begin\n    if (sel_b1 && sel_b2) begin\n        out_always <= b;\n    end\n    else begin\n        out_always <= a;\n    end\nend\n\nendmodule"]}
{"task_id": "kmap1", "doubao_output": ["assign out = ~a&b&~c | ~a&b&c | a&~b&~c | a&~b&c | a&b&~c | a&b&c | ~a&~b&c;\nendmodule", "assign out = ~a&b&~c | ~a&~b&c | a&~b&~c | a&b&c | a&b&~c | a&~b&c;\nendmodule", "assign out = ~a&b&~c | ~a&b&c | a&~b&~c | a&~b&c | a&b&~c | a&b&c | ~a&~b&c;\nendmodule", "assign out = ~a & (b & ~c | ~b & c) | a;\nendmodule", "assign out = ~a&b&~c | ~a&b&c | a&~b&~c | a&~b&c | a&b&~c | a&b&c | ~a&~b&c;\nendmodule", "assign out = ~a & (b & ~c | ~b & c) | a;\nendmodule", "assign out = ~a & (b & ~c | ~b & c) | a;\nendmodule", "assign out = ~a & b & ~c | ~a & b & c | a & ~b & ~c | a & ~b & c | a & b & ~c | a & b & c | ~a & ~b & c;\nendmodule", "assign out = ~a & (b & ~c | ~b & c) | a;\nendmodule", "assign out = ~a&b&~c | ~a&b&c | a&~b&~c | a&~b&c | a&b&~c | a&b&c | ~a&~b&c;\nendmodule"]}
{"task_id": "2013_q2afsm", "doubao_output": ["    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Parameterize the states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (!r[1] && r[2]) next_state = C;\n                else if (!r[1] && !r[2] && r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // State declarations\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (!r[1] && r[2]) next_state = C;\n                else if (!r[1] && !r[2] && r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Define states\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule", "    // Define states\n    localparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (!r[1] && r[2]) next_state = C;\n                else if (!r[1] && !r[2] && r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: begin\n                if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign g[1] = (state == B);\n    assign g[2] = (state == C);\n    assign g[3] = (state == D);\n\nendmodule"]}
{"task_id": "count10", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'd9) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule"]}
{"task_id": "fsm_ps2", "doubao_output": ["    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3] ? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3] ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3]? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3]? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3]? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3]? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3] ? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3] ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3] ? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3] ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3] ? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3] ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3]? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3]? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3]? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3]? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3] ? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3] ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule", "    reg [1:0] state, next_state;\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in[3] ? S1 : S0;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = in[3] ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign done = (state == S3);\n\nendmodule"]}
{"task_id": "mux2to1", "doubao_output": ["assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel ? b : a;\nendmodule", "assign out = sel? b : a;\nendmodule", "assign out = sel? b : a;\nendmodule"]}
{"task_id": "gates4", "doubao_output": ["assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule"]}
{"task_id": "2014_q3bfsm", "doubao_output": ["    reg [2:0] y;\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule", "    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                    end else begin\n                        y <= 3'b000;\n                    end\n                    z <= 1'b0;\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                    end else begin\n                        y <= 3'b001;\n                    end\n                    z <= 1'b0;\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                    end else begin\n                        y <= 3'b010;\n                    end\n                    z <= 1'b0;\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                    end else begin\n                        y <= 3'b001;\n                    end\n                    z <= 1'b1;\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                    end else begin\n                        y <= 3'b011;\n                    end\n                    z <= 1'b1;\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [2:0] y;\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule", "    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                    end else begin\n                        y <= 3'b000;\n                    end\n                    z <= 1'b0;\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                    end else begin\n                        y <= 3'b001;\n                    end\n                    z <= 1'b0;\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                    end else begin\n                        y <= 3'b010;\n                    end\n                    z <= 1'b0;\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                    end else begin\n                        y <= 3'b001;\n                    end\n                    z <= 1'b1;\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                    end else begin\n                        y <= 3'b011;\n                    end\n                    z <= 1'b1;\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "    reg [2:0] y;\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 1'b0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 1'b0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 1'b0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 1'b0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1'b1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1'b1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1'b1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule"]}
{"task_id": "2013_q2bfsm", "doubao_output": ["    // Define states\n    localparam STATE_A = 2'b00;\n    localparam SET_F = 2'b01;\n    localparam MONITOR_X = 2'b10;\n    localparam SET_G = 2'b11;\n    localparam CHECK_Y_1 = 3'b001;\n    localparam CHECK_Y_2 = 3'b010;\n    localparam KEEP_G_1 = 3'b011;\n    localparam KEEP_G_0 = 3'b100;\n\n    reg [2:0] state, next_state;\n    reg [2:0] x_sequence;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = (!resetn)? STATE_A : SET_F;\n            SET_F: next_state = MONITOR_X;\n            MONITOR_X: begin\n                x_sequence = {x_sequence[1:0], x};\n                if (x_sequence == 3'b101) begin\n                    next_state = SET_G;\n                end else begin\n                    next_state = MONITOR_X;\n                end\n            end\n            SET_G: next_state = CHECK_Y_1;\n            CHECK_Y_1: next_state = (y)? KEEP_G_1 : CHECK_Y_2;\n            CHECK_Y_2: next_state = (y)? KEEP_G_1 : KEEP_G_0;\n            KEEP_G_1: next_state = KEEP_G_1;\n            KEEP_G_0: next_state = KEEP_G_0;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    assign f = (state == SET_F);\n    assign g = (state == SET_G) || (state == CHECK_Y_1) || (state == CHECK_Y_2) || (state == KEEP_G_1);\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam STATE_SET_F = 2'b01;\n    localparam STATE_MONITOR_X = 2'b10;\n    localparam STATE_CHECK_Y = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg [1:0] x_count;\n    reg [1:0] y_count;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (resetn) begin\n                    next_state = STATE_SET_F;\n                end else begin\n                    next_state = STATE_A;\n                end\n            end\n            STATE_SET_F: begin\n                next_state = STATE_MONITOR_X;\n            end\n            STATE_MONITOR_X: begin\n                if (x_count == 2'b11) begin\n                    next_state = STATE_CHECK_Y;\n                end else begin\n                    next_state = STATE_MONITOR_X;\n                end\n            end\n            STATE_CHECK_Y: begin\n                if (y_count == 2'b10) begin\n                    if (y) begin\n                        next_state = STATE_CHECK_Y;\n                    end else begin\n                        next_state = STATE_MONITOR_X;\n                    end\n                end else begin\n                    next_state = STATE_CHECK_Y;\n                end\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    assign f = (state == STATE_SET_F);\n    assign g = (state == STATE_CHECK_Y && (y_count < 2'b10 || y));\n\n    // Counter logic for x\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_count <= 2'b00;\n        end else if (state == STATE_MONITOR_X) begin\n            case (x_count)\n                2'b00: if (x) x_count <= 2'b01;\n                2'b01: if (!x) x_count <= 2'b10;\n                2'b10: if (x) x_count <= 2'b11;\n                default: x_count <= 2'b00;\n            endcase\n        end else begin\n            x_count <= 2'b00;\n        end\n    end\n\n    // Counter logic for y\n    always @(posedge clk) begin\n        if (!resetn) begin\n            y_count <= 2'b00;\n        end else if (state == STATE_CHECK_Y) begin\n            if (y) begin\n                y_count <= 2'b10;\n            end else if (y_count < 2'b10) begin\n                y_count <= y_count + 1;\n            end\n        end else begin\n            y_count <= 2'b00;\n        end\n    end\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam STATE_SET_F = 2'b01;\n    localparam STATE_MONITOR_X = 2'b10;\n    localparam STATE_CHECK_Y = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg [1:0] x_count;\n    reg [1:0] y_count;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (resetn) begin\n                    next_state = STATE_SET_F;\n                end else begin\n                    next_state = STATE_A;\n                end\n            end\n            STATE_SET_F: begin\n                next_state = STATE_MONITOR_X;\n            end\n            STATE_MONITOR_X: begin\n                if (x_count == 2'd2 && x) begin\n                    next_state = STATE_CHECK_Y;\n                end else begin\n                    next_state = STATE_MONITOR_X;\n                end\n            end\n            STATE_CHECK_Y: begin\n                if (y_count == 2'd2 && !y) begin\n                    next_state = STATE_MONITOR_X;\n                end else begin\n                    next_state = STATE_CHECK_Y;\n                end\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    assign f = (state == STATE_SET_F);\n    assign g = (state == STATE_CHECK_Y && (y || (y_count < 2'd2)));\n\n    // X counter logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            x_count <= 2'd0;\n        end else if (state == STATE_MONITOR_X) begin\n            if (x_count == 2'd0 && x) begin\n                x_count <= 2'd1;\n            end else if (x_count == 2'd1 && !x) begin\n                x_count <= 2'd2;\n            end else if (x_count == 2'd2 && x) begin\n                x_count <= 2'd0;\n            end else if (!x && x_count != 2'd1) begin\n                x_count <= 2'd0;\n            end\n        end else begin\n            x_count <= 2'd0;\n        end\n    end\n\n    // Y counter logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            y_count <= 2'd0;\n        end else if (state == STATE_CHECK_Y) begin\n            if (!y) begin\n                y_count <= y_count + 1;\n            end\n        end else begin\n            y_count <= 2'd0;\n        end\n    end\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam STATE_SET_F = 2'b01;\n    localparam STATE_WAIT_X_1 = 2'b10;\n    localparam STATE_WAIT_X_0 = 2'b11;\n    localparam STATE_WAIT_X_1_AGAIN = 3'b100;\n    localparam STATE_SET_G = 3'b101;\n    localparam STATE_CHECK_Y_1 = 3'b110;\n    localparam STATE_CHECK_Y_2 = 3'b111;\n    localparam STATE_G_ON = 4'b1000;\n    localparam STATE_G_OFF = 4'b1001;\n\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = resetn ? STATE_SET_F : STATE_A;\n            STATE_SET_F: next_state = STATE_WAIT_X_1;\n            STATE_WAIT_X_1: next_state = x ? STATE_WAIT_X_0 : STATE_WAIT_X_1;\n            STATE_WAIT_X_0: next_state = x ? STATE_WAIT_X_1 : STATE_WAIT_X_1_AGAIN;\n            STATE_WAIT_X_1_AGAIN: next_state = x ? STATE_SET_G : STATE_WAIT_X_1;\n            STATE_SET_G: next_state = STATE_CHECK_Y_1;\n            STATE_CHECK_Y_1: next_state = y ? STATE_G_ON : STATE_CHECK_Y_2;\n            STATE_CHECK_Y_2: next_state = y ? STATE_G_ON : STATE_G_OFF;\n            STATE_G_ON: next_state = resetn ? STATE_G_ON : STATE_A;\n            STATE_G_OFF: next_state = resetn ? STATE_G_OFF : STATE_A;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign f = (state == STATE_SET_F);\n    assign g = (state == STATE_SET_G) || (state == STATE_CHECK_Y_1) || (state == STATE_CHECK_Y_2) || (state == STATE_G_ON);\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam STATE_SET_F = 2'b01;\n    localparam STATE_MONITOR_X = 2'b10;\n    localparam STATE_CHECK_X_1 = 2'b11;\n    localparam STATE_CHECK_X_0 = 3'b100;\n    localparam STATE_CHECK_X_1_AGAIN = 3'b101;\n    localparam STATE_SET_G = 3'b110;\n    localparam STATE_MONITOR_Y_1 = 3'b111;\n    localparam STATE_MONITOR_Y_2 = 4'b1000;\n    localparam STATE_G_ON = 4'b1001;\n    localparam STATE_G_OFF = 4'b1010;\n\n    reg [3:0] state, next_state;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = resetn? STATE_SET_F : STATE_A;\n            STATE_SET_F: next_state = STATE_MONITOR_X;\n            STATE_MONITOR_X: next_state = x? STATE_CHECK_X_1 : STATE_MONITOR_X;\n            STATE_CHECK_X_1: next_state = x? STATE_CHECK_X_1 : STATE_CHECK_X_0;\n            STATE_CHECK_X_0: next_state = x? STATE_CHECK_X_1_AGAIN : STATE_MONITOR_X;\n            STATE_CHECK_X_1_AGAIN: next_state = STATE_SET_G;\n            STATE_SET_G: next_state = STATE_MONITOR_Y_1;\n            STATE_MONITOR_Y_1: next_state = y? STATE_G_ON : STATE_MONITOR_Y_2;\n            STATE_MONITOR_Y_2: next_state = y? STATE_G_ON : STATE_G_OFF;\n            STATE_G_ON: next_state = STATE_G_ON;\n            STATE_G_OFF: next_state = STATE_G_OFF;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    assign f = (state == STATE_SET_F);\n    assign g = (state == STATE_SET_G) || (state == STATE_MONITOR_Y_1) || (state == STATE_MONITOR_Y_2) || (state == STATE_G_ON);\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam SET_F = 2'b01;\n    localparam MONITOR_X = 2'b10;\n    localparam WAIT_Y = 2'b11;\n    localparam G_ON = 2'b100;\n    localparam G_OFF = 2'b101;\n\n    reg [2:0] state, next_state;\n    reg [1:0] x_count;\n    reg [1:0] y_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = resetn ? SET_F : STATE_A;\n            SET_F: next_state = MONITOR_X;\n            MONITOR_X: begin\n                if (x_count == 2'b10 && x)\n                    next_state = WAIT_Y;\n                else if (x)\n                    next_state = (x_count == 2'b00) ? {x_count[0], 1'b1} : {1'b1, x_count[0]};\n                else if (x_count == 2'b01)\n                    next_state = {1'b0, x_count[0]};\n                else\n                    next_state = MONITOR_X;\n            end\n            WAIT_Y: begin\n                if (y)\n                    next_state = G_ON;\n                else if (y_count == 2'b10)\n                    next_state = G_OFF;\n                else\n                    next_state = {y_count[0], 1'b1};\n            end\n            G_ON: next_state = G_ON;\n            G_OFF: next_state = G_OFF;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n            x_count <= 2'b00;\n            y_count <= 2'b00;\n        end else begin\n            state <= next_state;\n            if (state == MONITOR_X) begin\n                if (x)\n                    x_count <= (x_count == 2'b00) ? {x_count[0], 1'b1} : {1'b1, x_count[0]};\n                else if (x_count == 2'b01)\n                    x_count <= {1'b0, x_count[0]};\n                else\n                    x_count <= 2'b00;\n            end else if (state == WAIT_Y) begin\n                if (y)\n                    y_count <= 2'b00;\n                else\n                    y_count <= {y_count[0], 1'b1};\n            end else begin\n                x_count <= 2'b00;\n                y_count <= 2'b00;\n            end\n        end\n    end\n\n    // Output logic\n    assign f = (state == SET_F);\n    assign g = (state == G_ON || state == WAIT_Y);\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam STATE_SET_F = 2'b01;\n    localparam STATE_MONITOR_X = 2'b10;\n    localparam STATE_CHECK_Y = 2'b11;\n    localparam STATE_G_ON = 2'b100;\n    localparam STATE_G_OFF = 2'b101;\n\n    reg [2:0] state, next_state;\n    reg [1:0] x_sequence;\n    reg [1:0] y_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = resetn ? STATE_SET_F : STATE_A;\n            STATE_SET_F: next_state = STATE_MONITOR_X;\n            STATE_MONITOR_X: begin\n                if (x_sequence == 2'b10 && x)\n                    next_state = STATE_CHECK_Y;\n                else\n                    next_state = STATE_MONITOR_X;\n            end\n            STATE_CHECK_Y: begin\n                if (y)\n                    next_state = STATE_G_ON;\n                else if (y_count == 2'b10)\n                    next_state = STATE_G_OFF;\n                else\n                    next_state = STATE_CHECK_Y;\n            end\n            STATE_G_ON: next_state = resetn ? STATE_G_ON : STATE_A;\n            STATE_G_OFF: next_state = resetn ? STATE_G_OFF : STATE_A;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign f = (state == STATE_SET_F);\n    assign g = (state == STATE_G_ON);\n\n    // X sequence monitoring\n    always @(posedge clk) begin\n        if (!resetn)\n            x_sequence <= 2'b00;\n        else if (state == STATE_MONITOR_X) begin\n            x_sequence[1] <= x_sequence[0];\n            x_sequence[0] <= x;\n        end else\n            x_sequence <= 2'b00;\n    end\n\n    // Y count monitoring\n    always @(posedge clk) begin\n        if (!resetn)\n            y_count <= 2'b00;\n        else if (state == STATE_CHECK_Y) begin\n            if (!y)\n                y_count <= y_count + 1;\n            else\n                y_count <= 2'b00;\n        end else\n            y_count <= 2'b00;\n    end\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam STATE_SET_F = 2'b01;\n    localparam STATE_MONITOR_X = 2'b10;\n    localparam STATE_CHECK_Y = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg [2:0] x_sequence;\n    reg [1:0] y_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (!resetn)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_SET_F;\n            end\n            STATE_SET_F: next_state = STATE_MONITOR_X;\n            STATE_MONITOR_X: begin\n                if (x_sequence == 3'b101)\n                    next_state = STATE_CHECK_Y;\n                else\n                    next_state = STATE_MONITOR_X;\n            end\n            STATE_CHECK_Y: begin\n                if (y_count == 2'd2) begin\n                    if (y)\n                        next_state = STATE_CHECK_Y;\n                    else\n                        next_state = STATE_MONITOR_X;\n                end\n                else\n                    next_state = STATE_CHECK_Y;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign f = (state == STATE_SET_F);\n\n    always @(posedge clk) begin\n        if (!resetn)\n            g <= 1'b0;\n        else if (state == STATE_CHECK_Y) begin\n            if (y_count == 2'd0)\n                g <= 1'b1;\n            else if (y_count == 2'd2) begin\n                if (!y)\n                    g <= 1'b0;\n            end\n        end\n    end\n\n    // X sequence monitoring\n    always @(posedge clk) begin\n        if (!resetn)\n            x_sequence <= 3'b000;\n        else if (state == STATE_MONITOR_X)\n            x_sequence <= {x_sequence[1:0], x};\n    end\n\n    // Y count monitoring\n    always @(posedge clk) begin\n        if (!resetn)\n            y_count <= 2'd0;\n        else if (state == STATE_CHECK_Y) begin\n            if (y_count < 2'd2)\n                y_count <= y_count + 1;\n        end\n        else\n            y_count <= 2'd0;\n    end\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam SET_F = 2'b01;\n    localparam MONITOR_X = 2'b10;\n    localparam WAIT_Y = 2'b11;\n    localparam G_ON = 3'b100;\n    localparam G_OFF = 3'b101;\n\n    reg [2:0] state, next_state;\n    reg [1:0] x_count;\n    reg [1:0] y_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = resetn ? SET_F : STATE_A;\n            SET_F: next_state = MONITOR_X;\n            MONITOR_X: begin\n                if (x_count == 2'b10 && x) next_state = WAIT_Y;\n                else if (x_count == 2'b00 && x) next_state = {MONITOR_X[1:0], 1'b1};\n                else if (x_count == 2'b01 && ~x) next_state = {MONITOR_X[1:0], 2'b10};\n                else next_state = {MONITOR_X[1:0], 2'b00};\n            end\n            WAIT_Y: begin\n                if (y) next_state = G_ON;\n                else if (y_count == 2'b10) next_state = G_OFF;\n                else next_state = WAIT_Y;\n            end\n            G_ON: next_state = G_ON;\n            G_OFF: next_state = G_OFF;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n            x_count <= 2'b00;\n            y_count <= 2'b00;\n        end else begin\n            state <= next_state;\n            case (state)\n                MONITOR_X: begin\n                    if (x_count == 2'b00 && x) x_count <= 2'b01;\n                    else if (x_count == 2'b01 && ~x) x_count <= 2'b10;\n                    else if (x_count == 2'b10 && x) x_count <= 2'b00;\n                    else x_count <= 2'b00;\n                end\n                WAIT_Y: begin\n                    if (!y) y_count <= y_count + 1;\n                    else y_count <= 2'b00;\n                end\n                default: begin\n                    x_count <= 2'b00;\n                    y_count <= 2'b00;\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign f = (state == SET_F);\n    assign g = (state == WAIT_Y || state == G_ON);\n\nendmodule", "    // Define states\n    localparam STATE_A = 2'b00;\n    localparam SET_F = 2'b01;\n    localparam MONITOR_X = 2'b10;\n    localparam WAIT_Y = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg [2:0] x_sequence;\n    reg [1:0] y_counter;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: next_state = resetn ? SET_F : STATE_A;\n            SET_F: next_state = MONITOR_X;\n            MONITOR_X: begin\n                x_sequence = {x_sequence[1:0], x};\n                if (x_sequence == 3'b101)\n                    next_state = WAIT_Y;\n                else\n                    next_state = MONITOR_X;\n            end\n            WAIT_Y: begin\n                if (y)\n                    next_state = WAIT_Y;\n                else if (y_counter == 2'd2)\n                    next_state = MONITOR_X;\n                else\n                    next_state = WAIT_Y;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n            x_sequence <= 3'b000;\n            y_counter <= 2'b00;\n        end else begin\n            state <= next_state;\n            if (state == MONITOR_X)\n                x_sequence <= {x_sequence[1:0], x};\n            if (state == WAIT_Y) begin\n                if (!y)\n                    y_counter <= y_counter + 1;\n            end else\n                y_counter <= 2'b00;\n        end\n    end\n\n    // Output logic\n    assign f = (state == SET_F);\n    assign g = (state == WAIT_Y) && (y || (y_counter < 2'd2));\n\nendmodule"]}
{"task_id": "dff8p", "doubao_output": ["always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "reduction", "doubao_output": ["assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule", "assign parity = ^in;\nendmodule"]}
{"task_id": "fsm3comb", "doubao_output": ["always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule", "always @(*) begin\n    case (state)\n        2'b00: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b00;\n        end\n        2'b01: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        2'b10: begin\n            if (in) next_state = 2'b11;\n            else next_state = 2'b00;\n        end\n        2'b11: begin\n            if (in) next_state = 2'b01;\n            else next_state = 2'b10;\n        end\n        default: next_state = 2'b00;\n    endcase\nend\n\nassign out = (state == 2'b11)? 1'b1 : 1'b0;\n\nendmodule"]}
{"task_id": "mt2015_q4b", "doubao_output": ["always @(posedge clk) begin\n    if (x == 1 && y == 0) begin\n        z <= 0;\n    end else if (x == 0 && y == 1) begin\n        z <= 0;\n    end else if (x == 1 && y == 1) begin\n        z <= 1;\n    end else begin\n        z <= 1;\n    end\nend\nendmodule", "    reg z_reg;\n    always @(posedge clk) begin\n        if (x == 1 && y == 0) begin\n            z_reg <= 0;\n        end else if (x == 0 && y == 1) begin\n            z_reg <= 0;\n        end else if (x == 1 && y == 1) begin\n            z_reg <= 1;\n        end else begin\n            z_reg <= 1;\n        end\n    end\n    assign z = z_reg;\nendmodule", "always @(posedge clk) begin\n    if (x && !y) begin\n        z <= 0;\n    end else if (!x && y) begin\n        z <= 0;\n    end else if (x && y) begin\n        z <= 1;\n    end else begin\n        z <= 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (x && !y) begin\n        z <= 0;\n    end else if (!x && y) begin\n        z <= 0;\n    end else if (x && y) begin\n        z <= 1;\n    end else begin\n        z <= 1;\n    end\nend\nendmodule", "    reg z_reg;\n    always @(posedge clk) begin\n        if (x == 1'b0 && y == 1'b0) begin\n            z_reg <= 1'b1;\n        end else if (x == 1'b1 && y == 1'b0) begin\n            z_reg <= 1'b0;\n        end else if (x == 1'b0 && y == 1'b1) begin\n            z_reg <= 1'b0;\n        end else if (x == 1'b1 && y == 1'b1) begin\n            z_reg <= 1'b1;\n        end\n    end\n    assign z = z_reg;\nendmodule", "always @(posedge clk) begin\n    if (x == 1'b1 && y == 1'b0) begin\n        z <= 1'b0;\n    end else if (x == 1'b0 && y == 1'b1) begin\n        z <= 1'b0;\n    end else if (x == 1'b1 && y == 1'b1) begin\n        z <= 1'b1;\n    end else begin\n        z <= 1'b1;\n    end\nend\nendmodule", "    reg z_reg;\n    always @(*) begin\n        if (x == 0 && y == 0) begin\n            z_reg = 1;\n        end else if (x == 1 && y == 0) begin\n            z_reg = 0;\n        end else if (x == 0 && y == 1) begin\n            z_reg = 0;\n        end else if (x == 1 && y == 1) begin\n            z_reg = 1;\n        end\n    end\n    assign z = z_reg;\nendmodule", "always @(posedge clk) begin\n    if (x && ~y) begin\n        z <= 0;\n    end else if (~x && y) begin\n        z <= 0;\n    end else if (x && y) begin\n        z <= 1;\n    end else begin\n        z <= 1;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (x == 1'b1 && y == 1'b0) begin\n        z <= 1'b0;\n    end else if (x == 1'b0 && y == 1'b1) begin\n        z <= 1'b0;\n    end else if (x == 1'b1 && y == 1'b1) begin\n        z <= 1'b1;\n    end else begin\n        z <= 1'b1;\n    end\nend\nendmodule", "    reg z_reg;\n    always @(posedge clk) begin\n        if (x == 0 && y == 0) begin\n            z_reg <= 1;\n        end else if (x == 1 && y == 0) begin\n            z_reg <= 0;\n        end else if (x == 0 && y == 1) begin\n            z_reg <= 0;\n        end else if (x == 1 && y == 1) begin\n            z_reg <= 1;\n        end\n    end\n    assign z = z_reg;\nendmodule"]}
{"task_id": "2012_q2fsm", "doubao_output": ["    // Define state names\n    localparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    // Declare state register\n    reg [2:0] state, next_state;\n    \n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // State encoding\n    parameter A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define state parameters\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    // Declare state registers\n    reg [2:0] state, next_state;\n    \n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) | (state == F);\n\nendmodule", "    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) | (state == F);\n\nendmodule", "    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) | (state == F);\n\nendmodule", "    // Define state codes\n    localparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    // Declare state register\n    reg [2:0] state, next_state;\n    \n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define state names\n    localparam A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    \n    // Declare state register\n    reg [2:0] state, next_state;\n    \n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n    \n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n    \n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule", "    // Define state names\n    localparam A = 3'd0, B = 3'd1, C = 3'd2, D = 3'd3, E = 3'd4, F = 3'd5;\n    reg [2:0] state, next_state;\n\n    // State table\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign z = (state == E) || (state == F);\n\nendmodule"]}
{"task_id": "dff16e", "doubao_output": ["always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule"]}
{"task_id": "edgedetect", "doubao_output": ["reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_reg;\nalways @(posedge clk) begin\n    in_reg <= in;\n    pedge <= in & ~in_reg;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule", "reg [7:0] in_prev;\nalways @(posedge clk) begin\n    in_prev <= in;\n    pedge <= in & ~in_prev;\nend\nendmodule"]}
{"task_id": "circuit8", "doubao_output": ["always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule", "always @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\nendmodule"]}
{"task_id": "rule90", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= q[1];\n        q[511] <= q[510];\n        for (int i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            if (i == 0) begin\n                q[i] <= q[i+1] ^ 1'b0;\n            end else if (i == 511) begin\n                q[i] <= q[i-1] ^ 1'b0;\n            end else begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= q[1];\n        q[511] <= q[510];\n        for (int i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            if (i == 0) begin\n                q[i] <= q[i+1] ^ 1'b0;\n            end else if (i == 511) begin\n                q[i] <= q[i-1] ^ 1'b0;\n            end else begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            if (i == 0) begin\n                q[i] <= q[i+1] ^ 1'b0;\n            end else if (i == 511) begin\n                q[i] <= q[i-1] ^ 1'b0;\n            end else begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            if (i == 0) begin\n                q[i] <= q[i+1] ^ 1'b0;\n            end else if (i == 511) begin\n                q[i] <= q[i-1] ^ 1'b0;\n            end else begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= q[1];\n        q[511] <= q[510];\n        for (int i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= q[1];\n        q[511] <= q[510];\n        for (int i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            if (i == 0) begin\n                q[i] <= q[i+1] ^ 1'b0;\n            end else if (i == 511) begin\n                q[i] <= q[i-1] ^ 1'b0;\n            end else begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (int i = 0; i < 512; i = i + 1) begin\n            if (i == 0) begin\n                q[i] <= q[i+1] ^ 1'b0;\n            end else if (i == 511) begin\n                q[i] <= q[i-1] ^ 1'b0;\n            end else begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\nend\nendmodule"]}
{"task_id": "mt2015_eq2", "doubao_output": ["assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B) ? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B) ? 1'b1 : 1'b0;\nendmodule", "assign z = (A == B)? 1'b1 : 1'b0;\nendmodule"]}
{"task_id": "gatesv100", "doubao_output": ["assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\n\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\n\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = in ^ {in[0], in[99:1]};\n\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\n\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\n\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = {in[0] ^ in[99], in[99:1] ^ in[98:0]};\n\nendmodule", "assign out_both = in[99:1] & in[98:0];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = in ^ {in[0], in[99:1]};\n\nendmodule"]}
{"task_id": "m2014_q4a", "doubao_output": ["always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule", "always @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule"]}
{"task_id": "mux256to1v", "doubao_output": ["assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3) : (sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3) : (sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3) : (sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3) : (sel * 4)];\nendmodule", "assign out = in[(sel * 4 + 3):(sel * 4)];\nendmodule"]}
{"task_id": "mux9to1v", "doubao_output": ["always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule", "always_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF;\n    endcase\nend\nendmodule"]}
{"task_id": "vectorgates", "doubao_output": ["assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule", "assign out_or_bitwise = a | b;\nassign out_or_logical = |a || |b;\nassign out_not = {~b, ~a};\nendmodule"]}
{"task_id": "fsm3onehot", "doubao_output": ["// State transition logic\nalways @(*) begin\n    case (1'b1)\n        state[0]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0001;\n        state[1]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0100;\n        state[2]: next_state = {4{in}} & 4'b1000 | {4{~in}} & 4'b0001;\n        state[3]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0100;\n        default: next_state = 4'b0000;\n    endcase\nend\n\n// Output logic\nassign out = state[3];\n\nendmodule", "// State encoding\nlocalparam A = 4'b0001;\nlocalparam B = 4'b0010;\nlocalparam C = 4'b0100;\nlocalparam D = 4'b1000;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        A: next_state = in? B : A;\n        B: next_state = in? B : C;\n        C: next_state = in? D : A;\n        D: next_state = in? B : C;\n        default: next_state = 4'b0000;\n    endcase\nend\n\n// Output logic\nassign out = (state == D);\n\nendmodule", "    // State transition logic\n    always @(*) begin\n        case (1'b1)\n            state[0]: next_state = {3'b000, in? 1'b1 : 1'b0};\n            state[1]: next_state = {2'b00, in? 1'b1 : 1'b0, 1'b0};\n            state[2]: next_state = {in? 1'b1 : 1'b0, 2'b00, in? 1'b0 : 1'b1};\n            state[3]: next_state = {1'b0, in? 1'b0 : 1'b1, 1'b0, in? 1'b1 : 1'b0};\n            default: next_state = 4'b0000;\n        endcase\n    end\n\n    // Output logic\n    assign out = state[3];\n\nendmodule", "// State transition logic\nalways @(*) begin\n    case (1'b1)\n        state[0]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0001;\n        state[1]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0100;\n        state[2]: next_state = {4{in}} & 4'b1000 | {4{~in}} & 4'b0001;\n        state[3]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0100;\n        default: next_state = 4'b0000;\n    endcase\nend\n\n// Output logic\nassign out = state[3];\n\nendmodule", "// State encoding\nlocalparam A = 4'b0001;\nlocalparam B = 4'b0010;\nlocalparam C = 4'b0100;\nlocalparam D = 4'b1000;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        A: next_state = in? B : A;\n        B: next_state = in? B : C;\n        C: next_state = in? D : A;\n        D: next_state = in? B : C;\n        default: next_state = 4'b0000;\n    endcase\nend\n\n// Output logic\nassign out = (state == D);\n\nendmodule", "// State transition logic\nalways @(*) begin\n    case (1'b1)\n        state[0]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0001;\n        state[1]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0100;\n        state[2]: next_state = {4{in}} & 4'b1000 | {4{~in}} & 4'b0001;\n        state[3]: next_state = {4{in}} & 4'b0010 | {4{~in}} & 4'b0100;\n        default: next_state = 4'b0000;\n    endcase\nend\n\n// Output logic\nassign out = state[3];\n\nendmodule", "// State transition logic\nalways @(*) begin\n    case (1'b1)\n        state[0]: next_state = in ? 4'b0010 : 4'b0001;\n        state[1]: next_state = in ? 4'b0010 : 4'b0100;\n        state[2]: next_state = in ? 4'b1000 : 4'b0001;\n        state[3]: next_state = in ? 4'b0010 : 4'b0100;\n        default: next_state = 4'b0000;\n    endcase\nend\n\n// Output logic\nassign out = state[3];\n\nendmodule", "    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0000;\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000);\n\nendmodule", "    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0000;\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000);\n\nendmodule", "    // State transition logic\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in? 4'b0010 : 4'b0001;\n            4'b0010: next_state = in? 4'b0010 : 4'b0100;\n            4'b0100: next_state = in? 4'b1000 : 4'b0001;\n            4'b1000: next_state = in? 4'b0010 : 4'b0100;\n            default: next_state = 4'b0000;\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000);\n\nendmodule"]}
{"task_id": "conditional", "doubao_output": ["always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    min <= (a < b)? ((a < c)? ((a < d)? a : d) : ((c < d)? c : d)) : ((b < c)? ((b < d)? b : d) : ((c < d)? c : d));\nend\nendmodule", "always @(posedge clk) begin\n    min <= (a < b)? ((a < c)? ((a < d)? a : d) : ((c < d)? c : d)) : ((b < c)? ((b < d)? b : d) : ((c < d)? c : d));\nend\nendmodule", "always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    min = a;\n    if (b < min) begin\n        min = b;\n    end\n    if (c < min) begin\n        min = c;\n    end\n    if (d < min) begin\n        min = d;\n    end\nend\nendmodule"]}
{"task_id": "gates", "doubao_output": ["assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule", "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule"]}
{"task_id": "kmap2", "doubao_output": ["assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (b & c & d) | (a & b & ~d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (b & c & d) | (a & b & ~d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule", "assign out = (~a & ~b & ~c) | (~a & ~c & ~d) | (~b & ~c & ~d) | (a & b & c) | (a & c & d) | (b & c & d);\nendmodule"]}
{"task_id": "2014_q3fsm", "doubao_output": ["    // Define states\n    localparam A = 1'b0, B = 1'b1;\n    reg state, next_state;\n    reg [1:0] count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                if (count == 2'b10) begin\n                    count <= 2'b00;\n                end else begin\n                    count <= count + 1;\n                end\n            end\n        end\n    end\n\n    // Output logic\n    reg [2:0] w_history;\n    always @(posedge clk) begin\n        if (reset) begin\n            w_history <= 3'b000;\n            z <= 1'b0;\n        end else if (state == B) begin\n            w_history <= {w_history[1:0], w};\n            if (count == 2'b10) begin\n                z <= (w_history[0] + w_history[1] + w_history[2] == 2);\n            end\n        end\n    end\n\nendmodule", "    // Define states\n    localparam A = 0, B = 1, C = 2, D = 3, E = 4;\n    reg [2:0] state, next_state;\n    reg [1:0] one_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = C;\n            C: next_state = D;\n            D: next_state = E;\n            E: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            one_count <= 2'b00;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                one_count <= w ? 2'b01 : 2'b00;\n            end else if (state == C || state == D) begin\n                one_count <= one_count + w;\n            end\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            z <= 1'b0;\n        end else if (state == E) begin\n            z <= (one_count == 2'b10);\n        end\n    end\n\nendmodule", "    // Parameterize the states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n    reg [1:0] count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = B;\n        endcase\n    end\n\n    // State flip-flop\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                if (w) begin\n                    count <= count + 1;\n                end\n                if (count == 3'd3) begin\n                    z <= (count == 2'd2);\n                    count <= 2'b00;\n                end else begin\n                    count <= count + 1;\n                end\n            end\n        end\n    end\n\nendmodule", "    // Define states\n    localparam A = 0, B = 1, C = 2, D = 3, E = 4;\n    reg [2:0] state, next_state;\n    reg [1:0] one_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = C;\n            C: next_state = D;\n            D: next_state = E;\n            E: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Count the number of w = 1 in states B, C, D\n    always @(posedge clk) begin\n        if (reset) begin\n            one_count <= 2'b00;\n        end else if (state == B || state == C || state == D) begin\n            one_count <= one_count + w;\n        end else if (state == E) begin\n            one_count <= 2'b00;\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            z <= 1'b0;\n        end else if (state == E) begin\n            z <= (one_count == 2'b10);\n        end\n    end\n\nendmodule", "    // Define states\n    localparam A = 1'b0, B = 1'b1;\n    reg state, next_state;\n    reg [1:0] count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                if (count == 2'b10) begin\n                    z <= (count == 2'b10) ? (w ? 1'b1 : 1'b0) : 1'b0;\n                    count <= 2'b00;\n                end else begin\n                    count <= count + 1'b1;\n                    if (w) begin\n                        count <= count + 1'b1;\n                    end\n                end\n            end\n        end\n    end\n\nendmodule", "    // Parameterize states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n    reg [1:0] count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                if (count == 2'b10) begin\n                    z <= (count == 2'b10 && w) || (count == 2'b01 && w && count[1]) || (count == 2'b00 && w && count[1:0] == 2'b10);\n                    count <= 2'b00;\n                end else begin\n                    count <= count + w;\n                end\n            end\n        end\n    end\n\nendmodule", "    // State declarations\n    localparam A = 0, B = 1, C = 2, D = 3, E = 4;\n    reg [2:0] state, next_state;\n    reg [1:0] one_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = C;\n            C: next_state = D;\n            D: next_state = E;\n            E: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Count the number of w = 1 in the three clock cycles\n    always @(posedge clk) begin\n        if (reset) begin\n            one_count <= 2'b00;\n        end else if (state == B) begin\n            one_count <= w ? 2'b01 : 2'b00;\n        end else if (state == C || state == D) begin\n            one_count <= one_count + w;\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            z <= 1'b0;\n        end else if (state == E) begin\n            z <= (one_count == 2'b10);\n        end\n    end\n\nendmodule", "    // Define states\n    localparam A = 0, B = 1, C = 2, D = 3, E = 4;\n    reg [2:0] state, next_state;\n    reg [1:0] one_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = C;\n            C: next_state = D;\n            D: next_state = E;\n            E: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            one_count <= 2'b00;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            case (state)\n                B: one_count <= w ? 2'b01 : 2'b00;\n                C: one_count <= one_count + (w ? 2'b01 : 2'b00);\n                D: one_count <= one_count + (w ? 2'b01 : 2'b00);\n                E: z <= (one_count == 2'b10);\n            endcase\n        end\n    end\n\nendmodule", "    // State declarations\n    localparam A = 1'b0, B = 1'b1;\n    reg state, next_state;\n    reg [1:0] count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 2'b00;\n            z <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == B) begin\n                if (count == 2'b10) begin\n                    z <= (count == 2'b10) ? ((w + count) == 2'b10) : 1'b0;\n                    count <= 2'b00;\n                end else begin\n                    count <= count + w;\n                end\n            end\n        end\n    end\n\nendmodule", "    // Define states\n    localparam A = 0, B = 1, C = 2, D = 3, E = 4;\n    reg [2:0] state, next_state;\n    reg [1:0] one_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;\n            B: next_state = C;\n            C: next_state = D;\n            D: next_state = E;\n            E: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Count the number of w = 1 in three clock cycles\n    always @(posedge clk) begin\n        if (reset) begin\n            one_count <= 2'b00;\n        end else if (state == B) begin\n            one_count <= w ? 2'b01 : 2'b00;\n        end else if (state == C) begin\n            one_count <= one_count + (w ? 2'b01 : 2'b00);\n        end else if (state == D) begin\n            one_count <= one_count + (w ? 2'b01 : 2'b00);\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            z <= 1'b0;\n        end else if (state == E) begin\n            z <= (one_count == 2'b10);\n        end\n    end\n\nendmodule"]}
{"task_id": "vector4", "doubao_output": ["assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule", "assign out = { {24{in[7]}}, in };\nendmodule"]}
{"task_id": "m2014_q4k", "doubao_output": ["reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule", "reg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule"]}
{"task_id": "always_case2", "doubao_output": ["always @(*) begin\n    casez (in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    if (in[3]) begin\n        pos = 2'd3;\n    end else if (in[2]) begin\n        pos = 2'd2;\n    end else if (in[1]) begin\n        pos = 2'd1;\n    end else if (in[0]) begin\n        pos = 2'd0;\n    end else begin\n        pos = 2'd0;\n    end\nend\nendmodule", "always @(*) begin\n    if (in[3]) begin\n        pos = 2'd3;\n    end else if (in[2]) begin\n        pos = 2'd2;\n    end else if (in[1]) begin\n        pos = 2'd1;\n    end else if (in[0]) begin\n        pos = 2'd0;\n    end else begin\n        pos = 2'd0;\n    end\nend\nendmodule", "always @(*) begin\n    casez (in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    if (in[3]) begin\n        pos = 2'd3;\n    end else if (in[2]) begin\n        pos = 2'd2;\n    end else if (in[1]) begin\n        pos = 2'd1;\n    end else if (in[0]) begin\n        pos = 2'd0;\n    end else begin\n        pos = 2'd0;\n    end\nend\nendmodule", "always @(*) begin\n    if (in[3]) begin\n        pos = 2'd3;\n    end else if (in[2]) begin\n        pos = 2'd2;\n    end else if (in[1]) begin\n        pos = 2'd1;\n    end else if (in[0]) begin\n        pos = 2'd0;\n    end else begin\n        pos = 2'd0;\n    end\nend\nendmodule", "always @(*) begin\n    casez (in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\nendmodule", "always @(*) begin\n    if (in[3])\n        pos = 2'd3;\n    else if (in[2])\n        pos = 2'd2;\n    else if (in[1])\n        pos = 2'd1;\n    else if (in[0])\n        pos = 2'd0;\n    else\n        pos = 2'd0;\nend\nendmodule", "always @(*) begin\n    if (in[3]) begin\n        pos = 2'd3;\n    end else if (in[2]) begin\n        pos = 2'd2;\n    end else if (in[1]) begin\n        pos = 2'd1;\n    end else if (in[0]) begin\n        pos = 2'd0;\n    end else begin\n        pos = 2'd0;\n    end\nend\nendmodule", "always @(*) begin\n    if (in[3]) begin\n        pos = 2'd3;\n    end else if (in[2]) begin\n        pos = 2'd2;\n    end else if (in[1]) begin\n        pos = 2'd1;\n    end else if (in[0]) begin\n        pos = 2'd0;\n    end else begin\n        pos = 2'd0;\n    end\nend\nendmodule"]}
{"task_id": "fsm2", "doubao_output": ["    // Parameterize the states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule", "    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: if (j) state <= ON;\n                ON: if (k) state <= OFF;\n                default: state <= OFF;\n            endcase\n        end\n    end\n\n    assign out = (state == ON);\n\nendmodule", "    // Parameterize the states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: if (j) state <= ON;\n                ON: if (k) state <= OFF;\n                default: state <= OFF;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule", "    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out = (state == ON)? 1'b1 : 1'b0;\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON)? 1'b1 : 1'b0;\n\nendmodule", "    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out = (state == ON);\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule", "    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: if (j) state <= ON;\n                ON: if (k) state <= OFF;\n                default: state <= OFF;\n            endcase\n        end\n    end\n\n    assign out = (state == ON);\n\nendmodule", "    // Parameterize the states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == ON);\n\nendmodule"]}
{"task_id": "m2014_q4i", "doubao_output": ["assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule", "assign out = 1'b0;\nendmodule"]}
{"task_id": "step_one", "doubao_output": ["assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule", "assign one = 1'b1;\nendmodule"]}
{"task_id": "vector100r", "doubao_output": ["always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule", "always @(posedge clk) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] <= in[99 - i];\n    end\nend\nendmodule"]}
{"task_id": "m2014_q4d", "doubao_output": ["always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "logic xor_out;\nassign xor_out = in ^ out;\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "logic xor_out;\nassign xor_out = in ^ out;\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "always_ff @(posedge clk) begin\n    out <= in ^ out;\nend\nendmodule", "logic xor_out;\nassign xor_out = in ^ out;\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\nendmodule", "logic xor_out;\nassign xor_out = in ^ out;\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\nendmodule", "logic xor_out;\nassign xor_out = in ^ out;\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\nendmodule"]}
{"task_id": "shift4", "doubao_output": ["always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule"]}
{"task_id": "truthtable1", "doubao_output": ["assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule", "assign f = (~x3 & x2) | (x3 & x1);\nendmodule"]}
{"task_id": "dff8ar", "doubao_output": ["always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "always @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule"]}
{"task_id": "gates100", "doubao_output": ["assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule", "assign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\nendmodule"]}
{"task_id": "hadd", "doubao_output": ["assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule", "assign sum = a ^ b;\nassign cout = a & b;\nendmodule"]}
{"task_id": "always_if2", "doubao_output": ["    // Bug fix: Add an else condition to the first always block to avoid a latch\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // Bug fix: Add an else condition to the second always block to avoid a latch\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "// Bug fixes:\n// 1. The original code had commented-out module and port declarations, which were incorrect.\n// 2. In the first always block, we need to add an else condition to handle the case when cpu_overheated is 0.\n// 3. In the second always block, we need to add an else condition to handle the case when arrived is 1.\n\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\n    else\n        shut_off_computer = 0;\nend\n\nalways @(*) begin\n    if (~arrived)\n        keep_driving = ~gas_tank_empty;\n    else\n        keep_driving = 0;\nend\n\nendmodule", "    // Bug fix: Add default values to avoid latches\n    always @(*) begin\n        shut_off_computer = 0;\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        keep_driving = 0;\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule", "    // Bug fix: Add an else condition to the first always block to avoid latches\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // Bug fix: Add an else condition to the second always block to avoid latches\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "// Bug fixes:\n// 1. The initial code had commented-out module and endmodule lines, which were incorrect.\n// 2. Added default values in the combinational logic to avoid latches.\n\nalways @(*) begin\n    if (cpu_overheated)\n        shut_off_computer = 1;\n    else\n        shut_off_computer = 0;\nend\n\nalways @(*) begin\n    if (~arrived)\n        keep_driving = ~gas_tank_empty;\n    else\n        keep_driving = 0;\nend\n\nendmodule", "// Bug fixes:\n// 1. Added missing initial values for the output registers to avoid latches.\n// 2. The original code did not handle the cases when the conditions are false, so we add default assignments.\n\nalways @(*) begin\n    // Default assignment to avoid latches\n    shut_off_computer = 0;\n    if (cpu_overheated) begin\n        shut_off_computer = 1;\n    end\nend\n\nalways @(*) begin\n    // Default assignment to avoid latches\n    keep_driving = 0;\n    if (~arrived) begin\n        keep_driving = ~gas_tank_empty;\n    end\nend\n\nendmodule", "    // Bug fix: Add an else condition to the first always block to avoid a latch\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // Bug fix: Add an else condition to the second always block to avoid a latch\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "    // Bug fix: Add an else condition to the first always block to avoid a latch\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // Bug fix: Add an else condition to the second always block to avoid a latch\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "    // Bug fix: Add an else condition to the first always block to ensure shut_off_computer is set to 0 when cpu_overheated is 0\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // Bug fix: Add an else condition to the second always block to ensure keep_driving is set to 0 when arrived is 1\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule", "    // Bug fix: Add an else block to set shut_off_computer to 0 when cpu_overheated is false\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // Bug fix: Add an else block to set keep_driving to 0 when arrived is true\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule"]}
{"task_id": "fsm2s", "doubao_output": ["    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out = (state == ON);\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == ON);\n\nendmodule", "    // Define the states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: if (j) state <= ON;\n                ON: if (k) state <= OFF;\n                default: state <= OFF;\n            endcase\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == ON);\n\nendmodule", "    // Define the states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic (Moore state machine, output depends only on state)\n    assign out = (state == ON);\n\nendmodule", "    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out = (state == ON);\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic (Moore state machine, output depends only on state)\n    assign out = (state == ON);\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic (Moore state machine)\n    assign out = (state == ON);\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule", "    // Define states\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == ON);\n\nendmodule", "    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= OFF;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                    end else begin\n                        state <= OFF;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                    end else begin\n                        state <= ON;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign out = (state == ON);\n\nendmodule"]}
{"task_id": "vector3", "doubao_output": ["assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule", "assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule", "wire [31:0] combined;\nassign combined = {a, b, c, d, e, f, 2'b11};\nassign w = combined[31:24];\nassign x = combined[23:16];\nassign y = combined[15:8];\nassign z = combined[7:0];\nendmodule", "wire [31:0] concat;\nassign concat = {a, b, c, d, e, f, 2'b11};\nassign w = concat[31:24];\nassign x = concat[23:16];\nassign y = concat[15:8];\nassign z = concat[7:0];\nendmodule", "wire [31:0] concat;\nassign concat = {a, b, c, d, e, f, 2'b11};\nassign w = concat[31:24];\nassign x = concat[23:16];\nassign y = concat[15:8];\nassign z = concat[7:0];\nendmodule", "wire [31:0] combined;\nassign combined = {a, b, c, d, e, f, 2'b11};\nassign w = combined[31:24];\nassign x = combined[23:16];\nassign y = combined[15:8];\nassign z = combined[7:0];\nendmodule", "assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule", "assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule", "assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule", "assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule"]}
{"task_id": "circuit2", "doubao_output": ["assign q = (a&b&c&d) | (~a&~b&c&d) | (~a&b&~c&d) | (~a&b&c&~d) | (a&~b&~c&d) | (a&~b&c&~d) | (a&b&~c&~d);\nendmodule", "assign q = (a&b&c&d) | (a&b&~c&~d) | (a&~b&c&~d) | (a&~b&~c&d) | (~a&b&c&~d) | (~a&b&~c&d) | (~a&~b&c&d);\nendmodule", "assign q = (a&b&c&d) | (a&b&~c&~d) | (a&~b&c&~d) | (a&~b&~c&d) | (~a&b&c&~d) | (~a&b&~c&d) | (~a&~b&c&d);\nendmodule", "assign q = ((~a & ~b & c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & d));\nendmodule", "assign q = (a&b&c&d) | (~a&~b&c&d) | (~a&b&~c&d) | (~a&b&c&~d) | (a&~b&~c&d) | (a&~b&c&~d) | (a&b&~c&~d);\nendmodule", "assign q = (a&b&c&d) | (a&b&~c&~d) | (a&~b&c&~d) | (a&~b&~c&d) | (~a&b&c&~d) | (~a&b&~c&d) | (~a&~b&c&d);\nendmodule", "assign q = (~a & ~b & c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & d);\nendmodule", "assign q = (~a & ~b & c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & d);\nendmodule", "assign q = (a & b & ~c & ~d) | (a & ~b & c & ~d) | (a & ~b & ~c & d) | (~a & b & c & ~d) | (~a & b & ~c & d) | (~a & ~b & c & d) | (~a & ~b & ~c & ~d) | (a & b & c & d);\nendmodule", "assign q = (a&b&c&d) | (a&b&~c&~d) | (a&~b&c&~d) | (a&~b&~c&d) | (~a&b&c&~d) | (~a&b&~c&d) | (~a&~b&c&d);\nendmodule"]}
{"task_id": "andgate", "doubao_output": ["assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule", "assign out = a & b;\nendmodule"]}
{"task_id": "fsm1s", "doubao_output": ["    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            case (state)\n                A: state <= in ? A : B;\n                B: state <= in ? B : A;\n                default: state <= B;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            case (state)\n                A: state <= in ? A : B;\n                B: state <= in ? B : A;\n                default: state <= B;\n            endcase\n        end\n    end\n\n    // Output logic (Moore machine)\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            case (state)\n                A: state <= in ? A : B;\n                B: state <= in ? B : A;\n                default: state <= B;\n            endcase\n        end\n    end\n\n    // Output logic (Moore machine, output depends only on state)\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    // Define states\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign out = (state == B);\n\nendmodule", "    parameter A = 1'b0, B = 1'b1;\n    reg state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            case (state)\n                A: state <= in ? A : B;\n                B: state <= in ? B : A;\n            endcase\n        end\n    end\n\n    assign out = (state == B);\n\nendmodule"]}
{"task_id": "fadd", "doubao_output": ["assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule", "assign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"]}
{"task_id": "m2014_q4g", "doubao_output": ["logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule", "logic xnor_out;\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\nendmodule"]}
{"task_id": "ece241_2014_q3", "doubao_output": ["    assign mux_in[0] = c | d;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c & d;\n    assign mux_in[3] = ~d | c;\n\nendmodule", "    assign mux_in[0] = c | d;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c & d;\n    assign mux_in[3] = ~d | c;\nendmodule", "    assign mux_in[0] = c | d;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c & d;\n    assign mux_in[3] = ~d | c;\n\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = c & d;\nassign mux_in[3] = ~d | c;\n\nendmodule", "    assign mux_in[0] = c | d;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c & d;\n    assign mux_in[3] = ~d | c;\nendmodule", "    assign mux_in[0] = c | d;\n    assign mux_in[1] = 1'b0;\n    assign mux_in[2] = c & d;\n    assign mux_in[3] = c | ~d;\n\nendmodule", "    // For mux_in[0]\n    assign mux_in[0] = c | d;\n    // For mux_in[1]\n    assign mux_in[1] = 1'b0;\n    // For mux_in[2]\n    wire temp;\n    assign temp = c & d;\n    assign mux_in[2] = temp;\n    // For mux_in[3]\n    assign mux_in[3] = ~d | c;\n\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = c & d;\nassign mux_in[3] = ~d | c;\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = c & d;\nassign mux_in[3] = c | ~d;\n\nendmodule", "assign mux_in[0] = c | d;\nassign mux_in[1] = 1'b0;\nassign mux_in[2] = c & d;\nassign mux_in[3] = ~d | c;\n\nendmodule"]}
{"task_id": "ece241_2014_q5b", "doubao_output": ["    // One-hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (x == 1'b0) begin\n                        state <= STATE_A;\n                    end else begin\n                        state <= STATE_B;\n                    end\n                end\n                STATE_B: begin\n                    state <= STATE_B;\n                end\n                default: state <= STATE_A;\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One - hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n    reg [1:0] state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (x == 0) begin\n                        state <= STATE_A;\n                    end else begin\n                        state <= STATE_B;\n                    end\n                end\n                STATE_B: begin\n                    state <= STATE_B;\n                end\n                default: state <= STATE_A;\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One-hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // State register with asynchronous active-high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            STATE_B: begin\n                next_state = STATE_B;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One - hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (x == 0) begin\n                        state <= STATE_A;\n                    end else begin\n                        state <= STATE_B;\n                    end\n                end\n                STATE_B: begin\n                    state <= STATE_B;\n                end\n                default: state <= STATE_A;\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One - hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            STATE_B: begin\n                next_state = STATE_B;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One-hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            STATE_B: begin\n                next_state = STATE_B;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One - hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            STATE_B: begin\n                next_state = STATE_B;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One-hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (x == 1'b0) begin\n                        state <= STATE_A;\n                    end else begin\n                        state <= STATE_B;\n                    end\n                end\n                STATE_B: begin\n                    state <= STATE_B;\n                end\n                default: state <= STATE_A;\n            endcase\n        end\n    end\n\n    // Output logic (Mealy machine)\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One-hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (x == 1'b0) begin\n                        state <= STATE_A;\n                    end else begin\n                        state <= STATE_B;\n                    end\n                end\n                STATE_B: begin\n                    state <= STATE_B;\n                end\n                default: state <= STATE_A;\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule", "    // One - hot encoding for states\n    parameter STATE_A = 2'b01;\n    parameter STATE_B = 2'b10;\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // State register with asynchronous active - high reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B;\n                end\n            end\n            STATE_B: begin\n                next_state = STATE_B;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (x == 1'b0) begin\n                    z = 1'b0;\n                end else begin\n                    z = 1'b1;\n                end\n            end\n            STATE_B: begin\n                if (x == 1'b0) begin\n                    z = 1'b1;\n                end else begin\n                    z = 1'b0;\n                end\n            end\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "circuit10", "doubao_output": ["reg next_state;\nalways @(posedge clk) begin\n    state <= next_state;\nend\n\nalways @(*) begin\n    case ({a, b, state})\n        3'b000: next_state = 0;\n        3'b001: next_state = 1;\n        3'b010: next_state = 0;\n        3'b011: next_state = 1;\n        3'b100: next_state = 0;\n        3'b101: next_state = 1;\n        3'b110: next_state = 1;\n        3'b111: next_state = 1;\n    endcase\nend\n\nassign q = (a == 0 && b == 1) || (a == 0 && state == 1) || (a == 1 && b == 0 && state == 1);\n\nendmodule", "    reg state_reg;\n    always @(posedge clk) begin\n        if (a && b) begin\n            state_reg <= 0;\n        end else if (!a && b) begin\n            state_reg <= 0;\n        end else if (a && !b) begin\n            state_reg <= 0;\n        end else if (!a && !b) begin\n            state_reg <= 1;\n        end\n    end\n\n    assign state = state_reg;\n    assign q = (!state_reg && b) || (state_reg && !b);\n\nendmodule", "reg next_state;\nreg current_state;\n\n// Combinational logic to determine the next state\nalways @(*) begin\n    case ({a, b, current_state})\n        3'b000: next_state = 1'b0;\n        3'b001: next_state = 1'b1;\n        3'b010: next_state = 1'b0;\n        3'b011: next_state = 1'b0;\n        3'b100: next_state = 1'b0;\n        3'b101: next_state = 1'b0;\n        3'b110: next_state = 1'b1;\n        3'b111: next_state = 1'b1;\n        default: next_state = 1'bx;\n    endcase\nend\n\n// State update on positive clock edge\nalways @(posedge clk) begin\n    current_state <= next_state;\nend\n\n// Output logic\nassign q = (a == 1'b0 && b == 1'b1 && current_state == 1'b0) || (a == 1'b0 && b == 1'b0 && current_state == 1'b1);\nassign state = current_state;\n\nendmodule", "    reg state_reg;\n    always @(posedge clk) begin\n        if (a && b) begin\n            state_reg <= 0;\n        end else if (!a && b) begin\n            state_reg <= 1;\n        end else if (!a && !b) begin\n            state_reg <= state_reg;\n        end else if (a && !b) begin\n            state_reg <= 0;\n        end\n    end\n    assign state = state_reg;\n    assign q = (!state_reg && b) || (state_reg && !b);\n\nendmodule", "    reg state_reg;\n    always @(posedge clk) begin\n        if (a & b) begin\n            state_reg <= 0;\n        end else if (!a & b) begin\n            state_reg <= 1;\n        end else if (!a & !b) begin\n            state_reg <= state_reg;\n        end else if (a & !b) begin\n            state_reg <= 0;\n        end\n    end\n\n    assign state = state_reg;\n    assign q = (!state_reg & b) | (state_reg & !b);\n\nendmodule", "    reg state_reg;\n    always @(posedge clk) begin\n        if (a & b) begin\n            state_reg <= 0;\n        end else if (~a & ~b) begin\n            state_reg <= 1;\n        end\n    end\n    \n    assign q = ~(state_reg & a & ~b);\n    assign state = state_reg;\n\nendmodule", "reg state_reg;\nalways @(posedge clk) begin\n    if (a & b) begin\n        state_reg <= 0;\n    end else if (~a & ~b) begin\n        state_reg <= 1;\n    end\nend\n\nassign q = (~state_reg & b) | (state_reg & ~b);\nassign state = state_reg;\n\nendmodule", "    reg state_reg;\n    always @(posedge clk) begin\n        state_reg <= (a & b) ? 0 : ((~a & ~b) ? 1 : state_reg);\n    end\n    assign q = (~state_reg & b) | (state_reg & ~(a | b));\n    assign state = state_reg;\n\nendmodule", "reg next_state;\nreg current_state;\n\n// Combinational logic to determine the next state\nalways @(*) begin\n    if (a & b) begin\n        next_state = 0;\n    end else if (b) begin\n        next_state = 0;\n    end else if (a) begin\n        next_state = 0;\n    end else begin\n        next_state = 1;\n    end\nend\n\n// Flip - flop to store the state\nalways @(posedge clk) begin\n    current_state <= next_state;\nend\n\n// Combinational logic to determine the output q\nassign q = ~(a & b);\n\n// Output the state\nassign state = current_state;\n\nendmodule", "    reg state_reg;\n    always @(posedge clk) begin\n        state_reg <= ~(a & b);\n    end\n    assign q = ~(state_reg & a & ~b);\n    assign state = state_reg;\n\nendmodule"]}
{"task_id": "2012_q1g", "doubao_output": ["assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & x[3] & ~x[2]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & ~x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & x[2]) | (x[4] & x[3] & x[2]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & ~x[3] & x[1]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & ~x[3] & x[1]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & ~x[3] & x[1]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[2]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[2]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & ~x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & x[2]) | (x[4] & x[3] & x[2]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & x[3] & ~x[2]);\nendmodule", "assign f = (~x[4] & ~x[3] & ~x[2]) | (~x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[1]) | (x[4] & ~x[3] & ~x[2]) | (x[4] & ~x[3] & x[1]) | (x[4] & x[3] & ~x[2]);\nendmodule"]}
{"task_id": "fsm_hdlc", "doubao_output": ["    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign disc = (state == S5 && !in);\n    assign flag = (state == S6 && !in);\n    assign err = (state == S7 && !in);\n\nendmodule", "    // Define states\n    parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n    reg [1:0] state, next_state;\n    reg [2:0] count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S3 : (count == 3'd5) ? S0 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            count <= 3'd0;\n        end else begin\n            state <= next_state;\n            if (in) begin\n                if (state == S0)\n                    count <= 3'd1;\n                else if (state == S1)\n                    count <= 3'd2;\n                else if (state == S2)\n                    count <= 3'd3;\n                else if (state == S3)\n                    count <= count + 1;\n            end else begin\n                count <= 3'd0;\n            end\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err <= 1'b0;\n        end else begin\n            disc <= (count == 3'd5 && !in);\n            flag <= (count == 3'd6 && !in);\n            err <= (count >= 3'd7 && !in);\n        end\n    end\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in? S1 : S0;\n            S1: next_state = in? S2 : S0;\n            S2: next_state = in? S3 : S0;\n            S3: next_state = in? S4 : S0;\n            S4: next_state = in? S5 : S0;\n            S5: next_state = in? S6 : S0;\n            S6: next_state = in? S7 : S0;\n            S7: next_state = in? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err <= 1'b0;\n        end else begin\n            disc <= (state == S5 && ~in);\n            flag <= (state == S6 && ~in);\n            err <= (state == S7 && ~in);\n        end\n    end\n\nendmodule", "    // Define states\n    localparam S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err <= 1'b0;\n        end\n        else begin\n            disc <= (state == S5 && !in);\n            flag <= (state == S6 && !in);\n            err <= (state == S7 && !in);\n        end\n    end\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign disc = (state == S5 && !in);\n    assign flag = (state == S6 && !in);\n    assign err = (state == S7);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in? S1 : S0;\n            S1: next_state = in? S2 : S0;\n            S2: next_state = in? S3 : S0;\n            S3: next_state = in? S4 : S0;\n            S4: next_state = in? S5 : S0;\n            S5: next_state = in? S6 : S0;\n            S6: next_state = in? S7 : S0;\n            S7: next_state = in? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign disc = (state == S5 &&!in);\n    assign flag = (state == S6 &&!in);\n    assign err = (state == S7 &&!in);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err <= 1'b0;\n        end else begin\n            disc <= (state == S5 && !in);\n            flag <= (state == S6 && !in);\n            err <= (state == S7 && !in);\n        end\n    end\n\nendmodule", "    // State declarations\n    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4, S5 = 3'd5, S6 = 3'd6;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S6 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err <= 1'b0;\n        end else begin\n            disc <= (state == S5 && !in);\n            flag <= (state == S6 && !in);\n            err <= (state == S6 && in);\n        end\n    end\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in? S1 : S0;\n            S1: next_state = in? S2 : S0;\n            S2: next_state = in? S3 : S0;\n            S3: next_state = in? S4 : S0;\n            S4: next_state = in? S5 : S0;\n            S5: next_state = in? S6 : S0;\n            S6: next_state = in? S7 : S0;\n            S7: next_state = in? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    assign disc = (state == S5 &&!in);\n    assign flag = (state == S6 &&!in);\n    assign err = (state == S7 &&!in);\n\nendmodule", "    reg [2:0] state, next_state;\n    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err <= 1'b0;\n        end else begin\n            disc <= (state == S5 && ~in);\n            flag <= (state == S6 && ~in);\n            err <= (state == S7 && ~in);\n        end\n    end\n\nendmodule"]}
{"task_id": "review2015_fancytimer", "doubao_output": ["    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [11:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            shift_reg <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg[0] == 1'b1) begin\n                        delay <= shift_reg[3:0];\n                        cycle_count <= 12'd0;\n                        state <= S_COUNTING;\n                        counting <= 1'b1;\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == ((delay + 1) * 1000) - 1) begin\n                        state <= S_DONE;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (counting)? (delay - (cycle_count / 1000)) : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [11:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            counting <= 1'b0;\n            done <= 1'b0;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 12'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:0]) begin\n                        state <= S_COUNTING;\n                        counting <= 1'b1;\n                        cycle_count <= 12'b0;\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == ((delay + 1) * 1000) - 1) begin\n                        state <= S_DONE;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (counting) ? delay - (cycle_count / 1000) : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [11:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            counting <= 1'b0;\n            done <= 1'b0;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 12'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    delay <= {delay[2:0], data};\n                    if (cycle_count == 3) begin\n                        state <= S_COUNTING;\n                        counting <= 1'b1;\n                        cycle_count <= 12'b0;\n                    end else begin\n                        cycle_count <= cycle_count + 1;\n                    end\n                end\n                S_COUNTING: begin\n                    if (cycle_count == {delay + 1, 10'b0} - 1) begin\n                        state <= S_DONE;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                        cycle_count <= 12'b0;\n                    end else begin\n                        cycle_count <= cycle_count + 1;\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                        shift_reg <= 4'b0;\n                        delay <= 4'b0;\n                        cycle_count <= 12'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (counting) ? delay - (cycle_count[11:10]) : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [9:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            shift_reg <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg[3]) begin\n                        delay <= {delay[2:0], data};\n                        if (&shift_reg[3:0]) begin\n                            state <= S_COUNTING;\n                            cycle_count <= 10'd0;\n                            counting <= 1'b1;\n                        end\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == 10'd999) begin\n                        cycle_count <= 10'd0;\n                        if (delay == 4'd0) begin\n                            state <= S_DONE;\n                            counting <= 1'b0;\n                            done <= 1'b1;\n                        end else begin\n                            delay <= delay - 1;\n                        end\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (counting)? delay : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [11:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 12'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg[3]) begin\n                        delay <= {delay[2:0], data};\n                        if (&shift_reg[3:0]) begin\n                            state <= S_COUNTING;\n                            cycle_count <= 12'b0;\n                            counting <= 1'b1;\n                        end\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == {delay + 1, 10'b0}) begin\n                        state <= S_DONE;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                    end\n                end\n                default: state <= S_SEARCH;\n            endcase\n        end\n    end\n\n    assign count = (state == S_COUNTING)? (delay - cycle_count[11:10]) : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [11:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            counting <= 1'b0;\n            done <= 1'b0;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 12'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:0]) begin\n                        state <= S_COUNTING;\n                        counting <= 1'b1;\n                        cycle_count <= 12'b0;\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == ((delay + 1) * 1000) - 1) begin\n                        state <= S_DONE;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = counting ? (delay - (cycle_count / 1000)) : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [9:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            counting <= 1'b0;\n            done <= 1'b0;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 10'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    delay <= {delay[2:0], data};\n                    if ($countones(delay) == 4) begin\n                        state <= S_COUNTING;\n                        counting <= 1'b1;\n                        cycle_count <= 10'b0;\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == 10'd999) begin\n                        if (delay == 4'b0) begin\n                            state <= S_DONE;\n                            counting <= 1'b0;\n                            done <= 1'b1;\n                        end else begin\n                            delay <= delay - 1;\n                            cycle_count <= 10'b0;\n                        end\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                        shift_reg <= 4'b0;\n                    end\n                end\n                default: state <= S_SEARCH;\n            endcase\n        end\n    end\n\n    assign count = (counting)? delay : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [9:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_SHIFT_DELAY = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            counting <= 1'b0;\n            done <= 1'b0;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 10'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_SHIFT_DELAY;\n                    end\n                end\n                S_SHIFT_DELAY: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg[3]) begin\n                        delay <= {delay[2:0], data};\n                        if (shift_reg[0]) begin\n                            state <= S_COUNTING;\n                            counting <= 1'b1;\n                            cycle_count <= 10'b0;\n                        end\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == 10'd999) begin\n                        cycle_count <= 10'b0;\n                        if (delay == 4'b0) begin\n                            state <= S_DONE;\n                            counting <= 1'b0;\n                            done <= 1'b1;\n                        end else begin\n                            delay <= delay - 1;\n                        end\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (counting)? delay : 4'bxxxx;\n\nendmodule", "    // Internal variables\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [11:0] cycle_count;\n    reg [2:0] state;\n    parameter SEARCH = 3'd0, LOAD_DELAY = 3'd1, COUNTING = 3'd2, WAIT_ACK = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= SEARCH;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 12'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= LOAD_DELAY;\n                    end\n                end\n                LOAD_DELAY: begin\n                    delay <= {delay[2:0], data};\n                    if (cycle_count == 3) begin\n                        state <= COUNTING;\n                        cycle_count <= 12'b0;\n                        counting <= 1'b1;\n                    end else begin\n                        cycle_count <= cycle_count + 1;\n                    end\n                end\n                COUNTING: begin\n                    if (cycle_count == 1000 - 1) begin\n                        cycle_count <= 12'b0;\n                        if (delay == 0) begin\n                            state <= WAIT_ACK;\n                            counting <= 1'b0;\n                            done <= 1'b1;\n                        end else begin\n                            delay <= delay - 1;\n                        end\n                    end else begin\n                        cycle_count <= cycle_count + 1;\n                    end\n                end\n                WAIT_ACK: begin\n                    if (ack) begin\n                        state <= SEARCH;\n                        done <= 1'b0;\n                        shift_reg <= 4'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = (counting)? delay : 4'bxxxx;\n\nendmodule", "    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [11:0] cycle_count;\n    reg [2:0] state;\n    localparam S_SEARCH = 3'd0, S_DELAY_SHIFT = 3'd1, S_COUNTING = 3'd2, S_DONE = 3'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S_SEARCH;\n            shift_reg <= 4'b0;\n            delay <= 4'b0;\n            cycle_count <= 12'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= S_DELAY_SHIFT;\n                    end\n                end\n                S_DELAY_SHIFT: begin\n                    delay <= {delay[2:0], data};\n                    if (&delay[3:0]) begin\n                        state <= S_COUNTING;\n                        cycle_count <= 12'b0;\n                        counting <= 1'b1;\n                    end\n                end\n                S_COUNTING: begin\n                    cycle_count <= cycle_count + 1;\n                    if (cycle_count == ((delay + 1) * 1000) - 1) begin\n                        state <= S_DONE;\n                        counting <= 1'b0;\n                        done <= 1'b1;\n                    end\n                end\n                S_DONE: begin\n                    if (ack) begin\n                        state <= S_SEARCH;\n                        done <= 1'b0;\n                    end\n                end\n                default: state <= S_SEARCH;\n            endcase\n        end\n    end\n\n    assign count = (state == S_COUNTING)? (delay - (cycle_count / 1000)) : 4'bxxxx;\n\nendmodule"]}
{"task_id": "ece241_2013_q4", "doubao_output": ["    // Define states\n    localparam LOW = 4'd0, BETWEEN_1_2 = 4'd1, BETWEEN_2_3 = 4'd2, ABOVE_3 = 4'd3;\n    reg [1:0] state, next_state;\n    reg [1:0] prev_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LOW: next_state = s[1]? BETWEEN_1_2 : LOW;\n            BETWEEN_1_2: next_state = s[2]? BETWEEN_2_3 : (s[1]? BETWEEN_1_2 : LOW);\n            BETWEEN_2_3: next_state = s[3]? ABOVE_3 : (s[2]? BETWEEN_2_3 : BETWEEN_1_2);\n            ABOVE_3: next_state = s[3]? ABOVE_3 : BETWEEN_2_3;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= LOW;\n            prev_state <= LOW;\n        end else begin\n            prev_state <= state;\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = (prev_state < LOW)? 1'b1 : 1'b0;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b0;\n                dfr = (prev_state < BETWEEN_1_2)? 1'b1 : 1'b0;\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1'b1;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = (prev_state < BETWEEN_2_3)? 1'b1 : 1'b0;\n            end\n            ABOVE_3: begin\n                fr1 = 1'b0;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam STATE_ABOVE_S3 = 4'd0;\n    localparam STATE_BETWEEN_S3_S2 = 4'd1;\n    localparam STATE_BETWEEN_S2_S1 = 4'd2;\n    localparam STATE_BELOW_S1 = 4'd3;\n\n    reg [1:0] current_state, next_state;\n    reg [1:0] prev_state;\n\n    // State transition logic\n    always @(*) begin\n        case (s)\n            3'b111: next_state = STATE_ABOVE_S3;\n            3'b110: next_state = STATE_BETWEEN_S3_S2;\n            3'b100: next_state = STATE_BETWEEN_S2_S1;\n            default: next_state = STATE_BELOW_S1;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_BELOW_S1;\n            prev_state <= STATE_BELOW_S1;\n        end else begin\n            prev_state <= current_state;\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_ABOVE_S3: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n                dfr = 1'b0;\n            end\n            STATE_BETWEEN_S3_S2: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b1;\n                dfr = (prev_state < current_state)? 1'b1 : 1'b0;\n            end\n            STATE_BETWEEN_S2_S1: begin\n                fr3 = 1'b0;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = (prev_state < current_state)? 1'b1 : 1'b0;\n            end\n            STATE_BELOW_S1: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = 1'b1;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter LOW = 3'd0, MID1 = 3'd1, MID2 = 3'd2, HIGH = 3'd3;\n    reg [2:0] state, next_state;\n    reg prev_lower;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                if (s[1]) next_state = MID1;\n                else next_state = LOW;\n            end\n            MID1: begin\n                if (s[2]) next_state = MID2;\n                else if (!s[1]) next_state = LOW;\n                else next_state = MID1;\n            end\n            MID2: begin\n                if (s[3]) next_state = HIGH;\n                else if (!s[2]) next_state = MID1;\n                else next_state = MID2;\n            end\n            HIGH: begin\n                if (!s[3]) next_state = MID2;\n                else next_state = HIGH;\n            end\n            default: next_state = LOW;\n        endcase\n    end\n\n    // Determine if previous level was lower\n    always @(*) begin\n        case ({state, next_state})\n            {LOW, MID1}, {MID1, MID2}, {MID2, HIGH}: prev_lower = 1'b1;\n            default: prev_lower = 1'b0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (next_state)\n            LOW: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = 1'b0;\n            end\n            MID1: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b1;\n                dfr = prev_lower;\n            end\n            MID2: begin\n                fr3 = 1'b0;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = prev_lower;\n            end\n            HIGH: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = 1'b0;\n            end\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= LOW;\n        end else begin\n            state <= next_state;\n        end\n    end\n\nendmodule", "    // Define states\n    parameter LOW = 3'b000, BETWEEN_1_2 = 3'b001, BETWEEN_2_3 = 3'b010, ABOVE_3 = 3'b011;\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            LOW: next_state = s[1]? BETWEEN_1_2 : LOW;\n            BETWEEN_1_2: next_state = s[2]? BETWEEN_2_3 : (s[1]? BETWEEN_1_2 : LOW);\n            BETWEEN_2_3: next_state = s[3]? ABOVE_3 : (s[2]? BETWEEN_2_3 : BETWEEN_1_2);\n            ABOVE_3: next_state = s[3]? ABOVE_3 : BETWEEN_2_3;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= LOW;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            LOW: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 0;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 0;\n                dfr = (current_state > next_state)? 0 : 1;\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = (current_state > next_state)? 0 : 1;\n            end\n            ABOVE_3: begin\n                fr1 = 0;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = 0;\n            end\n            default: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam LOW = 4'd0, BETWEEN_1_2 = 4'd1, BETWEEN_2_3 = 4'd2, ABOVE_3 = 4'd3;\n    reg [1:0] state, next_state;\n    reg [3:1] prev_s;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LOW: next_state = s[1]? BETWEEN_1_2 : LOW;\n            BETWEEN_1_2: next_state = s[2]? BETWEEN_2_3 : (s[1]? BETWEEN_1_2 : LOW);\n            BETWEEN_2_3: next_state = s[3]? ABOVE_3 : (s[2]? BETWEEN_2_3 : BETWEEN_1_2);\n            ABOVE_3: next_state = s[3]? ABOVE_3 : BETWEEN_2_3;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= LOW;\n            prev_s <= 3'b000;\n        end else begin\n            state <= next_state;\n            prev_s <= s;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b0;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b0;\n                dfr = prev_s < s? 1'b1 : 1'b0;\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1'b1;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = prev_s < s? 1'b1 : 1'b0;\n            end\n            ABOVE_3: begin\n                fr1 = 1'b0;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam LOW = 0, BETWEEN_1_2 = 1, BETWEEN_2_3 = 2, HIGH = 3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                if (s[1]) next_state = BETWEEN_1_2;\n                else next_state = LOW;\n            end\n            BETWEEN_1_2: begin\n                if (s[2]) next_state = BETWEEN_2_3;\n                else if (!s[1]) next_state = LOW;\n                else next_state = BETWEEN_1_2;\n            end\n            BETWEEN_2_3: begin\n                if (s[3]) next_state = HIGH;\n                else if (!s[2]) next_state = BETWEEN_1_2;\n                else next_state = BETWEEN_2_3;\n            end\n            HIGH: begin\n                if (!s[3]) next_state = BETWEEN_2_3;\n                else next_state = HIGH;\n            end\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) state <= LOW;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 0;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 0;\n                dfr = (next_state > state);\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = (next_state > state);\n            end\n            HIGH: begin\n                fr1 = 0;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = 0;\n            end\n            default: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam LOW = 0, BETWEEN_1_2 = 1, BETWEEN_2_3 = 2, ABOVE_3 = 3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LOW: next_state = s[1]? BETWEEN_1_2 : LOW;\n            BETWEEN_1_2: next_state = s[2]? BETWEEN_2_3 : (s[1]? BETWEEN_1_2 : LOW);\n            BETWEEN_2_3: next_state = s[3]? ABOVE_3 : (s[2]? BETWEEN_2_3 : BETWEEN_1_2);\n            ABOVE_3: next_state = s[3]? ABOVE_3 : BETWEEN_2_3;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= LOW;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 0;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 0;\n                dfr = (state > next_state)? 0 : 1;\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = (state > next_state)? 0 : 1;\n            end\n            ABOVE_3: begin\n                fr1 = 0;\n                fr2 = 0;\n                fr3 = 0;\n                dfr = 0;\n            end\n            default: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter LOW = 3'd0, BETWEEN_1_2 = 3'd1, BETWEEN_2_3 = 3'd2, ABOVE_3 = 3'd3;\n    reg [2:0] current_state, next_state;\n    reg [2:0] prev_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            LOW: next_state = s[1]? BETWEEN_1_2 : LOW;\n            BETWEEN_1_2: next_state = s[2]? BETWEEN_2_3 : (s[1]? BETWEEN_1_2 : LOW);\n            BETWEEN_2_3: next_state = s[3]? ABOVE_3 : (s[2]? BETWEEN_2_3 : BETWEEN_1_2);\n            ABOVE_3: next_state = s[3]? ABOVE_3 : BETWEEN_2_3;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= LOW;\n            prev_state <= LOW;\n        end\n        else begin\n            prev_state <= current_state;\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            LOW: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = (prev_state < LOW)? 1'b1 : 1'b0;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b0;\n                dfr = (prev_state < BETWEEN_1_2)? 1'b1 : 1'b0;\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1'b1;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = (prev_state < BETWEEN_2_3)? 1'b1 : 1'b0;\n            end\n            ABOVE_3: begin\n                fr1 = 1'b0;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter LOW = 4'b0000, BETWEEN_1_2 = 4'b0001, BETWEEN_2_3 = 4'b0010, ABOVE_3 = 4'b0011;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LOW: next_state = s[1]? BETWEEN_1_2 : LOW;\n            BETWEEN_1_2: next_state = s[2]? BETWEEN_2_3 : (s[1]? BETWEEN_1_2 : LOW);\n            BETWEEN_2_3: next_state = s[3]? ABOVE_3 : (s[2]? BETWEEN_2_3 : BETWEEN_1_2);\n            ABOVE_3: next_state = s[3]? ABOVE_3 : BETWEEN_2_3;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= LOW;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b0;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b0;\n                dfr = (state > next_state)? 1'b0 : 1'b1;\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1'b1;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = (state > next_state)? 1'b0 : 1'b1;\n            end\n            ABOVE_3: begin\n                fr1 = 1'b0;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam LOW = 4'b0000;\n    localparam BETWEEN_1_2 = 4'b0001;\n    localparam BETWEEN_2_3 = 4'b0010;\n    localparam HIGH = 4'b0011;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LOW: next_state = s[1]? BETWEEN_1_2 : LOW;\n            BETWEEN_1_2: next_state = s[2]? BETWEEN_2_3 : (s[1]? BETWEEN_1_2 : LOW);\n            BETWEEN_2_3: next_state = s[3]? HIGH : (s[2]? BETWEEN_2_3 : BETWEEN_1_2);\n            HIGH: next_state = s[3]? HIGH : BETWEEN_2_3;\n            default: next_state = LOW;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= LOW;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            LOW: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b1;\n            end\n            BETWEEN_1_2: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b0;\n                dfr = (state < next_state)? 1'b1 : 1'b0;\n            end\n            BETWEEN_2_3: begin\n                fr1 = 1'b1;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = (state < next_state)? 1'b1 : 1'b0;\n            end\n            HIGH: begin\n                fr1 = 1'b0;\n                fr2 = 1'b0;\n                fr3 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr1 = 1'b1;\n                fr2 = 1'b1;\n                fr3 = 1'b1;\n                dfr = 1'b1;\n            end\n        endcase\n    end\n\nendmodule"]}
{"task_id": "fsm_serial", "doubao_output": ["    parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;\n    reg [2:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : (in? IDLE : START);\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'd0;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'd0;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    // Parameterize the states\n    parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;\n            STOP: next_state = in ? IDLE : IDLE; // Wait for stop bit\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter logic\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'b0;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'b0;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    // Define states\n    parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;\n            STOP: next_state = in ? IDLE : (in ? IDLE : START);\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter logic\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'b000;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'b000;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    // Define states\n    parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : (in == 1'b0)? START : STOP;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter logic\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'b000;\n        end\n        else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end\n        else begin\n            bit_count <= 3'b000;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    // Define states\n    parameter IDLE = 0, START = 1, DATA = 2, STOP = 3, WAIT_FOR_STOP = 4;\n    reg [2:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : WAIT_FOR_STOP;\n            WAIT_FOR_STOP: next_state = in? IDLE : WAIT_FOR_STOP;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 3'd0;\n        end else begin\n            state <= next_state;\n            if (state == DATA) begin\n                bit_count <= bit_count + 1;\n            end else if (state != DATA) begin\n                bit_count <= 3'd0;\n            end\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;\n    reg [2:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'd0;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'd0;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    // Define states\n    parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'b000;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'b000;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    // Define states\n    parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter logic\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'd0;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'd0;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;\n            STOP: next_state = in ? IDLE : (in == 1'b0) ? START : STOP;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'b0;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'b0;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule", "    // Define states\n    parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Bit counter logic\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'b000;\n        end else if (state == DATA) begin\n            bit_count <= bit_count + 1;\n        end else begin\n            bit_count <= 3'b000;\n        end\n    end\n\n    // Output logic\n    assign done = (state == STOP) && in;\n\nendmodule"]}
{"task_id": "fsm_serialdata", "doubao_output": ["    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT1 = 4'd2, BIT2 = 4'd3, BIT3 = 4'd4, BIT4 = 4'd5, BIT5 = 4'd6, BIT6 = 4'd7, BIT7 = 4'd8, BIT8 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = BIT8;\n            BIT8: next_state = in? STOP : START;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data capture logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT1: data[0] <= in;\n                BIT2: data[1] <= in;\n                BIT3: data[2] <= in;\n                BIT4: data[3] <= in;\n                BIT5: data[4] <= in;\n                BIT6: data[5] <= in;\n                BIT7: data[6] <= in;\n                BIT8: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP);\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT0 = 4'd2, BIT1 = 4'd3, BIT2 = 4'd4, BIT3 = 4'd5, BIT4 = 4'd6, BIT5 = 4'd7, BIT6 = 4'd8, BIT7 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = BIT0;\n            BIT0: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = STOP;\n            STOP: next_state = in ? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data capture logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT0: data[0] <= in;\n                BIT1: data[1] <= in;\n                BIT2: data[2] <= in;\n                BIT3: data[3] <= in;\n                BIT4: data[4] <= in;\n                BIT5: data[5] <= in;\n                BIT6: data[6] <= in;\n                BIT7: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP) && in;\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT0 = 4'd2, BIT1 = 4'd3, BIT2 = 4'd4, BIT3 = 4'd5, BIT4 = 4'd6, BIT5 = 4'd7, BIT6 = 4'd8, BIT7 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = BIT0;\n            BIT0: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = STOP;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data capture logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT0: data[0] <= in;\n                BIT1: data[1] <= in;\n                BIT2: data[2] <= in;\n                BIT3: data[3] <= in;\n                BIT4: data[4] <= in;\n                BIT5: data[5] <= in;\n                BIT6: data[6] <= in;\n                BIT7: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP) && in;\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT1 = 4'd2, BIT2 = 4'd3, BIT3 = 4'd4, BIT4 = 4'd5, BIT5 = 4'd6, BIT6 = 4'd7, BIT7 = 4'd8, BIT8 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = BIT8;\n            BIT8: next_state = in ? STOP : START;\n            STOP: next_state = in ? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data capture logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT1: data[0] <= in;\n                BIT2: data[1] <= in;\n                BIT3: data[2] <= in;\n                BIT4: data[3] <= in;\n                BIT5: data[4] <= in;\n                BIT6: data[5] <= in;\n                BIT7: data[6] <= in;\n                BIT8: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP);\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT0 = 4'd2, BIT1 = 4'd3, BIT2 = 4'd4, BIT3 = 4'd5, BIT4 = 4'd6, BIT5 = 4'd7, BIT6 = 4'd8, BIT7 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = BIT0;\n            BIT0: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = in? STOP : START;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data storage logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT0: data[0] <= in;\n                BIT1: data[1] <= in;\n                BIT2: data[2] <= in;\n                BIT3: data[3] <= in;\n                BIT4: data[4] <= in;\n                BIT5: data[5] <= in;\n                BIT6: data[6] <= in;\n                BIT7: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP);\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT1 = 4'd2, BIT2 = 4'd3, BIT3 = 4'd4, BIT4 = 4'd5, BIT5 = 4'd6, BIT6 = 4'd7, BIT7 = 4'd8, BIT8 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = BIT8;\n            BIT8: next_state = in ? STOP : START;\n            STOP: next_state = in ? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data capture logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT1: data[0] <= in;\n                BIT2: data[1] <= in;\n                BIT3: data[2] <= in;\n                BIT4: data[3] <= in;\n                BIT5: data[4] <= in;\n                BIT6: data[5] <= in;\n                BIT7: data[6] <= in;\n                BIT8: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP);\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] shift_reg;\n    reg [2:0] bit_count;\n\n    // State definitions\n    localparam IDLE = 4'd0, START = 4'd1, DATA = 4'd2, STOP = 4'd3;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7)? STOP : DATA;\n            STOP: next_state = in? IDLE : STOP;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data shift and bit counting\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'd0;\n            bit_count <= 3'd0;\n        end else if (state == DATA) begin\n            shift_reg <= {in, shift_reg[7:1]};\n            bit_count <= bit_count + 1;\n        end else if (state == IDLE || state == START) begin\n            bit_count <= 3'd0;\n        end\n    end\n\n    // Output logic\n    assign out_byte = shift_reg;\n    assign done = (state == STOP && in);\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT0 = 4'd2, BIT1 = 4'd3, BIT2 = 4'd4, BIT3 = 4'd5, BIT4 = 4'd6, BIT5 = 4'd7, BIT6 = 4'd8, BIT7 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in? IDLE : START;\n            START: next_state = BIT0;\n            BIT0: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = in? STOP : START;\n            STOP: next_state = in? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data capture logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT0: data[0] <= in;\n                BIT1: data[1] <= in;\n                BIT2: data[2] <= in;\n                BIT3: data[3] <= in;\n                BIT4: data[4] <= in;\n                BIT5: data[5] <= in;\n                BIT6: data[6] <= in;\n                BIT7: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP);\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] data;\n    parameter IDLE = 4'd0, START = 4'd1, BIT0 = 4'd2, BIT1 = 4'd3, BIT2 = 4'd4, BIT3 = 4'd5, BIT4 = 4'd6, BIT5 = 4'd7, BIT6 = 4'd8, BIT7 = 4'd9, STOP = 4'd10;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = BIT0;\n            BIT0: next_state = BIT1;\n            BIT1: next_state = BIT2;\n            BIT2: next_state = BIT3;\n            BIT3: next_state = BIT4;\n            BIT4: next_state = BIT5;\n            BIT5: next_state = BIT6;\n            BIT6: next_state = BIT7;\n            BIT7: next_state = STOP;\n            STOP: next_state = in ? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data capture logic\n    always @(posedge clk) begin\n        if (reset) begin\n            data <= 8'b0;\n        end else begin\n            case (state)\n                BIT0: data[0] <= in;\n                BIT1: data[1] <= in;\n                BIT2: data[2] <= in;\n                BIT3: data[3] <= in;\n                BIT4: data[4] <= in;\n                BIT5: data[5] <= in;\n                BIT6: data[6] <= in;\n                BIT7: data[7] <= in;\n                default: data <= data;\n            endcase\n        end\n    end\n\n    // Output logic\n    assign out_byte = data;\n    assign done = (state == STOP) && in;\n\nendmodule", "    reg [3:0] state, next_state;\n    reg [7:0] shift_reg;\n    reg [2:0] bit_count;\n\n    // State definitions\n    localparam IDLE = 4'd0,\n               START = 4'd1,\n               DATA = 4'd2,\n               STOP = 4'd3;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? IDLE : START;\n            START: next_state = DATA;\n            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;\n            STOP: next_state = in ? IDLE : START;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Data shift and bit counting\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'd0;\n            bit_count <= 3'd0;\n        end else if (state == DATA) begin\n            shift_reg <= {in, shift_reg[7:1]};\n            bit_count <= bit_count + 1;\n        end else if (state != DATA) begin\n            bit_count <= 3'd0;\n        end\n    end\n\n    // Output logic\n    assign out_byte = shift_reg;\n    assign done = (state == STOP) && in;\n\nendmodule"]}
{"task_id": "gshare", "doubao_output": ["    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n\n    // Prediction logic\n    wire [6:0] predict_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    wire [6:0] train_index;\n    assign train_index = train_pc ^ train_history;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_mispredicted) begin\n                    global_history <= train_history;\n                end\n                case (pht[train_index])\n                    2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n            end\n            if (predict_valid && (!train_valid ||!train_mispredicted)) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n    // Pattern history table (PHT)\n    reg [1:0] pht [127:0];\n\n    // Generate index for PHT\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n\n    // Pattern History Table (PHT)\n    reg [1:0] pht [127:0];\n\n    // Hash function\n    wire [6:0] predict_index;\n    assign predict_index = predict_pc ^ global_history;\n\n    wire [6:0] train_index;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (integer i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n\n    // Pattern History Table (PHT)\n    reg [1:0] pht [127:0];\n\n    // Hash function\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n\n    // Pattern History Table (PHT)\n    reg [1:0] pht [127:0];\n\n    // Calculate index for PHT\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n    end\n\nendmodule", "    reg [1:0] pht [127:0];\n    reg [6:0] global_history;\n\n    // Prediction logic\n    wire [6:0] predict_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    wire [6:0] train_index;\n    assign train_index = train_pc ^ train_history;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                case (pht[train_index])\n                    2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n                endcase\n                if (train_mispredicted) begin\n                    global_history <= train_history;\n                end\n            end\n            if (predict_valid &&!train_mispredicted) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n    // Pattern history table (PHT)\n    reg [1:0] pht [127:0];\n\n    // Generate index for PHT\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n\n    // Pattern History Table (PHT)\n    reg [1:0] pht [127:0];\n\n    // Generate index for PHT\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n    // Pattern history table\n    reg [1:0] pht [127:0];\n\n    // Generate the index for the PHT\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Predict the branch direction\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (integer i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                if (train_mispredicted) begin\n                    global_history <= train_history;\n                end\n                if (train_taken) begin\n                    if (pht[train_index] != 2'b11) begin\n                        pht[train_index] <= pht[train_index] + 1;\n                    end\n                end else begin\n                    if (pht[train_index] != 2'b00) begin\n                        pht[train_index] <= pht[train_index] - 1;\n                    end\n                end\n            end\n            if (predict_valid && !train_valid) begin\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule", "    // Global branch history register\n    reg [6:0] global_history;\n\n    // Pattern History Table (PHT)\n    reg [1:0] pht [127:0];\n\n    // Generate the index for PHT\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\n\n    assign predict_taken = pht[predict_index][1];\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n    end\n\nendmodule"]}
{"task_id": "lemmings4", "doubao_output": ["    // Define states\n    parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_LEFT = 2'd2, FALL_RIGHT = 2'd3, DIG_LEFT = 2'd4, DIG_RIGHT = 2'd5, SPLAT = 2'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        case (state)\n            LEFT: walk_left = 1'b1;\n            RIGHT: walk_right = 1'b1;\n            FALL_LEFT, FALL_RIGHT: aaah = 1'b1;\n            DIG_LEFT, DIG_RIGHT: digging = 1'b1;\n            SPLAT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n                digging = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_LEFT = 2'd2, FALL_RIGHT = 2'd3, DIG_LEFT = 2'd4, DIG_RIGHT = 2'd5, SPLAT = 2'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT || state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5, SPLAT = 6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT || state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_LEFT = 2'd2, FALL_RIGHT = 2'd3, DIG_LEFT = 2'd4, DIG_RIGHT = 2'd5, SPLAT = 2'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        case (state)\n            LEFT: walk_left = 1'b1;\n            RIGHT: walk_right = 1'b1;\n            FALL_LEFT: aaah = 1'b1;\n            FALL_RIGHT: aaah = 1'b1;\n            DIG_LEFT: digging = 1'b1;\n            DIG_RIGHT: digging = 1'b1;\n            SPLAT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n                digging = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_LEFT = 2'd2, FALL_RIGHT = 2'd3, DIG_LEFT = 2'd4, DIG_RIGHT = 2'd5, SPLAT = 2'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        case (state)\n            LEFT: walk_left = 1'b1;\n            RIGHT: walk_right = 1'b1;\n            FALL_LEFT: aaah = 1'b1;\n            FALL_RIGHT: aaah = 1'b1;\n            DIG_LEFT: digging = 1'b1;\n            DIG_RIGHT: digging = 1'b1;\n            SPLAT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n                digging = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    localparam LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5, SPLAT = 6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT || state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    localparam LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5, SPLAT = 6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT || state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_LEFT = 2'd2, FALL_RIGHT = 2'd3, DIG_LEFT = 2'd4, DIG_RIGHT = 2'd5, SPLAT = 2'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        case (state)\n            LEFT: walk_left = 1'b1;\n            RIGHT: walk_right = 1'b1;\n            FALL_LEFT: aaah = 1'b1;\n            FALL_RIGHT: aaah = 1'b1;\n            DIG_LEFT: digging = 1'b1;\n            DIG_RIGHT: digging = 1'b1;\n            SPLAT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n                digging = 1'b0;\n            end\n        endcase\n    end\n\nendmodule", "    // Define states\n    parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_LEFT = 2'd2, FALL_RIGHT = 2'd3, DIG_LEFT = 2'd4, DIG_RIGHT = 2'd5, SPLAT = 2'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT || state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_LEFT = 2'd2, FALL_RIGHT = 2'd3, DIG_LEFT = 2'd4, DIG_RIGHT = 2'd5, SPLAT = 2'd6;\n    reg [2:0] state, next_state;\n    reg [4:0] fall_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = LEFT;\n                end\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) begin\n                    if (fall_count > 5'd20) next_state = SPLAT;\n                    else next_state = RIGHT;\n                end\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            SPLAT: next_state = SPLAT;\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= LEFT;\n            fall_count <= 5'd0;\n        end\n        else begin\n            state <= next_state;\n            if (state == FALL_LEFT || state == FALL_RIGHT) begin\n                fall_count <= fall_count + 1;\n            end\n            else begin\n                fall_count <= 5'd0;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        case (state)\n            LEFT: walk_left = 1'b1;\n            RIGHT: walk_right = 1'b1;\n            FALL_LEFT: aaah = 1'b1;\n            FALL_RIGHT: aaah = 1'b1;\n            DIG_LEFT: digging = 1'b1;\n            DIG_RIGHT: digging = 1'b1;\n            SPLAT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b0;\n                aaah = 1'b0;\n                digging = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"]}
{"task_id": "review2015_fsm", "doubao_output": ["parameter SEARCH = 0, SHIFT = 1, COUNT = 2, TIMEOUT = 3;\nreg [1:0] state, next_state;\n\nalways @(*) begin\n    case (state)\n        SEARCH: begin\n            if (data == 1'b1) begin\n                next_state = (shift_ena == 1'b0)? SEARCH : SHIFT;\n            end else begin\n                next_state = SEARCH;\n            end\n        end\n        SHIFT: begin\n            if (shift_ena == 1'b1) begin\n                next_state = (shift_ena == 4'b0000)? COUNT : SHIFT;\n            end else begin\n                next_state = SHIFT;\n            end\n        end\n        COUNT: begin\n            if (done_counting == 1'b1) begin\n                next_state = TIMEOUT;\n            end else begin\n                next_state = COUNT;\n            end\n        end\n        TIMEOUT: begin\n            if (ack == 1'b1) begin\n                next_state = SEARCH;\n            end else begin\n                next_state = TIMEOUT;\n            end\n        end\n        default: next_state = SEARCH;\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= SEARCH;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n    case (state)\n        SEARCH: begin\n            if (data == 4'b1101) begin\n                shift_ena = 1'b1;\n            end\n        end\n        SHIFT: begin\n            shift_ena = 1'b1;\n        end\n        COUNT: begin\n            counting = 1'b1;\n        end\n        TIMEOUT: begin\n            done = 1'b1;\n        end\n    endcase\nend\n\nendmodule", "    parameter SEARCH = 0, SHIFT = 1, COUNT = 2, TIMEOUT = 3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            SEARCH: begin\n                if (reset) next_state = SEARCH;\n                else if (data == 1) next_state = 1;\n                else next_state = SEARCH;\n            end\n            1: begin\n                if (reset) next_state = SEARCH;\n                else if (data == 1) next_state = 2;\n                else next_state = SEARCH;\n            end\n            2: begin\n                if (reset) next_state = SEARCH;\n                else if (data == 0) next_state = 3;\n                else next_state = SEARCH;\n            end\n            3: begin\n                if (reset) next_state = SEARCH;\n                else if (data == 1) next_state = SHIFT;\n                else next_state = SEARCH;\n            end\n            SHIFT: begin\n                if (reset) next_state = SEARCH;\n                else if ($countones({shift_ena, counting, done}) == 4) next_state = COUNT;\n                else next_state = SHIFT;\n            end\n            COUNT: begin\n                if (reset) next_state = SEARCH;\n                else if (done_counting) next_state = TIMEOUT;\n                else next_state = COUNT;\n            end\n            TIMEOUT: begin\n                if (reset) next_state = SEARCH;\n                else if (ack) next_state = SEARCH;\n                else next_state = TIMEOUT;\n            end\n            default: next_state = SEARCH;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk) begin\n        if (reset) state <= SEARCH;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n        case (state)\n            SHIFT: shift_ena = 1;\n            COUNT: counting = 1;\n            TIMEOUT: done = 1;\n        endcase\n    end\n\nendmodule", "// Define states\nlocalparam S_SEARCH = 0, S_SHIFT = 1, S_COUNT = 2, S_DONE = 3;\nreg [1:0] state, next_state;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        S_SEARCH: begin\n            if (data == 1'b1) begin\n                next_state = S_SHIFT;\n            end else begin\n                next_state = S_SEARCH;\n            end\n        end\n        S_SHIFT: begin\n            if ($countones(shift_ena) == 4) begin\n                next_state = S_COUNT;\n            end else begin\n                next_state = S_SHIFT;\n            end\n        end\n        S_COUNT: begin\n            if (done_counting) begin\n                next_state = S_DONE;\n            end else begin\n                next_state = S_COUNT;\n            end\n        end\n        S_DONE: begin\n            if (ack) begin\n                next_state = S_SEARCH;\n            end else begin\n                next_state = S_DONE;\n            end\n        end\n        default: next_state = S_SEARCH;\n    endcase\nend\n\n// State flip-flops\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= S_SEARCH;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Output logic\nalways @(*) begin\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n    case (state)\n        S_SHIFT: shift_ena = 1'b1;\n        S_COUNT: counting = 1'b1;\n        S_DONE: done = 1'b1;\n    endcase\nend\n\nendmodule", "    // Define states\n    parameter S_SEARCH = 0, S_SHIFT = 1, S_COUNT = 2, S_DONE = 3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S_SEARCH: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b1) next_state = 1'b1;\n                else next_state = S_SEARCH;\n            end\n            1'b1: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b1) next_state = 2'b10;\n                else next_state = S_SEARCH;\n            end\n            2'b10: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b0) next_state = 2'b11;\n                else next_state = S_SEARCH;\n            end\n            2'b11: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b1) next_state = S_SHIFT;\n                else next_state = S_SEARCH;\n            end\n            S_SHIFT: begin\n                if (reset) next_state = S_SEARCH;\n                else if (shift_ena_count == 4'd3) next_state = S_COUNT;\n                else next_state = S_SHIFT;\n            end\n            S_COUNT: begin\n                if (reset) next_state = S_SEARCH;\n                else if (done_counting) next_state = S_DONE;\n                else next_state = S_COUNT;\n            end\n            S_DONE: begin\n                if (reset) next_state = S_SEARCH;\n                else if (ack) next_state = S_SEARCH;\n                else next_state = S_DONE;\n            end\n            default: next_state = S_SEARCH;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) state <= S_SEARCH;\n        else state <= next_state;\n    end\n\n    // Output logic\n    reg [3:0] shift_ena_count;\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            shift_ena_count <= 4'd0;\n        end else begin\n            case (state)\n                S_SEARCH: begin\n                    shift_ena <= 1'b0;\n                    counting <= 1'b0;\n                    done <= 1'b0;\n                    shift_ena_count <= 4'd0;\n                end\n                S_SHIFT: begin\n                    shift_ena <= 1'b1;\n                    counting <= 1'b0;\n                    done <= 1'b0;\n                    shift_ena_count <= shift_ena_count + 4'd1;\n                end\n                S_COUNT: begin\n                    shift_ena <= 1'b0;\n                    counting <= 1'b1;\n                    done <= 1'b0;\n                    shift_ena_count <= 4'd0;\n                end\n                S_DONE: begin\n                    shift_ena <= 1'b0;\n                    counting <= 1'b0;\n                    done <= 1'b1;\n                    shift_ena_count <= 4'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "parameter SEARCH = 0, SHIFT = 1, COUNT = 2, TIMEOUT = 3;\nreg [1:0] state, next_state;\n\nalways @(*) begin\n    case (state)\n        SEARCH: begin\n            if (data == 1'b1) begin\n                next_state = (data == 1'b1)? ((data == 1'b0)? ((data == 1'b1)? SHIFT : SEARCH) : SEARCH) : SEARCH;\n            end else begin\n                next_state = SEARCH;\n            end\n        end\n        SHIFT: begin\n            if ($countbits(shift_ena, 1) == 4) begin\n                next_state = COUNT;\n            end else begin\n                next_state = SHIFT;\n            end\n        end\n        COUNT: begin\n            if (done_counting) begin\n                next_state = TIMEOUT;\n            end else begin\n                next_state = COUNT;\n            end\n        end\n        TIMEOUT: begin\n            if (ack) begin\n                next_state = SEARCH;\n            end else begin\n                next_state = TIMEOUT;\n            end\n        end\n        default: next_state = SEARCH;\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= SEARCH;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n    case (state)\n        SHIFT: shift_ena = 1'b1;\n        COUNT: counting = 1'b1;\n        TIMEOUT: done = 1'b1;\n    endcase\nend\n\nendmodule", "    // Define states\n    parameter IDLE = 2'b00, SHIFT = 2'b01, COUNT = 2'b10, FINISH = 2'b11;\n    reg [1:0] state, next_state;\n    reg [1:0] shift_count;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (data == 1'b1) begin\n                    next_state = 2'b00; // Wait for the next bit\n                end else if (data == 1'b0) begin\n                    next_state = 2'b00; // Wait for the next bit\n                end\n                if (data == 4'b1101) begin\n                    next_state = SHIFT;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            SHIFT: begin\n                if (shift_count == 2'b11) begin\n                    next_state = COUNT;\n                end else begin\n                    next_state = SHIFT;\n                end\n            end\n            COUNT: begin\n                if (done_counting) begin\n                    next_state = FINISH;\n                end else begin\n                    next_state = COUNT;\n                end\n            end\n            FINISH: begin\n                if (ack) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = FINISH;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_count <= 2'b00;\n        end else begin\n            state <= next_state;\n            if (state == SHIFT) begin\n                shift_count <= shift_count + 1;\n            end else begin\n                shift_count <= 2'b00;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n        case (state)\n            SHIFT: shift_ena = 1'b1;\n            COUNT: counting = 1'b1;\n            FINISH: done = 1'b1;\n        endcase\n    end\n\nendmodule", "// Define states\nparameter S_SEARCH = 0, S_SHIFT = 1, S_COUNT = 2, S_DONE = 3;\nreg [1:0] state, next_state;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        S_SEARCH: begin\n            if (reset) next_state = S_SEARCH;\n            else if (data == 1'b1) next_state = S_SHIFT;\n            else next_state = S_SEARCH;\n        end\n        S_SHIFT: begin\n            if (reset) next_state = S_SEARCH;\n            else if ($countones(shift_ena) == 4) next_state = S_COUNT;\n            else next_state = S_SHIFT;\n        end\n        S_COUNT: begin\n            if (reset) next_state = S_SEARCH;\n            else if (done_counting) next_state = S_DONE;\n            else next_state = S_COUNT;\n        end\n        S_DONE: begin\n            if (reset) next_state = S_SEARCH;\n            else if (ack) next_state = S_SEARCH;\n            else next_state = S_DONE;\n        end\n        default: next_state = S_SEARCH;\n    endcase\nend\n\n// State flip-flops\nalways @(posedge clk) begin\n    if (reset) state <= S_SEARCH;\n    else state <= next_state;\nend\n\n// Output logic\nalways @(*) begin\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n    case (state)\n        S_SHIFT: shift_ena = 1'b1;\n        S_COUNT: counting = 1'b1;\n        S_DONE: done = 1'b1;\n    endcase\nend\n\nendmodule", "parameter IDLE = 0, DETECT_PATTERN = 1, SHIFT = 2, WAIT_COUNTING = 3, TIMEOUT = 4;\nreg [2:0] state, next_state;\nreg [1:0] shift_count;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        IDLE: next_state = reset? IDLE : DETECT_PATTERN;\n        DETECT_PATTERN: begin\n            if (reset) next_state = IDLE;\n            else if (data == 1'b1) next_state = DETECT_PATTERN;\n            else if (data == 1'b0) next_state = SHIFT;\n            else next_state = DETECT_PATTERN;\n        end\n        SHIFT: begin\n            if (reset) next_state = IDLE;\n            else if (shift_count == 2'd3) next_state = WAIT_COUNTING;\n            else next_state = SHIFT;\n        end\n        WAIT_COUNTING: begin\n            if (reset) next_state = IDLE;\n            else if (done_counting) next_state = TIMEOUT;\n            else next_state = WAIT_COUNTING;\n        end\n        TIMEOUT: begin\n            if (reset) next_state = IDLE;\n            else if (ack) next_state = DETECT_PATTERN;\n            else next_state = TIMEOUT;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// State flip-flops\nalways @(posedge clk) begin\n    if (reset) state <= IDLE;\n    else state <= next_state;\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b0;\n        counting <= 1'b0;\n        done <= 1'b0;\n        shift_count <= 2'd0;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                shift_ena <= 1'b0;\n                counting <= 1'b0;\n                done <= 1'b0;\n                shift_count <= 2'd0;\n            end\n            DETECT_PATTERN: begin\n                shift_ena <= 1'b0;\n                counting <= 1'b0;\n                done <= 1'b0;\n                shift_count <= 2'd0;\n            end\n            SHIFT: begin\n                shift_ena <= 1'b1;\n                counting <= 1'b0;\n                done <= 1'b0;\n                shift_count <= shift_count + 1;\n            end\n            WAIT_COUNTING: begin\n                shift_ena <= 1'b0;\n                counting <= 1'b1;\n                done <= 1'b0;\n                shift_count <= 2'd0;\n            end\n            TIMEOUT: begin\n                shift_ena <= 1'b0;\n                counting <= 1'b0;\n                done <= 1'b1;\n                shift_count <= 2'd0;\n            end\n            default: begin\n                shift_ena <= 1'b0;\n                counting <= 1'b0;\n                done <= 1'b0;\n                shift_count <= 2'd0;\n            end\n        endcase\n    end\nend\n\nendmodule", "// State definitions\nlocalparam S_SEARCH = 0;\nlocalparam S_SHIFT = 1;\nlocalparam S_COUNT = 2;\nlocalparam S_DONE = 3;\n\nreg [1:0] state, next_state;\nreg [1:0] shift_count;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        S_SEARCH: begin\n            if (reset) next_state = S_SEARCH;\n            else if (data == 1'b1) next_state = S_SEARCH;\n            else if (data == 1'b0) next_state = S_SHIFT;\n            else next_state = S_SEARCH;\n        end\n        S_SHIFT: begin\n            if (reset) next_state = S_SEARCH;\n            else if (shift_count == 2'd3) next_state = S_COUNT;\n            else next_state = S_SHIFT;\n        end\n        S_COUNT: begin\n            if (reset) next_state = S_SEARCH;\n            else if (done_counting) next_state = S_DONE;\n            else next_state = S_COUNT;\n        end\n        S_DONE: begin\n            if (reset) next_state = S_SEARCH;\n            else if (ack) next_state = S_SEARCH;\n            else next_state = S_DONE;\n        end\n        default: next_state = S_SEARCH;\n    endcase\nend\n\n// State register\nalways @(posedge clk) begin\n    if (reset) state <= S_SEARCH;\n    else state <= next_state;\nend\n\n// Output logic\nalways @(*) begin\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n    case (state)\n        S_SHIFT: shift_ena = 1'b1;\n        S_COUNT: counting = 1'b1;\n        S_DONE: done = 1'b1;\n    endcase\nend\n\n// Shift counter\nalways @(posedge clk) begin\n    if (reset) shift_count <= 2'd0;\n    else if (state == S_SHIFT) shift_count <= shift_count + 1;\n    else shift_count <= 2'd0;\nend\n\nendmodule", "    // Define states\n    localparam S_SEARCH = 0, S_SHIFT = 1, S_COUNT = 2, S_DONE = 3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S_SEARCH: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b1) next_state = 1'b1;\n                else next_state = S_SEARCH;\n            end\n            1'b1: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b1) next_state = 2'b10;\n                else next_state = S_SEARCH;\n            end\n            2'b10: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b0) next_state = 2'b11;\n                else next_state = S_SEARCH;\n            end\n            2'b11: begin\n                if (reset) next_state = S_SEARCH;\n                else if (data == 1'b1) next_state = S_SHIFT;\n                else next_state = S_SEARCH;\n            end\n            S_SHIFT: begin\n                if (reset) next_state = S_SEARCH;\n                else if ($countones({shift_ena, shift_ena, shift_ena, shift_ena}) == 4) next_state = S_COUNT;\n                else next_state = S_SHIFT;\n            end\n            S_COUNT: begin\n                if (reset) next_state = S_SEARCH;\n                else if (done_counting) next_state = S_DONE;\n                else next_state = S_COUNT;\n            end\n            S_DONE: begin\n                if (reset) next_state = S_SEARCH;\n                else if (ack) next_state = S_SEARCH;\n                else next_state = S_DONE;\n            end\n            default: next_state = S_SEARCH;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk) begin\n        if (reset) state <= S_SEARCH;\n        else state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n        case (state)\n            S_SHIFT: shift_ena = 1'b1;\n            S_COUNT: counting = 1'b1;\n            S_DONE: done = 1'b1;\n        endcase\n    end\n\nendmodule"]}
{"task_id": "conwaylife", "doubao_output": ["always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i*16 + (j-1+16)%16)] + q[(i*16 + (j+1)%16)] +\n                                 q[((i-1+16)*16 + j)] + q[((i+1)%16*16 + j)] +\n                                 q[((i-1+16)*16 + (j-1+16)%16)] + q[((i-1+16)*16 + (j+1)%16)] +\n                                 q[((i+1)%16*16 + (j-1+16)%16)] + q[((i+1)%16*16 + (j+1)%16)];\n                case (neighbor_count)\n                    0, 1, 4, 5, 6, 7, 8: next_q[i*16 + j] = 1'b0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i == 0 ? 15 : i - 1) * 16 + (j == 0 ? 15 : j - 1)] +\n                                 q[(i == 0 ? 15 : i - 1) * 16 + j] +\n                                 q[(i == 0 ? 15 : i - 1) * 16 + (j == 15 ? 0 : j + 1)] +\n                                 q[i * 16 + (j == 0 ? 15 : j - 1)] +\n                                 q[i * 16 + (j == 15 ? 0 : j + 1)] +\n                                 q[(i == 15 ? 0 : i + 1) * 16 + (j == 0 ? 15 : j - 1)] +\n                                 q[(i == 15 ? 0 : i + 1) * 16 + j] +\n                                 q[(i == 15 ? 0 : i + 1) * 16 + (j == 15 ? 0 : j + 1)];\n                case (neighbor_count)\n                    0, 1, 4, 5, 6, 7, 8: next_q[i * 16 + j] = 1'b0;\n                    2: next_q[i * 16 + j] = q[i * 16 + j];\n                    3: next_q[i * 16 + j] = 1'b1;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i*16 + (j+1)%16)] + q[(i*16 + (j-1+16)%16)] +\n                                 q[((i+1)%16)*16 + j] + q[((i-1+16)%16)*16 + j] +\n                                 q[((i+1)%16)*16 + (j+1)%16] + q[((i+1)%16)*16 + (j-1+16)%16] +\n                                 q[((i-1+16)%16)*16 + (j+1)%16] + q[((i-1+16)%16)*16 + (j-1+16)%16];\n                case (neighbor_count)\n                    0, 1, 4, 5, 6, 7, 8: next_q[i*16 + j] = 1'b0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i*16 + (j+1)%16)] + q[(i*16 + (j-1+16)%16)] +\n                                 q[((i+1)%16)*16 + j] + q[((i-1+16)%16)*16 + j] +\n                                 q[((i+1)%16)*16 + (j+1)%16] + q[((i+1)%16)*16 + (j-1+16)%16] +\n                                 q[((i-1+16)%16)*16 + (j+1)%16] + q[((i-1+16)%16)*16 + (j-1+16)%16];\n                case (neighbor_count)\n                    0, 1: next_q[i*16 + j] = 1'b0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                    default: next_q[i*16 + j] = 1'b0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "reg [255:0] next_q;\n\nalways @(*) begin\n    for (integer i = 0; i < 256; i = i + 1) begin\n        integer row = i / 16;\n        integer col = i % 16;\n        integer neighbor_count = 0;\n\n        // Calculate the number of neighbors\n        neighbor_count = neighbor_count + q[((row - 1 + 16) % 16) * 16 + ((col - 1 + 16) % 16)];\n        neighbor_count = neighbor_count + q[((row - 1 + 16) % 16) * 16 + col];\n        neighbor_count = neighbor_count + q[((row - 1 + 16) % 16) * 16 + ((col + 1) % 16)];\n        neighbor_count = neighbor_count + q[row * 16 + ((col - 1 + 16) % 16)];\n        neighbor_count = neighbor_count + q[row * 16 + ((col + 1) % 16)];\n        neighbor_count = neighbor_count + q[((row + 1) % 16) * 16 + ((col - 1 + 16) % 16)];\n        neighbor_count = neighbor_count + q[((row + 1) % 16) * 16 + col];\n        neighbor_count = neighbor_count + q[((row + 1) % 16) * 16 + ((col + 1) % 16)];\n\n        case (neighbor_count)\n            0, 1, 4, 5, 6, 7, 8: next_q[i] = 1'b0;\n            2: next_q[i] = q[i];\n            3: next_q[i] = 1'b1;\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= next_q;\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i*16 + (j+1)%16)] + q[(i*16 + (j-1+16)%16)] +\n                                 q[((i+1)%16)*16 + j] + q[((i-1+16)%16)*16 + j] +\n                                 q[((i+1)%16)*16 + (j+1)%16] + q[((i+1)%16)*16 + (j-1+16)%16] +\n                                 q[((i-1+16)%16)*16 + (j+1)%16] + q[((i-1+16)%16)*16 + (j-1+16)%16];\n                case (neighbor_count)\n                    0, 1, 4, 5, 6, 7, 8: next_q[i*16 + j] = 1'b0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i * 16 + (j + 1) % 16)] +\n                                 q[(i * 16 + (j - 1 + 16) % 16)] +\n                                 q[((i + 1) % 16 * 16 + j)] +\n                                 q[((i - 1 + 16) % 16 * 16 + j)] +\n                                 q[((i + 1) % 16 * 16 + (j + 1) % 16)] +\n                                 q[((i + 1) % 16 * 16 + (j - 1 + 16) % 16)] +\n                                 q[((i - 1 + 16) % 16 * 16 + (j + 1) % 16)] +\n                                 q[((i - 1 + 16) % 16 * 16 + (j - 1 + 16) % 16)];\n                case (neighbor_count)\n                    0, 1: next_q[i * 16 + j] = 1'b0;\n                    2: next_q[i * 16 + j] = q[i * 16 + j];\n                    3: next_q[i * 16 + j] = 1'b1;\n                    default: next_q[i * 16 + j] = 1'b0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i*16 + (j-1+16)%16)] + q[(i*16 + (j+1)%16)] +\n                                 q[((i-1+16)%16*16 + j)] + q[((i-1+16)%16*16 + (j-1+16)%16)] +\n                                 q[((i-1+16)%16*16 + (j+1)%16)] + q[((i+1)%16*16 + j)] +\n                                 q[((i+1)%16*16 + (j-1+16)%16)] + q[((i+1)%16*16 + (j+1)%16)];\n                case (neighbor_count)\n                    0, 1, 4, 5, 6, 7, 8: next_q[i*16 + j] = 1'b0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [255:0] next_q;\n        integer i, j;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                integer neighbor_count;\n                neighbor_count = q[(i*16 + (j-1+16)%16)] + q[(i*16 + (j+1)%16)] + \n                                 q[((i-1+16)%16*16 + j)] + q[((i+1)%16*16 + j)] + \n                                 q[((i-1+16)%16*16 + (j-1+16)%16)] + q[((i-1+16)%16*16 + (j+1)%16)] + \n                                 q[((i+1)%16*16 + (j-1+16)%16)] + q[((i+1)%16*16 + (j+1)%16)];\n                case (neighbor_count)\n                    0, 1, 4, 5, 6, 7, 8: next_q[i*16 + j] = 1'b0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1'b1;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\nendmodule", "reg [255:0] next_q;\n\nalways @(*) begin\n    for (integer i = 0; i < 256; i = i + 1) begin\n        integer row = i / 16;\n        integer col = i % 16;\n        integer neighbor_count = 0;\n\n        // Calculate the number of neighbors\n        neighbor_count = q[((row - 1 + 16) % 16) * 16 + ((col - 1 + 16) % 16)] +\n                         q[((row - 1 + 16) % 16) * 16 + col] +\n                         q[((row - 1 + 16) % 16) * 16 + ((col + 1) % 16)] +\n                         q[row * 16 + ((col - 1 + 16) % 16)] +\n                         q[row * 16 + ((col + 1) % 16)] +\n                         q[((row + 1) % 16) * 16 + ((col - 1 + 16) % 16)] +\n                         q[((row + 1) % 16) * 16 + col] +\n                         q[((row + 1) % 16) * 16 + ((col + 1) % 16)];\n\n        case (neighbor_count)\n            0, 1, 4, 5, 6, 7, 8: next_q[i] = 1'b0;\n            2: next_q[i] = q[i];\n            3: next_q[i] = 1'b1;\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= next_q;\n    end\nend\n\nendmodule"]}
{"task_id": "lemmings3", "doubao_output": ["    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    localparam LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter WL = 2'b00, WR = 2'b01, FALL_WL = 2'b10, FALL_WR = 2'b11, DIG_WL = 2'b100, DIG_WR = 2'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            WL: begin\n                if (!ground) next_state = FALL_WL;\n                else if (dig) next_state = DIG_WL;\n                else if (bump_left) next_state = WR;\n                else next_state = WL;\n            end\n            WR: begin\n                if (!ground) next_state = FALL_WR;\n                else if (dig) next_state = DIG_WR;\n                else if (bump_right) next_state = WL;\n                else next_state = WR;\n            end\n            FALL_WL: begin\n                if (ground) next_state = WL;\n                else next_state = FALL_WL;\n            end\n            FALL_WR: begin\n                if (ground) next_state = WR;\n                else next_state = FALL_WR;\n            end\n            DIG_WL: begin\n                if (!ground) next_state = FALL_WL;\n                else next_state = DIG_WL;\n            end\n            DIG_WR: begin\n                if (!ground) next_state = FALL_WR;\n                else next_state = DIG_WR;\n            end\n            default: next_state = WL;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= WL;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == WL);\n    assign walk_right = (state == WR);\n    assign aaah = (state == FALL_WL) || (state == FALL_WR);\n    assign digging = (state == DIG_WL) || (state == DIG_WR);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 0, RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, DIG_LEFT = 4, DIG_RIGHT = 5;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State update\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule"]}
{"task_id": "count_clock", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        pm <= 1'b0;\n        hh <= 8'b0001_0010;\n        mm <= 8'b0000_0000;\n        ss <= 8'b0000_0000;\n    end\n    else if (ena) begin\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'b0000_0000;\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'b0000_0000;\n                        if (hh[3:0] == 4'd9) begin\n                            if (hh[7:4] == 4'd1) begin\n                                if (hh == 8'b0001_0011) begin\n                                    hh <= 8'b0001_0000;\n                                    pm <= ~pm;\n                                end\n                                else if (hh == 8'b0001_0012) begin\n                                    hh <= 8'b0001_0001;\n                                end\n                            end\n                        end\n                        else begin\n                            hh[3:0] <= hh[3:0] + 1;\n                        end\n                    end\n                    else begin\n                        mm[7:4] <= mm[7:4] + 1;\n                        mm[3:0] <= 4'd0;\n                    end\n                end\n                else begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end\n            end\n            else begin\n                ss[7:4] <= ss[7:4] + 1;\n                ss[3:0] <= 4'd0;\n            end\n        end\n        else begin\n            ss[3:0] <= ss[3:0] + 1;\n        end\n    end\nend\nendmodule", "    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 1'b0;\n            hh <= 8'b0001_0010;\n            mm <= 8'b0000_0000;\n            ss <= 8'b0000_0000;\n        end\n        else if (ena) begin\n            if (ss[3:0] == 4'd9) begin\n                if (ss[7:4] == 4'd5) begin\n                    ss <= 8'b0000_0000;\n                    if (mm[3:0] == 4'd9) begin\n                        if (mm[7:4] == 4'd5) begin\n                            mm <= 8'b0000_0000;\n                            if (hh[3:0] == 4'd9) begin\n                                if (hh[7:4] == 4'd1) begin\n                                    if (hh == 8'b0001_0011) begin\n                                        hh <= 8'b0001_0000;\n                                        pm <= ~pm;\n                                    end\n                                    else begin\n                                        hh <= 8'b0000_0001;\n                                    end\n                                end\n                            end\n                            else begin\n                                hh[3:0] <= hh[3:0] + 1;\n                            end\n                        end\n                        else begin\n                            mm[7:4] <= mm[7:4] + 1;\n                            mm[3:0] <= 4'd0;\n                        end\n                    end\n                    else begin\n                        mm[3:0] <= mm[3:0] + 1;\n                    end\n                end\n                else begin\n                    ss[7:4] <= ss[7:4] + 1;\n                    ss[3:0] <= 4'd0;\n                end\n            end\n            else begin\n                ss[3:0] <= ss[3:0] + 1;\n            end\n        end\n    end\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        pm <= 1'b0;\n        hh <= 8'b0001_0010;\n        mm <= 8'b0000_0000;\n        ss <= 8'b0000_0000;\n    end else if (ena) begin\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'b0000_0000;\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'b0000_0000;\n                        if (hh[3:0] == 4'd9) begin\n                            if (hh[7:4] == 4'd1) begin\n                                if (hh == 8'b0001_0012) begin\n                                    hh <= 8'b0001_0001;\n                                    pm <= ~pm;\n                                end else begin\n                                    hh <= 8'b0000_0000;\n                                end\n                            end else begin\n                                hh[7:4] <= hh[7:4] + 1;\n                                hh[3:0] <= 4'd0;\n                            end\n                        end else begin\n                            hh[3:0] <= hh[3:0] + 1;\n                        end\n                    end else begin\n                        mm[7:4] <= mm[7:4] + 1;\n                        mm[3:0] <= 4'd0;\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end\n            end else begin\n                ss[7:4] <= ss[7:4] + 1;\n                ss[3:0] <= 4'd0;\n            end\n        end else begin\n            ss[3:0] <= ss[3:0] + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        pm <= 1'b0;\n        hh <= 8'b0001_0010;\n        mm <= 8'b0000_0000;\n        ss <= 8'b0000_0000;\n    end else if (ena) begin\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'b0000_0000;\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'b0000_0000;\n                        if (hh[3:0] == 4'd9) begin\n                            if (hh[7:4] == 4'd1) begin\n                                if (hh == 8'b0001_0012) begin\n                                    hh <= 8'b0001_0001;\n                                    pm <= ~pm;\n                                end else begin\n                                    hh <= 8'b0000_0000;\n                                end\n                            end else begin\n                                hh[7:4] <= hh[7:4] + 1;\n                                hh[3:0] <= 4'd0;\n                            end\n                        end else begin\n                            hh[3:0] <= hh[3:0] + 1;\n                        end\n                    end else begin\n                        mm[7:4] <= mm[7:4] + 1;\n                        mm[3:0] <= 4'd0;\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end\n            end else begin\n                ss[7:4] <= ss[7:4] + 1;\n                ss[3:0] <= 4'd0;\n            end\n        end else begin\n            ss[3:0] <= ss[3:0] + 1;\n        end\n    end\nend\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        pm <= 1'b0;\n        hh <= 8'b0001_0010;\n        mm <= 8'b0000_0000;\n        ss <= 8'b0000_0000;\n    end\n    else if (ena) begin\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'b0000_0000;\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'b0000_0000;\n                        if (hh[3:0] == 4'd9) begin\n                            if (hh[7:4] == 4'd1) begin\n                                if (hh == 8'b0001_0011) begin\n                                    hh <= 8'b0001_0000;\n                                    pm <= ~pm;\n                                end\n                                else begin\n                                    hh <= 8'b0001_0000;\n                                end\n                            end\n                            else begin\n                                hh <= 8'b0001_0000;\n                            end\n                        end\n                        else if (hh == 8'b0001_0010) begin\n                            hh <= 8'b0001_0001;\n                            pm <= ~pm;\n                        end\n                        else begin\n                            hh[3:0] <= hh[3:0] + 1;\n                        end\n                    end\n                    else begin\n                        mm[7:4] <= mm[7:4] + 1;\n                        mm[3:0] <= 4'd0;\n                    end\n                end\n                else begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end\n            end\n            else begin\n                ss[7:4] <= ss[7:4] + 1;\n                ss[3:0] <= 4'd0;\n            end\n        end\n        else begin\n            ss[3:0] <= ss[3:0] + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        pm <= 1'b0;\n        hh <= 8'b0001_0010;\n        mm <= 8'b0000_0000;\n        ss <= 8'b0000_0000;\n    end else if (ena) begin\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'b0000_0000;\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'b0000_0000;\n                        if (hh[3:0] == 4'd9) begin\n                            if (hh[7:4] == 4'd1) begin\n                                if (hh == 8'b0001_0012) begin\n                                    hh <= 8'b0001_0001;\n                                    pm <= ~pm;\n                                end else begin\n                                    hh <= 8'b0000_0000;\n                                end\n                            end\n                        end else begin\n                            hh[3:0] <= hh[3:0] + 1;\n                        end\n                    end else begin\n                        mm[7:4] <= mm[7:4] + 1;\n                        mm[3:0] <= 4'd0;\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end\n            end else begin\n                ss[7:4] <= ss[7:4] + 1;\n                ss[3:0] <= 4'd0;\n            end\n        end else begin\n            ss[3:0] <= ss[3:0] + 1;\n        end\n    end\nend\nendmodule", "    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 1'b0;\n            hh <= 8'b0001_0010;\n            mm <= 8'b0000_0000;\n            ss <= 8'b0000_0000;\n        end\n        else if (ena) begin\n            if (ss[3:0] == 4'd9) begin\n                if (ss[7:4] == 4'd5) begin\n                    ss <= 8'b0000_0000;\n                    if (mm[3:0] == 4'd9) begin\n                        if (mm[7:4] == 4'd5) begin\n                            mm <= 8'b0000_0000;\n                            if (hh[3:0] == 4'd9) begin\n                                if (hh[7:4] == 4'd1) begin\n                                    if (hh == 8'b0001_0011) begin\n                                        hh <= 8'b0001_0000;\n                                        pm <= ~pm;\n                                    end\n                                    else begin\n                                        hh <= 8'b0001_0000;\n                                    end\n                                end\n                                else begin\n                                    hh <= {hh[7:4]+1, 4'd0};\n                                end\n                            end\n                            else begin\n                                hh <= {hh[7:4], hh[3:0]+1};\n                            end\n                        end\n                        else begin\n                            mm <= {mm[7:4]+1, 4'd0};\n                        end\n                    end\n                    else begin\n                        mm <= {mm[7:4], mm[3:0]+1};\n                    end\n                end\n                else begin\n                    ss <= {ss[7:4]+1, 4'd0};\n                end\n            end\n            else begin\n                ss <= {ss[7:4], ss[3:0]+1};\n            end\n        end\n    end\nendmodule", "    always @(posedge clk) begin\n        if (reset) begin\n            pm <= 1'b0;\n            hh <= 8'b0001_0010;\n            mm <= 8'b0000_0000;\n            ss <= 8'b0000_0000;\n        end\n        else if (ena) begin\n            if (ss[3:0] == 4'd9) begin\n                if (ss[7:4] == 4'd5) begin\n                    ss <= 8'b0000_0000;\n                    if (mm[3:0] == 4'd9) begin\n                        if (mm[7:4] == 4'd5) begin\n                            mm <= 8'b0000_0000;\n                            if (hh[3:0] == 4'd9) begin\n                                if (hh[7:4] == 4'd1) begin\n                                    if (hh == 8'b0001_0012) begin\n                                        hh <= 8'b0001_0001;\n                                        pm <= ~pm;\n                                    end\n                                    else begin\n                                        hh <= 8'b0000_0000;\n                                    end\n                                end\n                                else begin\n                                    hh[7:4] <= hh[7:4] + 1;\n                                    hh[3:0] <= 4'd0;\n                                end\n                            end\n                            else begin\n                                hh[3:0] <= hh[3:0] + 1;\n                            end\n                        end\n                        else begin\n                            mm[7:4] <= mm[7:4] + 1;\n                            mm[3:0] <= 4'd0;\n                        end\n                    end\n                    else begin\n                        mm[3:0] <= mm[3:0] + 1;\n                    end\n                end\n                else begin\n                    ss[7:4] <= ss[7:4] + 1;\n                    ss[3:0] <= 4'd0;\n                end\n            end\n            else begin\n                ss[3:0] <= ss[3:0] + 1;\n            end\n        end\n    end\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        pm <= 1'b0;\n        hh <= 8'b0001_0010;\n        mm <= 8'b0000_0000;\n        ss <= 8'b0000_0000;\n    end\n    else if (ena) begin\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'b0000_0000;\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'b0000_0000;\n                        if (hh[3:0] == 4'd9) begin\n                            if (hh[7:4] == 4'd1) begin\n                                if (hh == 8'b0001_0012) begin\n                                    hh <= 8'b0001_0001;\n                                    pm <= ~pm;\n                                end\n                                else begin\n                                    hh <= 8'b0000_0000;\n                                end\n                            end\n                            else begin\n                                hh[7:4] <= hh[7:4] + 1;\n                                hh[3:0] <= 4'd0;\n                            end\n                        end\n                        else begin\n                            hh[3:0] <= hh[3:0] + 1;\n                        end\n                    end\n                    else begin\n                        mm[7:4] <= mm[7:4] + 1;\n                        mm[3:0] <= 4'd0;\n                    end\n                end\n                else begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end\n            end\n            else begin\n                ss[7:4] <= ss[7:4] + 1;\n                ss[3:0] <= 4'd0;\n            end\n        end\n        else begin\n            ss[3:0] <= ss[3:0] + 1;\n        end\n    end\nend\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        pm <= 1'b0;\n        hh <= 8'b0001_0010;\n        mm <= 8'b0000_0000;\n        ss <= 8'b0000_0000;\n    end\n    else if (ena) begin\n        if (ss[3:0] == 4'd9) begin\n            if (ss[7:4] == 4'd5) begin\n                ss <= 8'b0000_0000;\n                if (mm[3:0] == 4'd9) begin\n                    if (mm[7:4] == 4'd5) begin\n                        mm <= 8'b0000_0000;\n                        if (hh[3:0] == 4'd9) begin\n                            if (hh[7:4] == 4'd1) begin\n                                if (hh == 8'b0001_0011) begin\n                                    hh <= 8'b0001_0000;\n                                    pm <= ~pm;\n                                end\n                                else begin\n                                    hh <= 8'b0001_0000;\n                                end\n                            end\n                            else begin\n                                hh <= 8'b0001_0000;\n                            end\n                        end\n                        else if (hh == 8'b0001_0001) begin\n                            hh <= 8'b0001_0010;\n                        end\n                        else begin\n                            hh[3:0] <= hh[3:0] + 1;\n                        end\n                    end\n                    else begin\n                        mm[7:4] <= mm[7:4] + 1;\n                        mm[3:0] <= 4'd0;\n                    end\n                end\n                else begin\n                    mm[3:0] <= mm[3:0] + 1;\n                end\n            end\n            else begin\n                ss[7:4] <= ss[7:4] + 1;\n                ss[3:0] <= 4'd0;\n            end\n        end\n        else begin\n            ss[3:0] <= ss[3:0] + 1;\n        end\n    end\nend\n\nendmodule"]}
{"task_id": "lemmings2", "doubao_output": ["    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip-flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule", "    // Define states\n    parameter LEFT = 2'b00, RIGHT = 2'b01, FALL_LEFT = 2'b10, FALL_RIGHT = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (bump_left) next_state = RIGHT;\n                else next_state = LEFT;\n            end\n            RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (bump_right) next_state = LEFT;\n                else next_state = RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            default: next_state = LEFT;\n        endcase\n    end\n\n    // State flip - flops\n    always @(posedge clk or posedge areset) begin\n        if (areset) state <= LEFT;\n        else state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == LEFT);\n    assign walk_right = (state == RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n\nendmodule"]}
{"task_id": "countbcd", "doubao_output": ["always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'b0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'b0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'b0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'b0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule", "always @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'd0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'd0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                    if (q[15:12] == 4'd9) begin\n                        q[15:12] <= 4'd0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\nassign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\nendmodule"]}
